<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W.Ikatti - Vännäsdagarna</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.3);
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #scanlines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.15) 0px,
                rgba(0,0,0,0.15) 1px,
                transparent 1px,
                transparent 3px
            );
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scanlines"></div>
    </div>

    <script>
// ============================================================
//  W.Ikatti - VÄNNÄSDAGARNA
//  A retro 8-bit side-scrolling beat 'em up
// ============================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game resolution (internal) - true 8-bit feel
const GAME_W = 400;
const GAME_H = 240;
const SCALE = 3;

canvas.width = GAME_W * SCALE;
canvas.height = GAME_H * SCALE;
ctx.imageSmoothingEnabled = false;

// Off-screen buffer for pixel-perfect rendering
const buf = document.createElement('canvas');
buf.width = GAME_W;
buf.height = GAME_H;
const bctx = buf.getContext('2d');
bctx.imageSmoothingEnabled = false;

// ============================================================
//  RETRO SOUND ENGINE (Web Audio API chiptune)
// ============================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function ensureAudio() {
    if (!audioCtx) audioCtx = new AudioCtx();
}

function playTone(freq, duration, type = 'square', vol = 0.08) {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = vol;
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
}

function sfxPunch()  { playTone(120, 0.1, 'square', 0.1); playTone(80, 0.15, 'sawtooth', 0.08); }
function sfxHit()    { playTone(200, 0.05); playTone(100, 0.1); }
function sfxHurt()   { playTone(300, 0.1); playTone(150, 0.2, 'sawtooth', 0.06); }
function sfxPickup() { playTone(440, 0.08); playTone(660, 0.08); playTone(880, 0.12); }
function sfxDeath()  { for(let i=0;i<5;i++) setTimeout(()=>playTone(200-i*30, 0.15, 'sawtooth', 0.07), i*100); }
function sfxEPA()    { playTone(60, 0.3, 'sawtooth', 0.04); playTone(55, 0.3, 'square', 0.03); }
function sfxPuke()   { playTone(90, 0.2, 'sawtooth', 0.05); playTone(70, 0.3, 'triangle', 0.04); }
function sfxGunShot(){ playTone(80, 0.04, 'sawtooth', 0.12); playTone(40, 0.08, 'square', 0.1); playTone(200, 0.02, 'square', 0.06); }
function sfxGunPickup(){ playTone(330, 0.06); playTone(440, 0.06); playTone(550, 0.1); playTone(660, 0.08); }
function sfxAmmoPickup(){ playTone(500, 0.05); playTone(600, 0.08); }
function sfxStomp(){ playTone(180, 0.06, 'square', 0.08); playTone(260, 0.08, 'square', 0.06); }

// ============================================================
//  NES-STYLE MULTI-CHANNEL MUSIC ENGINE
// ============================================================
// Note frequency table (octaves 2-6)
const NOTE = {
    C2:65.41,D2:73.42,Eb2:77.78,E2:82.41,F2:87.31,Fs2:92.50,G2:98,Ab2:103.83,A2:110,Bb2:116.54,B2:123.47,
    C3:130.81,D3:146.83,Eb3:155.56,E3:164.81,F3:174.61,Fs3:185,G3:196,Ab3:207.65,A3:220,Bb3:233.08,B3:246.94,
    C4:261.63,Cs4:277.18,D4:293.66,Eb4:311.13,E4:329.63,F4:349.23,Fs4:369.99,G4:392,Ab4:415.30,A4:440,Bb4:466.16,B4:493.88,
    C5:523.25,Cs5:554.37,D5:587.33,Eb5:622.25,E5:659.26,F5:698.46,Fs5:739.99,G5:783.99,Ab5:830.61,A5:880,Bb5:932.33,B5:987.77,
    C6:1046.5,D6:1174.66,E6:1318.51,F6:1396.91,G6:1567.98,A6:1760,
    R:0 // Rest
};

let musicEngine = {
    playing: false,
    currentSong: null,
    bpm: 150,
    ticksPerBeat: 4, // 16th notes
    currentTick: 0,
    channels: [], // active oscillator nodes per channel
    intervalId: null,
    masterGain: null,
};

function stopMusic() {
    if (musicEngine.intervalId) {
        clearInterval(musicEngine.intervalId);
        musicEngine.intervalId = null;
    }
    musicEngine.channels.forEach(ch => {
        if (ch.osc) { try { ch.osc.stop(); } catch(e){} }
        if (ch.osc2) { try { ch.osc2.stop(); } catch(e){} }
    });
    musicEngine.channels = [];
    musicEngine.playing = false;
    musicEngine.currentSong = null;
    // Also clear legacy interval
    if (window._musicInterval) { clearInterval(window._musicInterval); window._musicInterval = null; }
}

function playNoteOnChannel(freq, duration, type, vol, detune) {
    ensureAudio();
    if (freq <= 0) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    if (detune) osc.detune.value = detune;
    gain.gain.setValueAtTime(vol, t);
    gain.gain.setValueAtTime(vol * 0.8, t + duration * 0.6);
    gain.gain.exponentialRampToValueAtTime(0.001, t + duration * 0.95);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + duration);
    return { osc, gain };
}

// Drum sounds using noise + tone
function playKick() {
    ensureAudio();
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(30, t + 0.12);
    gain.gain.setValueAtTime(0.15, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.15);
}

function playSnare() {
    ensureAudio();
    const t = audioCtx.currentTime;
    // Noise burst via buffer
    const bufLen = audioCtx.sampleRate * 0.08;
    const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) data[i] = (Math.random() * 2 - 1);
    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;
    const noiseGain = audioCtx.createGain();
    noiseGain.gain.setValueAtTime(0.1, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    noise.connect(noiseGain); noiseGain.connect(audioCtx.destination);
    noise.start(t); noise.stop(t + 0.08);
    // Tone body
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(180, t);
    osc.frequency.exponentialRampToValueAtTime(60, t + 0.06);
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.07);
}

function playHiHat(open) {
    ensureAudio();
    const t = audioCtx.currentTime;
    const dur = open ? 0.12 : 0.04;
    const bufLen = audioCtx.sampleRate * dur;
    const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) data[i] = (Math.random() * 2 - 1);
    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;
    // Highpass filter for metallic sound
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = open ? 7000 : 9000;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(open ? 0.04 : 0.03, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
    noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
    noise.start(t); noise.stop(t + dur);
}

// ============================================================
//  SONG DEFINITIONS - Level themes
// ============================================================
// Each song has: melody (pulse1), harmony (pulse2), bass (triangle), drums
// Pattern format: array of [noteFreq, durationInTicks]
// Drums format: array of 'K'=kick, 'S'=snare, 'H'=hihat, 'O'=open hat, '.'=rest

// --- LEVEL 1: Upbeat action theme (Mega Man style) ---
const SONG_LEVEL1 = {
    bpm: 160,
    // Energetic, driving melody in E minor / G major
    melody: [
        [NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,2],[NOTE.B5,2],
        [NOTE.A5,2],[NOTE.G5,2],[NOTE.E5,2],[NOTE.D5,2],
        [NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,4],[NOTE.G5,2],[NOTE.E5,2],
        [NOTE.D5,2],[NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,2],
        // Second phrase - higher energy
        [NOTE.B5,2],[NOTE.C6,2],[NOTE.B5,2],[NOTE.A5,2],
        [NOTE.G5,2],[NOTE.A5,2],[NOTE.B5,4],
        [NOTE.A5,2],[NOTE.G5,2],[NOTE.E5,2],[NOTE.G5,2],
        [NOTE.A5,2],[NOTE.G5,2],[NOTE.E5,2],[NOTE.D5,2],
        // Third phrase - triumphant
        [NOTE.E5,2],[NOTE.Fs5,2],[NOTE.G5,2],[NOTE.A5,2],
        [NOTE.B5,4],[NOTE.A5,2],[NOTE.G5,2],
        [NOTE.E5,2],[NOTE.Fs5,2],[NOTE.G5,4],
        [NOTE.A5,2],[NOTE.G5,2],[NOTE.Fs5,2],[NOTE.E5,2],
        // Resolution
        [NOTE.G5,2],[NOTE.Fs5,2],[NOTE.E5,2],[NOTE.D5,2],
        [NOTE.E5,4],[NOTE.R,2],[NOTE.E5,2],
        [NOTE.G5,2],[NOTE.A5,2],[NOTE.B5,2],[NOTE.A5,2],
        [NOTE.G5,4],[NOTE.E5,4],
    ],
    harmony: [
        [NOTE.E4,4],[NOTE.G4,4],[NOTE.A4,4],[NOTE.B4,4],
        [NOTE.E4,4],[NOTE.G4,4],[NOTE.A4,2],[NOTE.G4,2],[NOTE.E4,4],
        [NOTE.D4,4],[NOTE.E4,4],[NOTE.G4,4],[NOTE.A4,4],
        [NOTE.B4,4],[NOTE.C5,4],[NOTE.B4,4],[NOTE.A4,4],
        [NOTE.G4,4],[NOTE.A4,4],[NOTE.B4,8],
        [NOTE.A4,4],[NOTE.G4,4],[NOTE.E4,4],[NOTE.G4,4],
        [NOTE.E4,4],[NOTE.Fs4,4],[NOTE.G4,4],[NOTE.A4,4],
        [NOTE.B4,8],[NOTE.A4,4],[NOTE.G4,4],
        [NOTE.E4,4],[NOTE.Fs4,4],[NOTE.G4,8],
        [NOTE.A4,4],[NOTE.G4,4],[NOTE.Fs4,4],[NOTE.E4,4],
        [NOTE.G4,4],[NOTE.Fs4,4],[NOTE.E4,8],
        [NOTE.G4,4],[NOTE.A4,4],[NOTE.B4,4],[NOTE.A4,4],
        [NOTE.G4,8],[NOTE.E4,8],
    ],
    bass: [
        [NOTE.E2,4],[NOTE.E3,4],[NOTE.G2,4],[NOTE.G3,4],
        [NOTE.A2,4],[NOTE.A3,4],[NOTE.B2,4],[NOTE.B3,4],
        [NOTE.E2,4],[NOTE.E3,4],[NOTE.G2,4],[NOTE.G3,4],
        [NOTE.A2,4],[NOTE.A3,4],[NOTE.E2,4],[NOTE.E3,4],
        [NOTE.D2,4],[NOTE.D3,4],[NOTE.E2,4],[NOTE.E3,4],
        [NOTE.G2,4],[NOTE.G3,4],[NOTE.A2,4],[NOTE.A3,4],
        [NOTE.B2,4],[NOTE.B3,4],[NOTE.C3,4],[NOTE.C4,4],
        [NOTE.A2,4],[NOTE.A3,4],[NOTE.G2,4],[NOTE.A2,4],
        [NOTE.B2,8],[NOTE.A2,4],[NOTE.G2,4],
        [NOTE.E2,4],[NOTE.E3,4],[NOTE.G2,4],[NOTE.G3,4],
        [NOTE.E2,4],[NOTE.Fs2,4],[NOTE.G2,4],[NOTE.A2,4],
        [NOTE.B2,8],[NOTE.A2,4],[NOTE.G2,4],
        [NOTE.E2,4],[NOTE.Fs2,4],[NOTE.G2,8],
        [NOTE.A2,4],[NOTE.G2,4],[NOTE.E2,8],
        [NOTE.G2,4],[NOTE.A2,4],[NOTE.B2,8],
        [NOTE.G2,8],[NOTE.E2,8],
    ],
    // 16th note drum grid - K=kick S=snare H=hat O=open hat .=rest
    drums: 'K.H.S.H.K.H.S.HO' +
           'K.H.S.H.KKH.S.H.' +
           'K.H.S.H.K.H.S.HO' +
           'K.HKS.H.K.H.S.H.' +
           'K.H.S.HOK.H.S.H.' +
           'K.H.S.H.KKH.S.HO' +
           'K.H.S.H.K.H.S.H.' +
           'K.HKS.HOK.HKS.H.',
};

// --- LEVEL 2: Indoor/funky theme (Goonies style) ---
const SONG_LEVEL2 = {
    bpm: 145,
    melody: [
        // Groovy, slightly mysterious - D minor
        [NOTE.D5,2],[NOTE.F5,2],[NOTE.A5,2],[NOTE.G5,2],
        [NOTE.F5,2],[NOTE.E5,2],[NOTE.D5,2],[NOTE.C5,2],
        [NOTE.D5,2],[NOTE.E5,2],[NOTE.F5,4],[NOTE.E5,2],[NOTE.D5,2],
        [NOTE.A4,2],[NOTE.C5,2],[NOTE.D5,4],
        // Second section - higher
        [NOTE.A5,2],[NOTE.G5,2],[NOTE.F5,2],[NOTE.E5,2],
        [NOTE.F5,2],[NOTE.G5,2],[NOTE.A5,4],
        [NOTE.G5,2],[NOTE.F5,2],[NOTE.E5,2],[NOTE.D5,2],
        [NOTE.E5,2],[NOTE.F5,2],[NOTE.D5,4],
        // Bridge - tension
        [NOTE.Bb4,2],[NOTE.C5,2],[NOTE.D5,2],[NOTE.E5,2],
        [NOTE.F5,2],[NOTE.G5,2],[NOTE.A5,2],[NOTE.Bb5,2],
        [NOTE.A5,4],[NOTE.G5,2],[NOTE.F5,2],
        [NOTE.E5,2],[NOTE.D5,2],[NOTE.C5,2],[NOTE.D5,2],
        // Resolution
        [NOTE.D5,2],[NOTE.F5,2],[NOTE.A5,2],[NOTE.G5,2],
        [NOTE.F5,4],[NOTE.D5,4],
        [NOTE.E5,2],[NOTE.F5,2],[NOTE.G5,2],[NOTE.A5,2],
        [NOTE.D5,4],[NOTE.R,4],
    ],
    harmony: [
        [NOTE.D4,4],[NOTE.F4,4],[NOTE.A4,4],[NOTE.G4,4],
        [NOTE.D4,4],[NOTE.F4,4],[NOTE.A4,4],[NOTE.D4,4],
        [NOTE.A3,4],[NOTE.C4,4],[NOTE.D4,8],
        [NOTE.A4,4],[NOTE.G4,4],[NOTE.F4,4],[NOTE.E4,4],
        [NOTE.F4,4],[NOTE.G4,4],[NOTE.A4,8],
        [NOTE.G4,4],[NOTE.F4,4],[NOTE.E4,4],[NOTE.D4,4],
        [NOTE.Bb3,4],[NOTE.C4,4],[NOTE.D4,4],[NOTE.E4,4],
        [NOTE.F4,4],[NOTE.G4,4],[NOTE.A4,4],[NOTE.Bb4,4],
        [NOTE.A4,8],[NOTE.G4,4],[NOTE.F4,4],
        [NOTE.D4,4],[NOTE.F4,4],[NOTE.A4,4],[NOTE.G4,4],
        [NOTE.F4,8],[NOTE.D4,8],
        [NOTE.E4,4],[NOTE.F4,4],[NOTE.G4,4],[NOTE.A4,4],
        [NOTE.D4,8],[NOTE.R,8],
    ],
    bass: [
        [NOTE.D2,4],[NOTE.D3,4],[NOTE.F2,4],[NOTE.F3,4],
        [NOTE.A2,4],[NOTE.A3,4],[NOTE.G2,4],[NOTE.G3,4],
        [NOTE.D2,4],[NOTE.D3,4],[NOTE.A2,4],[NOTE.A3,4],
        [NOTE.D2,4],[NOTE.D3,4],[NOTE.C3,4],[NOTE.D3,4],
        [NOTE.A2,4],[NOTE.A3,4],[NOTE.G2,4],[NOTE.G3,4],
        [NOTE.F2,4],[NOTE.F3,4],[NOTE.A2,8],
        [NOTE.G2,4],[NOTE.F2,4],[NOTE.E2,4],[NOTE.D2,4],
        [NOTE.Bb2,4],[NOTE.C3,4],[NOTE.D3,4],[NOTE.E3,4],
        [NOTE.F2,4],[NOTE.G2,4],[NOTE.A2,4],[NOTE.Bb2,4],
        [NOTE.A2,8],[NOTE.G2,4],[NOTE.F2,4],
        [NOTE.D2,4],[NOTE.D3,4],[NOTE.F2,4],[NOTE.F3,4],
        [NOTE.D2,8],[NOTE.A2,8],
        [NOTE.D2,4],[NOTE.E2,4],[NOTE.F2,4],[NOTE.G2,4],
        [NOTE.D2,8],[NOTE.R,8],
    ],
    drums: 'K.H.S.HOK.H.S.H.' +
           'K.HKS.H.K.H.S.HO' +
           'K.H.S.H.K.HKS.H.' +
           'K.H.S.HOK.HKS.HO' +
           'K.H.S.H.K.H.S.H.' +
           'K.HKS.HOK.H.S.HO' +
           'K.H.S.H.KKH.S.H.' +
           'K.H.SKHOK.HKS.HO',
};

// --- LEVEL 3: Outdoor adventure theme (uplifting, driving) ---
const SONG_LEVEL3 = {
    bpm: 155,
    melody: [
        // Bright, adventurous - C major / A minor
        [NOTE.C5,2],[NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,2],
        [NOTE.G5,2],[NOTE.E5,2],[NOTE.C5,2],[NOTE.D5,2],
        [NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,4],[NOTE.G5,2],[NOTE.E5,2],
        [NOTE.F5,2],[NOTE.E5,2],[NOTE.D5,2],[NOTE.C5,2],
        // Build up
        [NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,2],[NOTE.B5,2],
        [NOTE.C6,4],[NOTE.B5,2],[NOTE.A5,2],
        [NOTE.G5,2],[NOTE.A5,2],[NOTE.G5,2],[NOTE.E5,2],
        [NOTE.D5,2],[NOTE.E5,2],[NOTE.C5,4],
        // Power section
        [NOTE.A5,2],[NOTE.B5,2],[NOTE.C6,2],[NOTE.D6,2],
        [NOTE.C6,2],[NOTE.B5,2],[NOTE.A5,2],[NOTE.G5,2],
        [NOTE.A5,4],[NOTE.G5,2],[NOTE.E5,2],
        [NOTE.F5,2],[NOTE.G5,2],[NOTE.A5,2],[NOTE.G5,2],
        // Resolve
        [NOTE.C5,2],[NOTE.E5,2],[NOTE.G5,2],[NOTE.A5,2],
        [NOTE.G5,4],[NOTE.E5,2],[NOTE.C5,2],
        [NOTE.D5,2],[NOTE.E5,2],[NOTE.F5,2],[NOTE.G5,2],
        [NOTE.C5,4],[NOTE.R,2],[NOTE.C5,2],
    ],
    harmony: [
        [NOTE.C4,4],[NOTE.E4,4],[NOTE.G4,4],[NOTE.A4,4],
        [NOTE.C4,4],[NOTE.E4,4],[NOTE.A4,4],[NOTE.C4,4],
        [NOTE.F4,4],[NOTE.E4,4],[NOTE.D4,4],[NOTE.C4,4],
        [NOTE.E4,4],[NOTE.G4,4],[NOTE.A4,4],[NOTE.B4,4],
        [NOTE.C5,8],[NOTE.B4,4],[NOTE.A4,4],
        [NOTE.G4,4],[NOTE.A4,4],[NOTE.G4,4],[NOTE.E4,4],
        [NOTE.A4,4],[NOTE.B4,4],[NOTE.C5,4],[NOTE.D5,4],
        [NOTE.C5,4],[NOTE.B4,4],[NOTE.A4,4],[NOTE.G4,4],
        [NOTE.A4,8],[NOTE.G4,4],[NOTE.E4,4],
        [NOTE.C4,4],[NOTE.E4,4],[NOTE.G4,4],[NOTE.A4,4],
        [NOTE.G4,8],[NOTE.E4,4],[NOTE.C4,4],
        [NOTE.D4,4],[NOTE.E4,4],[NOTE.F4,4],[NOTE.G4,4],
        [NOTE.C4,8],[NOTE.R,4],[NOTE.C4,4],
    ],
    bass: [
        [NOTE.C2,4],[NOTE.C3,4],[NOTE.E2,4],[NOTE.E3,4],
        [NOTE.G2,4],[NOTE.G3,4],[NOTE.A2,4],[NOTE.A3,4],
        [NOTE.C2,4],[NOTE.C3,4],[NOTE.E2,4],[NOTE.G2,4],
        [NOTE.F2,4],[NOTE.E2,4],[NOTE.D2,4],[NOTE.C2,4],
        [NOTE.E2,4],[NOTE.G2,4],[NOTE.A2,4],[NOTE.B2,4],
        [NOTE.C3,8],[NOTE.B2,4],[NOTE.A2,4],
        [NOTE.G2,4],[NOTE.A2,4],[NOTE.E2,4],[NOTE.G2,4],
        [NOTE.A2,4],[NOTE.B2,4],[NOTE.C3,4],[NOTE.D3,4],
        [NOTE.C3,4],[NOTE.B2,4],[NOTE.A2,4],[NOTE.G2,4],
        [NOTE.A2,8],[NOTE.G2,4],[NOTE.E2,4],
        [NOTE.C2,4],[NOTE.E2,4],[NOTE.G2,4],[NOTE.A2,4],
        [NOTE.G2,8],[NOTE.E2,4],[NOTE.C2,4],
        [NOTE.D2,4],[NOTE.E2,4],[NOTE.F2,4],[NOTE.G2,4],
        [NOTE.C2,8],[NOTE.R,4],[NOTE.C2,4],
    ],
    drums: 'K.H.S.H.K.H.S.HO' +
           'K.HKS.H.K.H.S.H.' +
           'K.H.S.HOK.HKS.HO' +
           'K.H.S.H.K.H.S.H.' +
           'K.HKS.HOK.H.S.H.' +
           'K.H.S.H.KKH.S.HO' +
           'K.HKS.H.K.HKS.HO' +
           'K.H.S.HOK.H.SKHO',
};

// --- BOSS FIGHT: Intense, aggressive theme ---
const SONG_BOSS = {
    bpm: 175,
    melody: [
        // Fast, aggressive - E minor
        [NOTE.E5,1],[NOTE.E5,1],[NOTE.R,1],[NOTE.E5,1],[NOTE.R,1],[NOTE.G5,1],[NOTE.E5,2],
        [NOTE.D5,1],[NOTE.E5,1],[NOTE.R,1],[NOTE.E5,1],[NOTE.G5,1],[NOTE.A5,1],[NOTE.G5,2],
        [NOTE.E5,1],[NOTE.E5,1],[NOTE.R,1],[NOTE.B5,1],[NOTE.A5,1],[NOTE.G5,1],[NOTE.E5,2],
        [NOTE.D5,1],[NOTE.E5,1],[NOTE.G5,2],[NOTE.A5,1],[NOTE.B5,1],[NOTE.A5,2],
        // Intense section
        [NOTE.B5,1],[NOTE.B5,1],[NOTE.R,1],[NOTE.B5,1],[NOTE.C6,1],[NOTE.B5,1],[NOTE.A5,2],
        [NOTE.G5,1],[NOTE.A5,1],[NOTE.B5,2],[NOTE.A5,1],[NOTE.G5,1],[NOTE.E5,2],
        [NOTE.E5,1],[NOTE.G5,1],[NOTE.A5,1],[NOTE.B5,1],[NOTE.C6,2],[NOTE.B5,2],
        [NOTE.A5,1],[NOTE.G5,1],[NOTE.E5,1],[NOTE.D5,1],[NOTE.E5,4],
    ],
    harmony: [
        [NOTE.E4,2],[NOTE.R,2],[NOTE.E4,2],[NOTE.G4,2],
        [NOTE.D4,2],[NOTE.E4,2],[NOTE.G4,2],[NOTE.A4,2],
        [NOTE.E4,2],[NOTE.R,2],[NOTE.B4,2],[NOTE.A4,2],
        [NOTE.D4,2],[NOTE.E4,2],[NOTE.G4,4],
        [NOTE.B4,2],[NOTE.R,2],[NOTE.B4,2],[NOTE.A4,2],
        [NOTE.G4,2],[NOTE.A4,2],[NOTE.B4,4],
        [NOTE.E4,2],[NOTE.G4,2],[NOTE.A4,2],[NOTE.B4,2],
        [NOTE.A4,2],[NOTE.G4,2],[NOTE.E4,4],
    ],
    bass: [
        [NOTE.E2,2],[NOTE.E3,2],[NOTE.E2,2],[NOTE.E3,2],
        [NOTE.D2,2],[NOTE.D3,2],[NOTE.E2,2],[NOTE.E3,2],
        [NOTE.E2,2],[NOTE.E3,2],[NOTE.G2,2],[NOTE.G3,2],
        [NOTE.D2,2],[NOTE.E2,2],[NOTE.G2,2],[NOTE.A2,2],
        [NOTE.B2,2],[NOTE.B3,2],[NOTE.B2,2],[NOTE.A2,2],
        [NOTE.G2,2],[NOTE.A2,2],[NOTE.B2,2],[NOTE.B3,2],
        [NOTE.E2,2],[NOTE.G2,2],[NOTE.A2,2],[NOTE.B2,2],
        [NOTE.A2,2],[NOTE.G2,2],[NOTE.E2,2],[NOTE.E3,2],
    ],
    drums: 'KKH.S.HOKKHKS.HO' +
           'KKH.SKHOKKHKS.HO' +
           'KKH.S.HOKKHKS.H.' +
           'KKHKSKHOKKH.SKHO' +
           'KKH.S.HOKKHKS.HO' +
           'KKH.SKHOKKHKS.HO' +
           'KKHKS.HOKKHKS.H.' +
           'KKHKSKHOKKH.SKHO',
};

// --- SKRAECKOEDLAN: Super Heavy Doom Stoner Rock ---
const SONG_STONER = {
    bpm: 65,
    melody: [
        // Crushing doom riff - E minor with tritone (E-Bb = devil's interval)
        [NOTE.E3,8],[NOTE.R,4],[NOTE.E3,4],
        [NOTE.G3,4],[NOTE.A3,4],[NOTE.G3,4],[NOTE.E3,4],
        [NOTE.D3,8],[NOTE.R,4],[NOTE.D3,4],
        [NOTE.E3,4],[NOTE.G3,4],[NOTE.E3,4],[NOTE.D3,4],
        // Ascending doom with tritone
        [NOTE.E3,8],[NOTE.G3,8],
        [NOTE.A3,8],[NOTE.Bb3,8],
        // Descending heavy resolve
        [NOTE.A3,8],[NOTE.G3,8],
        [NOTE.E3,8],[NOTE.R,8],
    ],
    harmony: [
        // Power chord fifths
        [NOTE.B3,8],[NOTE.R,4],[NOTE.B3,4],
        [NOTE.D4,4],[NOTE.E4,4],[NOTE.D4,4],[NOTE.B3,4],
        [NOTE.A3,8],[NOTE.R,4],[NOTE.A3,4],
        [NOTE.B3,4],[NOTE.D4,4],[NOTE.B3,4],[NOTE.A3,4],
        // Ascending fifths
        [NOTE.B3,8],[NOTE.D4,8],
        [NOTE.E4,8],[NOTE.F4,8],
        // Descending
        [NOTE.E4,8],[NOTE.D4,8],
        [NOTE.B3,8],[NOTE.R,8],
    ],
    bass: [
        // Super heavy bass rumble
        [NOTE.E2,4],[NOTE.E2,4],[NOTE.E2,4],[NOTE.R,4],
        [NOTE.E2,4],[NOTE.G2,4],[NOTE.A2,4],[NOTE.G2,4],
        [NOTE.D2,4],[NOTE.D2,4],[NOTE.D2,4],[NOTE.R,4],
        [NOTE.D2,4],[NOTE.E2,4],[NOTE.G2,4],[NOTE.D2,4],
        // Follow melody
        [NOTE.E2,4],[NOTE.E2,4],[NOTE.G2,4],[NOTE.G2,4],
        [NOTE.A2,4],[NOTE.A2,4],[NOTE.B2,4],[NOTE.B2,4],
        // Resolve
        [NOTE.A2,4],[NOTE.A2,4],[NOTE.G2,4],[NOTE.G2,4],
        [NOTE.E2,4],[NOTE.E2,4],[NOTE.E2,4],[NOTE.R,4],
    ],
    drums: 'K...S...K...S...' +
           'K...S...K.K.S...' +
           'K...S...K...S...' +
           'K...SK..K.K.S...' +
           'K...S...K...S...' +
           'K...S...K.K.S...' +
           'K...S.K.K...S...' +
           'K.K.S.K.K.K.SKHO',
};

// --- Song player ---
function playSong(song) {
    ensureAudio();
    stopMusic();
    musicEngine.currentSong = song;
    musicEngine.playing = true;
    musicEngine.currentTick = 0;

    const tpb = 4; // ticks per beat (16th notes)
    const tickDuration = 60 / (song.bpm * tpb);
    const tickMs = tickDuration * 1000;

    // Track positions in each pattern
    let melodyIdx = 0, melodyTicksLeft = 0;
    let harmonyIdx = 0, harmonyTicksLeft = 0;
    let bassIdx = 0, bassTicksLeft = 0;
    let drumIdx = 0;

    const mel = song.melody;
    const har = song.harmony;
    const bas = song.bass;
    const drm = song.drums;

    musicEngine.intervalId = setInterval(() => {
        if (game.state !== 'playing' && game.state !== 'victory' && game.state !== 'cutscene') return;

        // --- MELODY (Pulse 1) ---
        if (melodyTicksLeft <= 0 && mel.length > 0) {
            const entry = mel[melodyIdx % mel.length];
            const freq = entry[0];
            const dur = entry[1];
            melodyTicksLeft = dur;
            if (freq > 0) {
                playNoteOnChannel(freq, dur * tickDuration * 0.9, 'square', 0.04, 0);
            }
            melodyIdx++;
        }
        melodyTicksLeft--;

        // --- HARMONY (Pulse 2) ---
        if (harmonyTicksLeft <= 0 && har.length > 0) {
            const entry = har[harmonyIdx % har.length];
            const freq = entry[0];
            const dur = entry[1];
            harmonyTicksLeft = dur;
            if (freq > 0) {
                playNoteOnChannel(freq, dur * tickDuration * 0.85, 'square', 0.02, 7);
            }
            harmonyIdx++;
        }
        harmonyTicksLeft--;

        // --- BASS (Triangle) ---
        if (bassTicksLeft <= 0 && bas.length > 0) {
            const entry = bas[bassIdx % bas.length];
            const freq = entry[0];
            const dur = entry[1];
            bassTicksLeft = dur;
            if (freq > 0) {
                playNoteOnChannel(freq, dur * tickDuration * 0.9, 'triangle', 0.06, 0);
            }
            bassIdx++;
        }
        bassTicksLeft--;

        // --- DRUMS (Noise) ---
        if (drm.length > 0) {
            const dc = drm[drumIdx % drm.length];
            if (dc === 'K') playKick();
            else if (dc === 'S') playSnare();
            else if (dc === 'H') playHiHat(false);
            else if (dc === 'O') playHiHat(true);
            drumIdx++;
        }

        musicEngine.currentTick++;
    }, tickMs);
}

// Main entry point - selects song based on current level
function playMusic() {
    ensureAudio();
    const lvl = game.level || 1;
    if (lvl === 3) playSong(SONG_LEVEL3);
    else if (lvl === 2) playSong(SONG_LEVEL2);
    else playSong(SONG_LEVEL1);
}

// Switch to boss music
function playBossMusic() {
    if (musicEngine.currentSong === SONG_BOSS) return;
    playSong(SONG_BOSS);
}

// Switch back to level music after boss
function playLevelMusic() {
    playMusic();
}

// Special heavy stoner doom player for SKRAECKOEDLAN (sawtooth + louder)
function playSkraeckoedlanMusic() {
    ensureAudio();
    stopMusic();
    const song = SONG_STONER;
    musicEngine.currentSong = song;
    musicEngine.playing = true;
    musicEngine.currentTick = 0;
    const tpb = 4;
    const tickDuration = 60 / (song.bpm * tpb);
    const tickMs = tickDuration * 1000;
    let melodyIdx = 0, melodyTicksLeft = 0;
    let harmonyIdx = 0, harmonyTicksLeft = 0;
    let bassIdx = 0, bassTicksLeft = 0;
    let drumIdx = 0;
    const mel = song.melody, har = song.harmony, bas = song.bass, drm = song.drums;
    musicEngine.intervalId = setInterval(() => {
        if (game.state !== 'playing' && game.state !== 'victory' && game.state !== 'cutscene') return;
        // MELODY - heavy sawtooth wave, louder
        if (melodyTicksLeft <= 0 && mel.length > 0) {
            const entry = mel[melodyIdx % mel.length];
            melodyTicksLeft = entry[1];
            if (entry[0] > 0) playNoteOnChannel(entry[0], entry[1] * tickDuration * 0.9, 'sawtooth', 0.06, 0);
            melodyIdx++;
        }
        melodyTicksLeft--;
        // HARMONY - distorted square, thicker detune
        if (harmonyTicksLeft <= 0 && har.length > 0) {
            const entry = har[harmonyIdx % har.length];
            harmonyTicksLeft = entry[1];
            if (entry[0] > 0) playNoteOnChannel(entry[0], entry[1] * tickDuration * 0.85, 'square', 0.04, 12);
            harmonyIdx++;
        }
        harmonyTicksLeft--;
        // BASS - crushing sawtooth, extra loud
        if (bassTicksLeft <= 0 && bas.length > 0) {
            const entry = bas[bassIdx % bas.length];
            bassTicksLeft = entry[1];
            if (entry[0] > 0) playNoteOnChannel(entry[0], entry[1] * tickDuration * 0.9, 'sawtooth', 0.09, 0);
            bassIdx++;
        }
        bassTicksLeft--;
        // DRUMS - heavy
        if (drm.length > 0) {
            const dc = drm[drumIdx % drm.length];
            if (dc === 'K') playKick();
            else if (dc === 'S') playSnare();
            else if (dc === 'H') playHiHat(false);
            else if (dc === 'O') playHiHat(true);
            drumIdx++;
        }
        musicEngine.currentTick++;
    }, tickMs);
}

// ============================================================
//  COLOR PALETTE (NES-inspired)
// ============================================================
const PAL = {
    black:      '#0f0f0f',
    darkblue:   '#1d2b53',
    darkpurple: '#7e2553',
    darkgreen:  '#008751',
    brown:      '#ab5236',
    darkgrey:   '#5f574f',
    grey:       '#c2c3c7',
    white:      '#fff1e8',
    red:        '#ff004d',
    orange:     '#ffa300',
    yellow:     '#ffec27',
    green:      '#00e436',
    blue:       '#29adff',
    indigo:     '#83769c',
    pink:       '#ff77a8',
    peach:      '#ffccaa',
    sky:        '#7ec8e3',
    cream:      '#f0e6d2',
    darkbrown:  '#6d3c1b',
    icared:     '#cc0000',
    systemblue: '#003366',
    asphalt:    '#3a3a3a',
    pavement:   '#8a8a7a',
};

// ============================================================
//  INPUT
// ============================================================
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });
window.addEventListener('mousedown', e => { keys['Mouse0'] = true; });
window.addEventListener('mouseup', e => { keys['Mouse0'] = false; });

// ============================================================
//  PIXEL ART DRAWING HELPERS
// ============================================================
function drawPixel(x, y, color) {
    bctx.fillStyle = color;
    bctx.fillRect(Math.floor(x), Math.floor(y), 1, 1);
}

function drawRect(x, y, w, h, color) {
    bctx.fillStyle = color;
    bctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

function drawText(text, x, y, color = PAL.white, size = 1) {
    bctx.fillStyle = color;
    // Simple pixel font rendering
    const chars = text.toUpperCase();
    let cx = Math.floor(x);
    for (let i = 0; i < chars.length; i++) {
        drawChar(chars[i], cx, Math.floor(y), color, size);
        cx += 6 * size;
    }
}

// Tiny 5x5 pixel font
const FONT = {
    'A': [0b01110,0b10001,0b11111,0b10001,0b10001],
    'B': [0b11110,0b10001,0b11110,0b10001,0b11110],
    'C': [0b01111,0b10000,0b10000,0b10000,0b01111],
    'D': [0b11110,0b10001,0b10001,0b10001,0b11110],
    'E': [0b11111,0b10000,0b11110,0b10000,0b11111],
    'F': [0b11111,0b10000,0b11110,0b10000,0b10000],
    'G': [0b01111,0b10000,0b10011,0b10001,0b01111],
    'H': [0b10001,0b10001,0b11111,0b10001,0b10001],
    'I': [0b11111,0b00100,0b00100,0b00100,0b11111],
    'J': [0b11111,0b00010,0b00010,0b10010,0b01100],
    'K': [0b10001,0b10010,0b11100,0b10010,0b10001],
    'L': [0b10000,0b10000,0b10000,0b10000,0b11111],
    'M': [0b10001,0b11011,0b10101,0b10001,0b10001],
    'N': [0b10001,0b11001,0b10101,0b10011,0b10001],
    'O': [0b01110,0b10001,0b10001,0b10001,0b01110],
    'P': [0b11110,0b10001,0b11110,0b10000,0b10000],
    'Q': [0b01110,0b10001,0b10101,0b10010,0b01101],
    'R': [0b11110,0b10001,0b11110,0b10010,0b10001],
    'S': [0b01111,0b10000,0b01110,0b00001,0b11110],
    'T': [0b11111,0b00100,0b00100,0b00100,0b00100],
    'U': [0b10001,0b10001,0b10001,0b10001,0b01110],
    'V': [0b10001,0b10001,0b10001,0b01010,0b00100],
    'W': [0b10001,0b10001,0b10101,0b11011,0b10001],
    'X': [0b10001,0b01010,0b00100,0b01010,0b10001],
    'Y': [0b10001,0b01010,0b00100,0b00100,0b00100],
    'Z': [0b11111,0b00010,0b00100,0b01000,0b11111],
    '0': [0b01110,0b10011,0b10101,0b11001,0b01110],
    '1': [0b00100,0b01100,0b00100,0b00100,0b11111],
    '2': [0b01110,0b10001,0b00110,0b01000,0b11111],
    '3': [0b11110,0b00001,0b01110,0b00001,0b11110],
    '4': [0b10001,0b10001,0b11111,0b00001,0b00001],
    '5': [0b11111,0b10000,0b11110,0b00001,0b11110],
    '6': [0b01111,0b10000,0b11110,0b10001,0b01110],
    '7': [0b11111,0b00001,0b00010,0b00100,0b00100],
    '8': [0b01110,0b10001,0b01110,0b10001,0b01110],
    '9': [0b01110,0b10001,0b01111,0b00001,0b11110],
    ' ': [0b00000,0b00000,0b00000,0b00000,0b00000],
    '.': [0b00000,0b00000,0b00000,0b00000,0b00100],
    '!': [0b00100,0b00100,0b00100,0b00000,0b00100],
    '-': [0b00000,0b00000,0b11111,0b00000,0b00000],
    ':': [0b00000,0b00100,0b00000,0b00100,0b00000],
    '/': [0b00001,0b00010,0b00100,0b01000,0b10000],
    ',': [0b00000,0b00000,0b00000,0b00100,0b01000],
    'Ä': [0b01010,0b01110,0b10001,0b11111,0b10001],
    'Ö': [0b01010,0b01110,0b10001,0b10001,0b01110],
    'Å': [0b00100,0b01110,0b10001,0b11111,0b10001],
    '\'': [0b00100,0b00100,0b00000,0b00000,0b00000],
    '+': [0b00000,0b00100,0b01110,0b00100,0b00000],
    'x': [0b00000,0b01010,0b00100,0b01010,0b00000],
};

function drawChar(ch, x, y, color, size) {
    const bitmap = FONT[ch];
    if (!bitmap) return;
    bctx.fillStyle = color;
    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
            if (bitmap[row] & (1 << (4 - col))) {
                bctx.fillRect(x + col * size, y + row * size, size, size);
            }
        }
    }
}

// ============================================================
//  SPRITE DEFINITIONS (Pixel art as 2D arrays)
// ============================================================

// Extra shading colors
const SH = {
    skinHi:   '#ffe0c0',
    skinLo:   '#d4a574',
    hairHi:   '#c4854a',
    hairLo:   '#6b3a1a',
    shirtHi:  '#5bc0ff',
    shirtLo:  '#1868a8',
    shirtMid: '#3399dd',
    pantsHi:  '#2a3f6e',
    pantsLo:  '#0d1b36',
    bootHi:   '#8a5a2a',
    bootLo:   '#3a1a0a',
    eyeWhite: '#e8e8e8',
    mouth:    '#c06060',
    belt:     '#555555',
    beltBkl:  '#ccaa44',
    epaBody:  '#2a7a2a',
    epaDark:  '#1a5a1a',
    epaLight: '#44bb44',
    epaRust:  '#8a6a3a',
    tireDark: '#1a1a1a',
    tireMid:  '#333333',
    tireHi:   '#4a4a4a',
    hubcap:   '#888888',
    chrome:   '#aaaaaa',
    chromHi:  '#cccccc',
    window:   '#88bbdd',
    winHi:    '#aaddff',
    drunkHat: '#ff4488',
    drunkShirt:'#dd2244',
    drunkSh2: '#aa1133',
    beer:     '#ddaa22',
    beerFoam: '#ffffcc',
    pukeGrn:  '#55cc33',
    pukeDrk:  '#338822',
};

function drawSprite(sprite, x, y, flipX = false) {
    for (let row = 0; row < sprite.length; row++) {
        for (let col = 0; col < sprite[row].length; col++) {
            const color = sprite[row][col];
            if (color) {
                const dx = flipX ? (sprite[row].length - 1 - col) : col;
                drawPixel(x + dx, y + row, color);
            }
        }
    }
}

// Draw sprite at 2x scale for main characters
function drawSprite2x(sprite, x, y, flipX = false) {
    for (let row = 0; row < sprite.length; row++) {
        for (let col = 0; col < sprite[row].length; col++) {
            const color = sprite[row][col];
            if (color) {
                const dx = flipX ? (sprite[row].length - 1 - col) * 2 : col * 2;
                bctx.fillStyle = color;
                bctx.fillRect(Math.floor(x + dx), Math.floor(y + row * 2), 2, 2);
            }
        }
    }
}

// W.Ikatti - the hero! (16x18 detailed pixel art sprite)
const P = PAL;
function getPlayerSprite(frame, attacking) {
    const _ = null;
    // Detailed color palette for W.Ikatti
    const s = SH.skinHi;     // Skin highlight
    const S = P.peach;       // Skin mid
    const q = SH.skinLo;     // Skin shadow
    const h = SH.hairHi;     // Hair highlight
    const H = P.brown;       // Hair mid
    const j = SH.hairLo;     // Hair shadow
    const t = SH.shirtHi;    // Shirt highlight
    const T = SH.shirtMid;   // Shirt mid
    const u = SH.shirtLo;    // Shirt shadow
    const l = SH.pantsHi;    // Pants highlight
    const L = P.darkblue;    // Pants mid
    const m = SH.pantsLo;    // Pants shadow
    const b = SH.bootHi;     // Boot highlight
    const B = P.darkbrown;   // Boot mid
    const c = SH.bootLo;     // Boot shadow
    const E = P.black;       // Eyes
    const W = SH.eyeWhite;   // Eye whites
    const M = SH.mouth;      // Mouth
    const K = SH.belt;       // Belt
    const G = SH.beltBkl;    // Belt buckle

    if (attacking) {
        // Straight punch - arm fully extended with fist
        return [
            [_,_,_,j,H,H,H,h,_,_,_,_,_,_,_,_],
            [_,_,j,H,H,h,H,H,h,_,_,_,_,_,_,_],
            [_,_,j,H,h,h,H,h,h,_,_,_,_,_,_,_],
            [_,_,S,S,W,E,S,W,E,_,_,_,_,_,_,_],
            [_,_,q,S,S,S,S,S,S,_,_,_,_,_,_,_],
            [_,_,_,q,S,M,S,q,_,_,_,_,_,_,_,_],
            [_,_,u,T,T,T,T,T,t,_,_,_,_,_,_,_],
            [_,u,T,T,t,T,T,t,T,S,S,S,S,S,q,_],
            [_,u,T,T,T,T,T,T,T,S,S,S,S,q,S,_],
            [_,_,u,T,T,T,T,T,u,_,_,_,_,_,_,_],
            [_,_,q,K,G,K,K,K,q,_,_,_,_,_,_,_],
            [_,_,_,l,L,L,L,l,_,_,_,_,_,_,_,_],
            [_,_,_,L,L,m,L,L,_,_,_,_,_,_,_,_],
            [_,_,_,m,L,_,m,L,_,_,_,_,_,_,_,_],
            [_,_,c,B,b,_,c,B,b,_,_,_,_,_,_,_],
            [_,_,c,B,b,_,c,B,b,_,_,_,_,_,_,_],
        ];
    }

    // 4-frame walk cycle with full shading
    const walk0 = [ // Standing / contact right
        [_,_,_,j,H,H,H,h,_,_,_,_,_,_,_,_],
        [_,_,j,H,H,h,H,H,h,_,_,_,_,_,_,_],
        [_,_,j,H,h,h,H,h,h,_,_,_,_,_,_,_],
        [_,_,S,S,W,E,S,W,E,_,_,_,_,_,_,_],
        [_,_,q,S,S,S,S,S,S,_,_,_,_,_,_,_],
        [_,_,_,q,S,M,S,q,_,_,_,_,_,_,_,_],
        [_,_,u,T,T,T,T,T,t,_,_,_,_,_,_,_],
        [_,u,T,T,t,T,T,t,T,_,_,_,_,_,_,_],
        [_,u,T,T,T,T,T,T,T,_,_,_,_,_,_,_],
        [_,_,q,T,T,T,T,T,q,_,_,_,_,_,_,_],
        [_,_,_,K,G,K,K,K,_,_,_,_,_,_,_,_],
        [_,_,_,l,L,L,L,l,_,_,_,_,_,_,_,_],
        [_,_,l,L,m,_,_,L,l,_,_,_,_,_,_,_],
        [_,_,L,m,_,_,_,m,L,_,_,_,_,_,_,_],
        [_,c,B,b,_,_,_,c,B,b,_,_,_,_,_,_],
        [_,c,B,B,b,_,_,c,B,b,_,_,_,_,_,_],
    ];

    const walk1 = [ // Passing right
        [_,_,_,j,H,H,H,h,_,_,_,_,_,_,_,_],
        [_,_,j,H,H,h,H,H,h,_,_,_,_,_,_,_],
        [_,_,j,H,h,h,H,h,h,_,_,_,_,_,_,_],
        [_,_,S,S,W,E,S,W,E,_,_,_,_,_,_,_],
        [_,_,q,S,S,S,S,S,S,_,_,_,_,_,_,_],
        [_,_,_,q,S,M,S,q,_,_,_,_,_,_,_,_],
        [_,_,u,T,T,T,T,T,t,_,_,_,_,_,_,_],
        [_,u,T,T,t,T,T,t,T,_,_,_,_,_,_,_],
        [_,u,T,T,T,T,T,T,T,_,_,_,_,_,_,_],
        [_,_,q,T,T,T,T,T,q,_,_,_,_,_,_,_],
        [_,_,_,K,G,K,K,K,_,_,_,_,_,_,_,_],
        [_,_,_,l,L,L,L,l,_,_,_,_,_,_,_,_],
        [_,_,_,L,L,L,L,L,_,_,_,_,_,_,_,_],
        [_,_,_,m,L,_,L,m,_,_,_,_,_,_,_,_],
        [_,_,_,c,B,_,c,B,_,_,_,_,_,_,_,_],
        [_,_,_,c,B,b,c,B,b,_,_,_,_,_,_,_],
    ];

    const walk2 = [ // Contact left
        [_,_,_,j,H,H,H,h,_,_,_,_,_,_,_,_],
        [_,_,j,H,H,h,H,H,h,_,_,_,_,_,_,_],
        [_,_,j,H,h,h,H,h,h,_,_,_,_,_,_,_],
        [_,_,S,S,W,E,S,W,E,_,_,_,_,_,_,_],
        [_,_,q,S,S,S,S,S,S,_,_,_,_,_,_,_],
        [_,_,_,q,S,M,S,q,_,_,_,_,_,_,_,_],
        [_,_,u,T,T,T,T,T,t,_,_,_,_,_,_,_],
        [_,u,T,T,t,T,T,t,T,_,_,_,_,_,_,_],
        [_,u,T,T,T,T,T,T,T,_,_,_,_,_,_,_],
        [_,_,q,T,T,T,T,T,q,_,_,_,_,_,_,_],
        [_,_,_,K,G,K,K,K,_,_,_,_,_,_,_,_],
        [_,_,_,l,L,L,L,l,_,_,_,_,_,_,_,_],
        [_,_,_,L,l,_,l,L,_,_,_,_,_,_,_,_],
        [_,_,m,L,_,_,_,L,m,_,_,_,_,_,_,_],
        [_,c,B,b,_,_,c,B,b,_,_,_,_,_,_,_],
        [_,c,B,B,b,_,c,B,B,b,_,_,_,_,_,_],
    ];

    const walk3 = [ // Passing left
        [_,_,_,j,H,H,H,h,_,_,_,_,_,_,_,_],
        [_,_,j,H,H,h,H,H,h,_,_,_,_,_,_,_],
        [_,_,j,H,h,h,H,h,h,_,_,_,_,_,_,_],
        [_,_,S,S,W,E,S,W,E,_,_,_,_,_,_,_],
        [_,_,q,S,S,S,S,S,S,_,_,_,_,_,_,_],
        [_,_,_,q,S,M,S,q,_,_,_,_,_,_,_,_],
        [_,_,u,T,T,T,T,T,t,_,_,_,_,_,_,_],
        [_,u,T,T,t,T,T,t,T,_,_,_,_,_,_,_],
        [_,u,T,T,T,T,T,T,T,_,_,_,_,_,_,_],
        [_,_,q,T,T,T,T,T,q,_,_,_,_,_,_,_],
        [_,_,_,K,G,K,K,K,_,_,_,_,_,_,_,_],
        [_,_,_,l,L,L,L,l,_,_,_,_,_,_,_,_],
        [_,_,_,L,L,L,L,L,_,_,_,_,_,_,_,_],
        [_,_,_,L,m,_,m,L,_,_,_,_,_,_,_,_],
        [_,_,_,B,c,_,B,c,_,_,_,_,_,_,_,_],
        [_,_,c,B,b,_,c,B,b,_,_,_,_,_,_,_],
    ];

    const frames = [walk0, walk1, walk2, walk3];
    return frames[frame % 4];
}

// EPA-traktor sprite (32x22) - Realistic Volvo 240 sedan with slow-vehicle triangle
// Car faces LEFT (direction of travel): headlights left, taillights right
function getEPASprite(frame) {
    const _ = null;
    const M = SH.epaBody;   // Body
    const D = SH.epaDark;   // Body shadow
    const G = SH.epaLight;  // Body highlight
    const K = SH.tireDark;  // Tire dark
    const k = SH.tireMid;   // Tire mid
    const g = SH.tireHi;    // Tire highlight
    const H = SH.hubcap;    // Hubcap
    const W = SH.window;    // Window
    const w = SH.winHi;     // Window highlight
    const R = P.red;        // Rear lights
    const r = '#cc0000';    // Dark red
    const Y = P.yellow;     // Headlights
    const y = '#ddaa00';    // Headlight dim
    const C = SH.chrome;    // Chrome
    const c = SH.chromHi;   // Chrome highlight
    const O = P.orange;     // Triangle border
    const U = SH.epaRust;   // Rust patches
    const X = P.black;      // Outlines

    return [
        [_,_,_,_,_,_,_,_,_,X,X,X,X,X,X,X,X,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_],
        [_,_,_,_,_,_,_,_,X,D,D,M,M,M,M,M,M,M,M,G,G,G,X,_,_,_,_,_,_,_,_,_],
        [_,_,_,_,_,_,_,X,W,W,w,X,W,W,W,W,X,W,W,w,W,D,X,_,_,_,_,_,_,_,_,_],
        [_,_,_,_,_,_,X,D,W,W,w,X,W,W,W,W,X,W,W,w,D,D,X,_,_,_,_,_,_,_,_,_],
        [_,_,_,_,_,X,D,M,X,X,X,X,X,X,X,X,X,X,X,X,M,G,G,X,_,_,_,_,_,_,_,_],
        [_,_,_,X,X,D,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,G,G,X,X,X,_,_,_,_,_],
        [_,_,X,D,D,M,M,M,M,M,M,M,D,M,M,M,M,M,M,M,M,M,M,M,G,G,G,X,_,_,_,_],
        [_,_,X,D,M,M,M,M,c,M,M,M,D,M,M,c,M,M,M,M,M,M,M,M,M,M,G,X,_,_,_,_],
        [_,_,X,D,M,M,M,M,M,M,M,M,D,M,M,M,M,M,U,M,M,M,O,O,O,G,G,X,_,_,_,_],
        [Y,Y,X,D,M,M,M,M,M,M,M,M,D,M,M,M,M,M,M,M,M,M,O,R,O,G,G,X,R,R,_,_],
        [y,Y,X,D,M,M,M,M,M,M,M,M,D,M,M,M,M,M,M,M,M,O,R,R,R,O,G,X,R,r,_,_],
        [_,y,X,C,c,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,O,O,O,C,c,X,r,_,_,_],
        [_,_,X,D,M,M,_,_,_,_,_,M,M,M,M,M,M,M,M,M,_,_,_,_,_,M,G,X,_,_,_,_],
        [_,_,X,_,_,_,k,K,K,k,_,_,_,_,_,_,_,_,_,_,_,k,K,K,k,_,_,X,_,_,_,_],
        [_,_,_,_,_,k,K,K,K,K,k,_,_,_,_,_,_,_,_,_,k,K,K,K,K,k,_,_,_,_,_,_],
        [_,_,_,_,k,K,K,H,H,K,K,k,_,_,_,_,_,_,_,k,K,K,H,H,K,K,k,_,_,_,_,_],
        [_,_,_,_,k,K,K,H,H,K,K,k,_,_,_,_,_,_,_,k,K,K,H,H,K,K,k,_,_,_,_,_],
        [_,_,_,_,_,k,K,K,K,K,k,_,_,_,_,_,_,_,_,_,k,K,K,K,K,k,_,_,_,_,_,_],
        [_,_,_,_,_,_,k,K,K,k,_,_,_,_,_,_,_,_,_,_,_,k,K,K,k,_,_,_,_,_,_,_],
        [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
        [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
        [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
    ];
}

// Drunk person sprite (14x17) - detailed with party hat and beer
function getDrunkSprite(frame, puking) {
    const _ = null;
    const s = SH.skinHi;     // Skin light
    const S = P.peach;       // Skin
    const q = SH.skinLo;     // Skin shadow
    const H = P.orange;      // Hair
    const h = '#dd8822';     // Hair shadow
    const T = SH.drunkShirt; // Shirt
    const t = SH.drunkSh2;   // Shirt shadow
    const L = P.darkblue;    // Pants
    const l = '#0d1b36';     // Pants shadow
    const B = P.black;       // Shoes
    const E = P.black;       // Eyes
    const W = SH.eyeWhite;   // Eye white
    const G = SH.pukeGrn;    // Puke
    const g = SH.pukeDrk;    // Puke dark
    const P2= SH.drunkHat;   // Party hat
    const p = '#cc3366';     // Hat shadow
    const D = SH.beer;       // Beer bottle
    const d = SH.beerFoam;   // Beer foam
    const X = P.black;       // Outline

    if (puking) {
        return [
            [_,_,_,_,P2,_,_,_,_,_,_,_,_,_],
            [_,_,_,P2,P2,P2,_,_,_,_,_,_,_,_],
            [_,_,h,H,H,H,H,h,_,_,_,_,_,_],
            [_,_,H,H,H,H,H,H,_,_,_,_,_,_],
            [_,_,S,W,E,S,W,E,q,_,_,_,_,_],
            [_,_,q,S,S,S,S,S,q,G,G,_,_,_],
            [_,_,_,q,S,S,q,_,_,G,G,G,_,_],
            [_,_,t,T,T,T,T,T,_,_,g,G,G,_],
            [_,t,T,T,T,T,T,T,_,_,_,G,_,_],
            [_,t,T,T,T,T,T,T,_,_,_,_,_,_],
            [_,_,q,T,T,T,q,_,_,_,_,_,_,_],
            [_,_,_,L,L,L,L,_,_,_,_,_,_,_],
            [_,_,_,L,l,l,L,_,_,_,_,_,_,_],
            [_,_,_,l,_,_,l,_,_,_,_,_,_,_],
            [_,_,B,B,_,_,B,B,_,_,_,_,_,_],
        ];
    }

    // 4-frame wobble cycle
    const f = frame % 4;
    const wobbleX = f < 2 ? 0 : 1;
    const leanR = f === 1 || f === 2;

    return [
        [_,_,_,_,P2,_,_,_,_,_,_,_,_,_],
        [_,_,_,P2,P2,P2,_,_,_,_,_,_,_,_],
        [_,_,h,H,H,H,H,h,_,_,_,_,_,_],
        [_,_,H,H,H,H,H,H,_,_,_,_,_,_],
        [_,_,S,W,E,S,W,E,q,_,_,_,_,_],
        [_,_,q,S,S,S,S,S,q,_,_,_,_,_],
        [_,_,_,q,S,S,q,_,_,_,_,_,_,_],
        [_,leanR?_:t,t,T,T,T,T,T,leanR?t:_,_,_,_,_,_],
        [_,leanR?_:t,T,T,T,T,T,T,leanR?t:_,D,_,_,_,_],
        [_,_,t,T,T,T,T,T,_,D,_,_,_,_],
        [_,_,q,T,T,T,q,_,_,d,_,_,_,_],
        [_,_,_,L,L,L,L,_,_,_,_,_,_,_],
        [_,_,_,L,l,l,L,_,_,_,_,_,_,_],
        [_,wobbleX?_:B,_,l,_,_,l,wobbleX?B:_,_,_,_,_,_,_],
        [_,wobbleX?_:B,B,B,_,_,B,B,wobbleX?B:_,_,_,_,_,_],
    ];
}

// ============================================================
//  BUILDING RENDERERS
// ============================================================

function drawBuilding_ICA(x, y, camX) {
    const sx = Math.floor(x - camX);
    const by = GAME_H - 90;

    // Main building with brick texture (180px wide)
    drawRect(sx, by, 180, 60, '#cc2222');
    drawRect(sx + 1, by + 1, 178, 58, '#dd3333');
    // Brick lines
    for (let row = 0; row < 12; row++) {
        const brickY = by + 4 + row * 5;
        drawRect(sx, brickY, 180, 1, '#bb2222');
        const offset = row % 2 === 0 ? 0 : 8;
        for (let col = offset; col < 180; col += 16) {
            drawRect(sx + col, by + 4 + row * 5, 1, 5, '#bb2222');
        }
    }

    // Roof with overhang and gutter
    drawRect(sx - 3, by - 2, 186, 3, '#771111');
    drawRect(sx - 2, by - 4, 184, 3, '#881111');
    drawRect(sx - 1, by - 5, 182, 2, '#991111');

    // Sign - illuminated box sign (160px wide, centered)
    drawRect(sx + 10, by + 3, 160, 16, '#ffffff');
    drawRect(sx + 11, by + 4, 158, 14, '#eeeeff');
    drawRect(sx + 12, by + 5, 156, 12, '#cc0000');
    // 'ICA STINSEN' = 11 chars * 12px = 132px, centered: (160-132)/2 + 10 = 24
    drawText('ICA STINSEN', sx + 24, by + 7, PAL.white, 2);
    // Sign glow
    if (game.frameCount % 120 < 110) {
        drawRect(sx + 10, by + 2, 160, 1, '#ff6666');
    }

    // Large display windows with products inside
    drawRect(sx + 6, by + 26, 28, 18, '#556677');
    drawRect(sx + 7, by + 27, 26, 16, '#88bbdd');
    drawRect(sx + 8, by + 28, 24, 14, '#aaddff');
    // Window reflection
    drawRect(sx + 9, by + 28, 2, 10, '#cceeFF');
    // Products in window (fruit display)
    drawRect(sx + 14, by + 36, 4, 4, '#ff4444'); // Apple
    drawRect(sx + 20, by + 37, 3, 3, PAL.yellow); // Banana
    drawRect(sx + 25, by + 36, 4, 4, PAL.orange); // Orange

    drawRect(sx + 40, by + 26, 28, 18, '#556677');
    drawRect(sx + 41, by + 27, 26, 16, '#88bbdd');
    drawRect(sx + 42, by + 28, 24, 14, '#aaddff');
    drawRect(sx + 43, by + 28, 2, 10, '#cceeFF');
    // "ERBJUDANDE" poster in window
    drawRect(sx + 48, by + 30, 14, 8, PAL.yellow);
    drawText('REA', sx + 49, by + 32, PAL.red, 1);

    // Third display window
    drawRect(sx + 74, by + 26, 28, 18, '#556677');
    drawRect(sx + 75, by + 27, 26, 16, '#88bbdd');
    drawRect(sx + 76, by + 28, 24, 14, '#aaddff');
    drawRect(sx + 77, by + 28, 2, 10, '#cceeFF');
    // Stacked cans
    drawRect(sx + 82, by + 35, 3, 5, '#cc4444');
    drawRect(sx + 86, by + 35, 3, 5, '#44cc44');
    drawRect(sx + 84, by + 31, 3, 5, '#4444cc');

    // Automatic sliding door
    drawRect(sx + 120, by + 22, 36, 38, '#445566');
    drawRect(sx + 122, by + 24, 32, 36, '#667788');
    const doorSlide = Math.sin(game.frameCount * 0.03) > 0.7 ? 7 : 0;
    drawRect(sx + 122, by + 24, 16 - doorSlide, 36, '#7799aa');
    drawRect(sx + 138 + doorSlide, by + 24, 16 - doorSlide, 36, '#7799aa');
    // Door mat
    drawRect(sx + 120, by + 58, 36, 2, '#444444');
    // Welcome text above door
    drawText('VÄLKOMNA', sx + 114, by + 20, PAL.white, 1);

    // Shopping cart row outside
    for (let ci = 0; ci < 4; ci++) {
        const cx = sx + 3 + ci * 6;
        drawRect(cx, by + 52, 5, 5, PAL.grey);
        drawRect(cx, by + 51, 5, 1, SH.chrome);
        drawPixel(cx + 1, by + 57, PAL.black);
        drawPixel(cx + 4, by + 57, PAL.black);
    }

    // Price sign outside
    drawRect(sx + 168, by + 44, 6, 14, PAL.white);
    drawText('3', sx + 169, by + 46, PAL.red, 1);
    drawText('9', sx + 169, by + 52, PAL.red, 1);
}

function drawBuilding_GOJVUT(x, y, camX) {
    const sx = Math.floor(x - camX);
    const by = GAME_H - 92;

    // Main building - sleek dark facade (150px wide, taller)
    drawRect(sx, by, 150, 62, '#2a3a55');
    drawRect(sx + 1, by + 1, 148, 60, '#3a4a66');
    // Subtle vertical paneling
    for (let p = 0; p < 13; p++) {
        drawRect(sx + p * 12, by, 1, 62, '#2a3a55');
    }

    // Stylish angled roof
    drawRect(sx - 2, by - 3, 154, 4, '#1a2a44');
    drawRect(sx - 1, by - 5, 152, 3, '#223355');

    // Neon-style sign (130px wide, taller to hold both texts)
    drawRect(sx + 10, by + 3, 130, 20, '#111122');
    drawRect(sx + 11, by + 4, 128, 18, '#1a1a2a');
    // 'GÖJVUT' = 6 chars * 6px = 36px, centered: (130-36)/2 + 10 = 57
    drawText('GÖJVUT', sx + 57, by + 6, PAL.orange, 1);
    // 'HERRKLÄDER' = 10 chars * 6px = 60px, centered: (130-60)/2 + 10 = 45
    drawText('HERRKLÄDER', sx + 45, by + 14, '#8899bb', 1);
    // Neon glow effect
    if (game.frameCount % 90 < 80) {
        drawRect(sx + 10, by + 2, 130, 1, '#ff880044');
        drawRect(sx + 10, by + 23, 130, 1, '#ff880044');
    }

    // Awning (below sign, above windows)
    for (let aw = 0; aw < 150; aw++) {
        const stripe = aw % 8 < 4 ? '#2a3a55' : '#445577';
        drawPixel(sx + aw, by + 24, stripe);
        drawPixel(sx + aw, by + 25, stripe);
    }

    // Display window 1 - with mannequin in suit
    drawRect(sx + 5, by + 27, 38, 26, '#556677');
    drawRect(sx + 6, by + 28, 36, 24, '#eeddcc');
    drawRect(sx + 7, by + 29, 34, 22, '#f5e8d8');
    // Mannequin with detailed suit
    drawRect(sx + 20, by + 31, 5, 4, PAL.peach);     // Head
    drawPixel(sx + 21, by + 32, PAL.black);           // Eye
    drawPixel(sx + 23, by + 32, PAL.black);           // Eye
    drawRect(sx + 18, by + 35, 9, 10, '#222244');     // Suit jacket
    drawRect(sx + 21, by + 35, 3, 10, '#333355');     // Shirt under
    drawRect(sx + 22, by + 36, 1, 8, PAL.red);       // Tie
    drawRect(sx + 16, by + 36, 2, 7, '#222244');      // Left sleeve
    drawRect(sx + 27, by + 36, 2, 7, '#222244');      // Right sleeve
    drawRect(sx + 19, by + 45, 3, 5, '#1a1a33');      // Left leg
    drawRect(sx + 23, by + 45, 3, 5, '#1a1a33');      // Right leg
    drawRect(sx + 19, by + 49, 3, 2, PAL.black);      // Shoes
    drawRect(sx + 23, by + 49, 3, 2, PAL.black);
    // Spotlight on mannequin
    drawPixel(sx + 22, by + 29, PAL.yellow);

    // Display window 2 - caps and accessories
    drawRect(sx + 50, by + 27, 34, 26, '#556677');
    drawRect(sx + 51, by + 28, 32, 24, '#eeddcc');
    drawRect(sx + 52, by + 29, 30, 22, '#f5e8d8');
    // Shelf with caps
    drawRect(sx + 53, by + 38, 28, 1, '#8B6914');
    drawRect(sx + 55, by + 33, 6, 4, '#cc2222');     // Red cap
    drawRect(sx + 56, by + 32, 4, 1, '#cc2222');
    drawRect(sx + 65, by + 33, 6, 4, '#2244cc');     // Blue cap
    drawRect(sx + 66, by + 32, 4, 1, '#2244cc');
    drawRect(sx + 75, by + 33, 6, 4, PAL.darkgreen);  // Green cap
    drawRect(sx + 76, by + 32, 4, 1, PAL.darkgreen);
    // Folded shirts on shelf
    drawRect(sx + 55, by + 41, 7, 4, PAL.white);
    drawRect(sx + 65, by + 41, 7, 4, '#44aa44');
    drawRect(sx + 75, by + 41, 7, 4, '#cc8844');
    // Price tag
    drawRect(sx + 55, by + 46, 8, 4, PAL.yellow);
    drawText('499', sx + 56, by + 47, PAL.black, 1);

    // Elegant door
    drawRect(sx + 96, by + 27, 30, 35, '#1a2a44');
    drawRect(sx + 98, by + 29, 26, 33, '#3a4a5a');
    drawRect(sx + 99, by + 30, 24, 32, '#4a5a6a');
    // Door handle (brass)
    drawRect(sx + 120, by + 44, 2, 6, PAL.yellow);
    // "ÖPPET" sign on door (clearly below awning)
    drawRect(sx + 103, by + 32, 16, 7, '#115511');
    drawRect(sx + 104, by + 33, 14, 5, PAL.green);
    drawText('ÖPPET', sx + 103, by + 34, PAL.white, 1);

    // Display window 3 - accessories
    drawRect(sx + 130, by + 27, 16, 26, '#556677');
    drawRect(sx + 131, by + 28, 14, 24, '#eeddcc');
    drawRect(sx + 132, by + 29, 12, 22, '#f5e8d8');
    // Belt on display
    drawRect(sx + 134, by + 35, 8, 2, '#553311');
    drawPixel(sx + 138, by + 35, PAL.yellow);
    // Scarf
    drawRect(sx + 134, by + 40, 3, 6, '#cc2266');
    drawRect(sx + 137, by + 42, 5, 3, '#cc2266');
}

function drawBuilding_SYSTEM(x, y, camX) {
    const sx = Math.floor(x - camX);
    const by = GAME_H - 95;

    // Main building - stern government look with stone texture
    drawRect(sx, by, 130, 65, '#2a5a2a');
    drawRect(sx + 1, by + 1, 128, 63, '#3a6a3a');
    // Stone block pattern
    for (let row = 0; row < 6; row++) {
        drawRect(sx, by + row * 10, 130, 1, '#2a5a2a');
        const off = row % 2 === 0 ? 0 : 12;
        for (let col = off; col < 130; col += 24) {
            drawRect(sx + col, by + row * 10, 1, 10, '#2a5a2a');
        }
    }

    // Solid official roof with cornice
    drawRect(sx - 3, by - 2, 136, 3, '#1a4a1a');
    drawRect(sx - 2, by - 5, 134, 4, '#225522');
    // Roof pediment
    drawRect(sx + 48, by - 10, 35, 6, '#225522');
    drawRect(sx + 50, by - 8, 31, 4, '#2a5a2a');

    // Official sign with green/yellow
    drawRect(sx + 5, by + 3, 120, 16, '#002200');
    drawRect(sx + 6, by + 4, 118, 14, '#003300');
    drawRect(sx + 7, by + 5, 116, 12, '#004400');
    drawText('SYSTEMBOLAGET', sx + 26, by + 8, '#ddcc44', 1);
    // Sign border detail
    drawRect(sx + 5, by + 3, 120, 1, '#005500');
    drawRect(sx + 5, by + 18, 120, 1, '#005500');

    // Windows - tall official style with proper frames
    for (let i = 0; i < 3; i++) {
        const wx = sx + 10 + i * 32;
        // Window frame
        drawRect(wx - 1, by + 22, 20, 16, '#1a4a1a');
        drawRect(wx, by + 23, 18, 14, '#88aa88');
        drawRect(wx + 1, by + 24, 16, 12, '#99bb99');
        // Glass reflection
        drawRect(wx + 2, by + 24, 2, 8, '#aaccaa');
        // Window cross (Swedish style)
        drawRect(wx + 8, by + 24, 2, 12, '#3a6a3a');
        drawRect(wx + 1, by + 29, 16, 2, '#3a6a3a');
        // Window sill
        drawRect(wx - 1, by + 37, 20, 2, '#557755');
        // Bottles visible through window
        if (i === 0) {
            drawRect(wx + 4, by + 32, 2, 4, '#882222');
            drawRect(wx + 12, by + 31, 2, 5, '#228822');
        }
    }

    // Heavy official door
    drawRect(sx + 42, by + 40, 26, 25, '#1a3a1a');
    drawRect(sx + 44, by + 42, 22, 23, '#2a4a2a');
    drawRect(sx + 45, by + 43, 9, 21, '#334433');
    drawRect(sx + 56, by + 43, 9, 21, '#334433');
    // Door handles
    drawRect(sx + 53, by + 52, 2, 6, '#ccaa44');
    drawRect(sx + 56, by + 52, 2, 6, '#ccaa44');
    // "SYSTEMBOLAGET" above door
    drawRect(sx + 43, by + 38, 24, 3, '#003300');

    // Age restriction sign (important!)
    drawRect(sx + 96, by + 42, 26, 12, '#cc0000');
    drawRect(sx + 97, by + 43, 24, 10, '#dd2222');
    drawText('ÖL', sx + 98, by + 45, PAL.white, 1);

    // Opening hours sign
    drawRect(sx + 4, by + 44, 36, 16, PAL.white);
    drawRect(sx + 5, by + 45, 34, 14, '#eeffee');
    drawText('10-18', sx + 8, by + 49, '#003300', 1);

    // Recycling station next to building
    drawRect(sx + 122, by + 50, 6, 14, '#447744');
    drawRect(sx + 123, by + 49, 4, 2, '#557755');
}

function drawBuilding_TEXACO(x, y, camX) {
    const sx = Math.floor(x - camX);
    const by = GAME_H - 85;

    // Small shop building behind pumps
    drawRect(sx + 70, by, 70, 55, '#ddccbb');
    drawRect(sx + 71, by + 1, 68, 53, '#eeddcc');
    // Brick pattern
    for (let row = 0; row < 10; row++) {
        drawRect(sx + 70, by + 4 + row * 5, 70, 1, '#ccbbaa');
        const off = row % 2 === 0 ? 0 : 8;
        for (let col = off; col < 70; col += 16) {
            drawRect(sx + 70 + col, by + 4 + row * 5, 1, 5, '#ccbbaa');
        }
    }

    // Shop roof
    drawRect(sx + 67, by - 3, 76, 4, '#aa2222');
    drawRect(sx + 68, by - 1, 74, 2, '#cc3333');

    // TEXACO sign on shop
    drawRect(sx + 80, by + 3, 50, 14, '#cc0000');
    drawRect(sx + 81, by + 4, 48, 12, '#dd1111');
    drawText('TEXACO', sx + 87, by + 7, PAL.white, 1);

    // Star logo above sign
    drawPixel(sx + 104, by - 8, PAL.red);
    drawPixel(sx + 103, by - 7, PAL.red);
    drawPixel(sx + 105, by - 7, PAL.red);
    drawPixel(sx + 101, by - 6, PAL.red);
    drawPixel(sx + 102, by - 6, PAL.red);
    drawPixel(sx + 103, by - 6, PAL.red);
    drawPixel(sx + 104, by - 6, PAL.red);
    drawPixel(sx + 105, by - 6, PAL.red);
    drawPixel(sx + 106, by - 6, PAL.red);
    drawPixel(sx + 107, by - 6, PAL.red);
    drawPixel(sx + 102, by - 5, PAL.red);
    drawPixel(sx + 103, by - 5, PAL.red);
    drawPixel(sx + 105, by - 5, PAL.red);
    drawPixel(sx + 106, by - 5, PAL.red);
    drawPixel(sx + 103, by - 4, PAL.red);
    drawPixel(sx + 105, by - 4, PAL.red);

    // Shop window
    drawRect(sx + 80, by + 20, 20, 16, '#556677');
    drawRect(sx + 81, by + 21, 18, 14, '#88bbdd');
    drawRect(sx + 82, by + 22, 16, 12, '#aaddff');
    // Shelf with items
    drawRect(sx + 83, by + 28, 14, 1, '#8B6914');
    drawRect(sx + 85, by + 25, 3, 3, '#cc4444'); // Candy
    drawRect(sx + 90, by + 25, 3, 3, '#44cc44'); // Drink
    drawRect(sx + 85, by + 30, 3, 4, '#884422'); // Coffee
    drawRect(sx + 90, by + 29, 4, 5, '#2244cc'); // Bottle

    // Shop door
    drawRect(sx + 106, by + 20, 20, 35, '#3a3a3a');
    drawRect(sx + 108, by + 22, 16, 33, '#4a4a4a');
    drawRect(sx + 122, by + 36, 2, 6, PAL.yellow); // Handle
    // ÖPPET sign
    drawRect(sx + 110, by + 24, 12, 6, '#115511');
    drawText('ÖPPET', sx + 109, by + 25, PAL.white, 1);

    // Canopy over pumps (wide metal roof)
    drawRect(sx - 5, by + 10, 70, 3, '#444444');
    drawRect(sx - 3, by + 13, 66, 2, '#555555');
    // Canopy support pillars
    drawRect(sx + 5, by + 15, 3, 40, '#666666');
    drawRect(sx + 52, by + 15, 3, 40, '#666666');
    // Canopy top stripe
    drawRect(sx - 5, by + 8, 70, 3, '#cc2222');

    // Gas pump 1
    drawRect(sx + 16, by + 30, 10, 22, '#dddddd');
    drawRect(sx + 17, by + 31, 8, 20, '#cccccc');
    // Display
    drawRect(sx + 18, by + 33, 6, 4, '#111111');
    drawRect(sx + 19, by + 34, 4, 2, '#44ff44'); // Green digits
    // Nozzle
    drawRect(sx + 24, by + 38, 4, 2, '#333333');
    drawRect(sx + 27, by + 36, 2, 6, '#222222');
    // Red stripe
    drawRect(sx + 17, by + 42, 8, 3, '#cc2222');
    // Price sign
    drawRect(sx + 15, by + 26, 12, 5, PAL.white);
    drawText('21', sx + 16, by + 27, PAL.red, 1);

    // Gas pump 2
    drawRect(sx + 36, by + 30, 10, 22, '#dddddd');
    drawRect(sx + 37, by + 31, 8, 20, '#cccccc');
    // Display
    drawRect(sx + 38, by + 33, 6, 4, '#111111');
    drawRect(sx + 39, by + 34, 4, 2, '#44ff44');
    // Nozzle
    drawRect(sx + 44, by + 38, 4, 2, '#333333');
    drawRect(sx + 47, by + 36, 2, 6, '#222222');
    // Red stripe
    drawRect(sx + 37, by + 42, 8, 3, '#cc2222');
    // Diesel sign
    drawRect(sx + 35, by + 26, 12, 5, '#222222');
    drawText('DI', sx + 37, by + 27, PAL.yellow, 1);

    // Ground - concrete pad
    drawRect(sx - 5, by + 53, 150, 2, '#aaaaaa');
    drawRect(sx - 5, by + 55, 150, 1, '#999999');
}

function drawBuilding_JARNIA(x, y, camX) {
    const sx = Math.floor(x - camX);
    const by = GAME_H - 88;

    // Main building - sturdy industrial look (130px wide)
    drawRect(sx, by, 130, 58, '#cc6600');
    drawRect(sx + 1, by + 1, 128, 56, '#dd7711');
    // Horizontal cladding lines
    for (let row = 0; row < 14; row++) {
        drawRect(sx, by + 2 + row * 4, 130, 1, '#bb5500');
    }

    // Roof
    drawRect(sx - 3, by - 3, 136, 4, '#993300');
    drawRect(sx - 2, by - 5, 134, 3, '#aa4400');

    // JÄRNIA sign (big, orange/white on dark)
    drawRect(sx + 10, by + 3, 110, 16, '#331100');
    drawRect(sx + 11, by + 4, 108, 14, '#442200');
    // "JÄRNIA" = 6 chars * 12px = 72px at size 2, centered: (110-72)/2 + 10 = 29
    drawText('JÄRNIA', sx + 29, by + 6, '#ffaa00', 2);

    // Tool display window 1 - hammers and saws
    drawRect(sx + 5, by + 22, 34, 24, '#556677');
    drawRect(sx + 6, by + 23, 32, 22, '#eeddcc');
    drawRect(sx + 7, by + 24, 30, 20, '#f5e8d8');
    // Hammer
    drawRect(sx + 12, by + 27, 2, 10, '#8B6914'); // Handle
    drawRect(sx + 10, by + 26, 6, 3, '#888888');  // Head
    // Saw
    drawRect(sx + 22, by + 28, 12, 2, '#aaaaaa'); // Blade
    drawRect(sx + 20, by + 27, 4, 4, '#8B6914');  // Handle
    // Zigzag teeth on saw
    for (let t = 0; t < 5; t++) {
        drawPixel(sx + 24 + t * 2, by + 30, '#999999');
    }
    // Price tag
    drawRect(sx + 12, by + 38, 10, 5, PAL.yellow);
    drawText('149', sx + 12, by + 39, PAL.black, 1);

    // Tool display window 2 - drill and screwdrivers
    drawRect(sx + 44, by + 22, 34, 24, '#556677');
    drawRect(sx + 45, by + 23, 32, 22, '#eeddcc');
    drawRect(sx + 46, by + 24, 30, 20, '#f5e8d8');
    // Drill
    drawRect(sx + 52, by + 28, 8, 5, '#44aa44'); // Body
    drawRect(sx + 60, by + 29, 5, 2, '#888888');  // Bit
    drawRect(sx + 52, by + 33, 3, 4, '#44aa44');  // Handle
    // Screwdrivers
    drawRect(sx + 68, by + 26, 2, 10, '#cc4444'); // Red handle
    drawRect(sx + 69, by + 36, 1, 4, '#aaaaaa');  // Shaft
    drawRect(sx + 72, by + 26, 2, 10, PAL.yellow); // Yellow handle
    drawRect(sx + 73, by + 36, 1, 4, '#aaaaaa');
    // Price tag
    drawRect(sx + 50, by + 38, 14, 5, PAL.yellow);
    drawText('599', sx + 51, by + 39, PAL.black, 1);

    // Door
    drawRect(sx + 86, by + 22, 24, 36, '#553311');
    drawRect(sx + 88, by + 24, 20, 34, '#664422');
    drawRect(sx + 89, by + 25, 18, 32, '#775533');
    // Door handle
    drawRect(sx + 104, by + 40, 2, 6, PAL.yellow);
    // ÖPPET sign
    drawRect(sx + 91, by + 27, 14, 6, '#115511');
    drawText('ÖPPET', sx + 90, by + 28, PAL.white, 1);

    // Outdoor display - paint cans
    drawRect(sx + 114, by + 38, 8, 8, '#cc2222');
    drawRect(sx + 114, by + 37, 8, 2, '#aa1111');
    drawRect(sx + 123, by + 38, 8, 8, '#2244cc');
    drawRect(sx + 123, by + 37, 8, 2, '#1133bb');
    drawRect(sx + 118, by + 30, 8, 8, '#44cc44');
    drawRect(sx + 118, by + 29, 8, 2, '#33bb33');

    // Wheelbarrow outside
    drawRect(sx + 2, by + 48, 12, 6, '#666666');
    drawRect(sx + 1, by + 47, 14, 2, '#777777');
    drawRect(sx + 14, by + 44, 2, 10, '#555555'); // Handle
    drawPixel(sx + 6, by + 55, PAL.black); // Wheel
    drawPixel(sx + 7, by + 55, PAL.black);
    drawPixel(sx + 6, by + 56, PAL.black);
    drawPixel(sx + 7, by + 56, PAL.black);
}

// ============================================================
//  PUKE PUDDLE / PROJECTILE
// ============================================================
class PukeProjectile {
    constructor(x, y, dir) {
        this.x = x;
        this.y = y;
        this.vx = dir * 1.5;
        this.vy = -1;
        this.life = 60;
        this.gravity = 0.08;
    }

    update() {
        this.x += this.vx;
        this.vy += this.gravity;
        this.y += this.vy;
        this.life--;
        if (this.y > GAME_H - 32) {
            this.y = GAME_H - 32;
            this.vy = 0;
            this.vx = 0;
        }
    }

    draw(camX) {
        const sx = Math.floor(this.x - camX);
        const sy = Math.floor(this.y);
        // Detailed puke blob
        drawRect(sx, sy + 1, 5, 2, SH.pukeDrk);
        drawRect(sx + 1, sy, 3, 3, SH.pukeGrn);
        drawPixel(sx + 2, sy, '#88ff66');
        // Droplets
        if (this.vy < 0) {
            drawPixel(sx + 1, sy + 3, SH.pukeDrk);
            drawPixel(sx + 3, sy + 3, SH.pukeGrn);
        }
    }

    getHitbox(camX) {
        return { x: this.x, y: this.y, w: 4, h: 3 };
    }
}

// ============================================================
//  GAME STATE
// ============================================================
const LEVEL_WIDTH = 4800;
const LEVEL2_WIDTH = 2400;
const LEVEL3_WIDTH = 5200;

const game = {
    state: 'title',    // title, playing, gameover, victory
    level: 1,          // 1 = outdoor Vännäs, 2 = inside Hotell Vännäs, 3 = Myranparken + streets
    score: 0,
    highScore: 0,
    camX: 0,
    frameCount: 0,
    shakeTimer: 0,
    shakeIntensity: 0,
    particles: [],
    pukeProjectiles: [],
    bullets: [],
    dogPoops: [],
    discProjectiles: [],
    puckProjectiles: [],
    flashTimer: 0,
    flashColor: '',
    bossActive: false,
    bossDefeated: false,
    bossIntroTimer: 0,
    bossWarningShown: false,
    gunMessageTimer: 0,
    level2BossIntroTimer: 0,
    level2BossActive: false,
    level2BossDefeated: false,
    enteringHotel: false,
    enterHotelTimer: 0,
    enteringLevel3: false,
    enterLevel3Timer: 0,
    level3BossIntroTimer: 0,
    level3BossActive: false,
    level3BossDefeated: false,
    bandMembersDefeated: 0,
    bandMembersTotal: 3,
    cutscenePhase: '',
    cutsceneTimer: 0,
};

const player = {
    x: 40,
    y: GAME_H - 50,
    w: 16,
    h: 16,
    vx: 0,
    vy: 0,
    speed: 1.5,
    hp: 100,
    maxHp: 100,
    lives: 3,
    facing: 1,       // 1 = right, -1 = left
    attacking: false,
    attackTimer: 0,
    attackCooldown: 0,
    invincible: 0,
    frame: 0,
    walkTimer: 0,
    grounded: true,
    combo: 0,
    comboTimer: 0,
    hasGun: false,
    ammo: 0,
    shootCooldown: 0,
    hasBat: false,
    batDurability: 0,
};

let enemies = [];
let pickups = [];
let buildings = [];

function initLevel() {
    game.level = 1;
    game.camX = 0;
    game.score = 0;
    game.particles = [];
    game.pukeProjectiles = [];
    game.frameCount = 0;
    game.enteringHotel = false;
    game.enterHotelTimer = 0;
    game.level2BossIntroTimer = 0;
    game.level2BossActive = false;
    game.level2BossDefeated = false;
    game.enteringLevel3 = false;
    game.enterLevel3Timer = 0;
    game.level3BossIntroTimer = 0;
    game.level3BossActive = false;
    game.level3BossDefeated = false;
    game.bandMembersDefeated = 0;
    game.cutscenePhase = '';
    game.cutsceneTimer = 0;
    game.dogPoops = [];
    game.discProjectiles = [];

    player.x = 40;
    player.y = GAME_H - 50;
    player.hp = player.maxHp;
    player.lives = 3;
    player.facing = 1;
    player.attacking = false;
    player.invincible = 0;
    player.combo = 0;

    enemies = [];
    pickups = [];
    game.bullets = [];
    player.hasGun = false;
    player.ammo = 0;
    player.shootCooldown = 0;
    player.hasBat = false;
    player.batDurability = 0;

    // Buildings placement
    buildings = [
        { type: 'ica',    x: 200 },
        { type: 'gojvut', x: 550 },
        { type: 'texaco', x: 920 },
        { type: 'system', x: 1300 },
        { type: 'jarnia', x: 1700 },
        { type: 'ica',    x: 2100 },
        { type: 'gojvut', x: 2500 },
        { type: 'texaco', x: 2900 },
        { type: 'system', x: 3300 },
        { type: 'jarnia', x: 3700 },
        { type: 'ica',    x: 4050 },
        { type: 'gojvut', x: 4350 },
        { type: 'hotell', x: LEVEL_WIDTH - 140 },
    ];

    game.bossActive = false;
    game.bossDefeated = false;
    game.bossIntroTimer = 0;
    game.bossWarningShown = false;

    // Enemies spawns
    const spawnPoints = [
        // EPA tractors (more for longer level)
        { type: 'epa', x: 600 },
        { type: 'epa', x: 1400 },
        { type: 'epa', x: 2200 },
        { type: 'epa', x: 3000 },
        { type: 'epa', x: 3800 },
        { type: 'epa', x: 4400 },
        // Drunk people (more spread out)
        { type: 'drunk', x: 350 },
        { type: 'drunk', x: 600 },
        { type: 'drunk', x: 850 },
        { type: 'drunk', x: 1100 },
        { type: 'drunk', x: 1400 },
        { type: 'drunk', x: 1650 },
        { type: 'drunk', x: 1900 },
        { type: 'drunk', x: 2200 },
        { type: 'drunk', x: 2500 },
        { type: 'drunk', x: 2750 },
        { type: 'drunk', x: 3000 },
        { type: 'drunk', x: 3300 },
        { type: 'drunk', x: 3600 },
        { type: 'drunk', x: 3900 },
        { type: 'drunk', x: 4200 },
        { type: 'drunk', x: 4500 },
    ];

    spawnPoints.forEach(sp => {
        if (sp.type === 'epa') {
            enemies.push({
                type: 'epa',
                x: sp.x,
                y: GAME_H - 52,
                w: 32,
                h: 22,
                hp: 40,
                maxHp: 40,
                speed: -0.4 - Math.random() * 0.4,
                frame: 0,
                active: true,
                flashTimer: 0,
                honkTimer: Math.random() * 120,
            });
        } else {
            enemies.push({
                type: 'drunk',
                x: sp.x,
                y: GAME_H - 44,
                w: 12,
                h: 16,
                hp: 20,
                maxHp: 20,
                speed: 0.3 + Math.random() * 0.4,
                dir: Math.random() > 0.5 ? 1 : -1,
                frame: 0,
                active: true,
                puking: false,
                pukeTimer: 60 + Math.random() * 120,
                wobbleTimer: 0,
                flashTimer: 0,
            });
        }
    });

    // BOSS: The Bouncer of Hotell Vännäs
    enemies.push({
        type: 'boss',
        x: LEVEL_WIDTH - 100,
        y: GAME_H - 62,
        w: 24,
        h: 28,
        hp: 150,
        maxHp: 150,
        speed: 0.6,
        frame: 0,
        active: true,
        flashTimer: 0,
        phase: 0,         // 0=idle, 1=charge, 2=ground pound, 3=summon
        phaseTimer: 90,
        chargeDir: -1,
        chargeSpeed: 0,
        groundPoundY: 0,
        summonCooldown: 0,
        stunTimer: 0,
        introPlayed: false,
    });

    // Health pickups (kebab!)
    for (let i = 0; i < 12; i++) {
        pickups.push({
            type: 'kebab',
            x: 300 + i * 380,
            y: GAME_H - 42,
            w: 8,
            h: 8,
            active: true,
        });
    }

    // Gun pickups (scattered along the level)
    const gunPositions = [80, 1200, 2500, 3600];
    gunPositions.forEach(gx => {
        pickups.push({
            type: 'gun',
            x: gx,
            y: GAME_H - 44,
            w: 10,
            h: 6,
            active: true,
        });
    });

    // Ammo pickups (less frequent)
    const ammoPositions = [700, 1350, 2000, 2750, 3400, 4100];
    ammoPositions.forEach(ax => {
        pickups.push({
            type: 'ammo',
            x: ax,
            y: GAME_H - 40,
            w: 6,
            h: 6,
            active: true,
        });
    });

    // Baseball bat pickups
    [500, 1800, 3200, 4300].forEach(bx => {
        pickups.push({ type: 'bat', x: bx, y: GAME_H - 44, w: 10, h: 10, active: true });
    });
}

// ============================================================
//  LEVEL 2: INSIDE HOTELL VÄNNÄS
// ============================================================
// Room layout (x ranges in level2):
// 0-400: Hotel lobby/corridor
// 400-900: Disco room
// 900-1400: Karaoke room
// 1400-1900: Dining room
// 1900-2400: FRASSES (boss area)

let rooms = [];

function initLevel2() {
    game.level = 2;
    game.camX = 0;
    game.particles = [];
    game.pukeProjectiles = [];
    game.bullets = [];
    game.bossActive = false;
    game.bossDefeated = false;
    game.bossIntroTimer = 0;
    game.bossWarningShown = false;
    game.gunMessageTimer = 0;
    game.level2BossIntroTimer = 0;
    game.level2BossActive = false;
    game.level2BossDefeated = false;
    game.enteringHotel = false;

    player.x = 40;
    player.y = GAME_H - 50;
    player.facing = 1;
    player.attacking = false;
    player.invincible = 60;
    player.combo = 0;
    // Keep hp/lives/gun/ammo from level 1

    enemies = [];
    pickups = [];

    rooms = [
        { type: 'lobby',   x: 0,    w: 400 },
        { type: 'disco',   x: 400,  w: 500 },
        { type: 'karaoke', x: 900,  w: 500 },
        { type: 'dining',  x: 1400, w: 500 },
        { type: 'frasses', x: 1900, w: 500 },
    ];

    // Indoor drunks
    const indoorDrunks = [
        // Lobby
        { x: 150 }, { x: 300 },
        // Disco
        { x: 500 }, { x: 600 }, { x: 700 }, { x: 800 },
        // Karaoke
        { x: 1000 }, { x: 1100 }, { x: 1200 }, { x: 1300 },
        // Dining
        { x: 1500 }, { x: 1600 }, { x: 1700 }, { x: 1800 },
    ];

    indoorDrunks.forEach(sp => {
        enemies.push({
            type: 'drunk',
            x: sp.x,
            y: GAME_H - 44,
            w: 12,
            h: 16,
            hp: 25,
            maxHp: 25,
            speed: 0.3 + Math.random() * 0.4,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0,
            active: true,
            puking: false,
            pukeTimer: 60 + Math.random() * 120,
            wobbleTimer: 0,
            flashTimer: 0,
        });
    });

    // BOSS: KOCKEN (The Chef at FRASSES)
    enemies.push({
        type: 'boss',
        x: LEVEL2_WIDTH - 100,
        y: GAME_H - 62,
        w: 24,
        h: 28,
        hp: 200,
        maxHp: 200,
        speed: 0.7,
        frame: 0,
        active: true,
        flashTimer: 0,
        phase: 0,
        phaseTimer: 90,
        chargeDir: -1,
        chargeSpeed: 0,
        groundPoundY: 0,
        summonCooldown: 0,
        stunTimer: 0,
        introPlayed: false,
    });

    // Kebab pickups inside
    const kebabPos = [200, 550, 850, 1150, 1550, 1850];
    kebabPos.forEach(kx => {
        pickups.push({
            type: 'kebab',
            x: kx,
            y: GAME_H - 42,
            w: 8, h: 8,
            active: true,
        });
    });

    // Gun pickup early in hotel
    pickups.push({ type: 'gun', x: 100, y: GAME_H - 44, w: 10, h: 6, active: true });
    pickups.push({ type: 'gun', x: 1050, y: GAME_H - 44, w: 10, h: 6, active: true });

    // Ammo pickups (reduced)
    const ammoPos2 = [480, 960, 1480, 1720, 1960];
    ammoPos2.forEach(ax => {
        pickups.push({ type: 'ammo', x: ax, y: GAME_H - 40, w: 6, h: 6, active: true });
    });

    // Baseball bat pickups
    [300, 1200, 1800].forEach(bx => {
        pickups.push({ type: 'bat', x: bx, y: GAME_H - 44, w: 10, h: 10, active: true });
    });
}

// ============================================================
//  LEVEL 2 INDOOR DRAWING FUNCTIONS
// ============================================================
function drawIndoorBackground() {
    // Hotel carpet floor
    drawRect(0, GAME_H - 30, GAME_W, 30, '#6a2233');
    // Carpet pattern
    for (let i = 0; i < GAME_W; i += 12) {
        drawRect(i, GAME_H - 30, 6, 30, '#7a2a3a');
    }
    // Carpet edge trim
    drawRect(0, GAME_H - 31, GAME_W, 2, '#aa8833');
    drawRect(0, GAME_H - 1, GAME_W, 1, '#aa8833');

    // Ceiling
    drawRect(0, 0, GAME_W, 40, '#3a2020');
    drawRect(0, 38, GAME_W, 3, '#4a2a2a');
    // Crown molding
    drawRect(0, 40, GAME_W, 2, '#aa8833');

    // Base wall (changes per room)
    drawRect(0, 42, GAME_W, GAME_H - 72, '#8B4513');
    // Wallpaper pattern
    for (let wy = 45; wy < GAME_H - 35; wy += 20) {
        for (let wx = 0; wx < GAME_W; wx += 30) {
            const worldX = wx + game.camX;
            // Diamond pattern
            drawPixel(wx + 15, wy, '#7a3a10');
            drawPixel(wx + 14, wy + 1, '#7a3a10');
            drawPixel(wx + 16, wy + 1, '#7a3a10');
        }
    }

    // Ceiling lights
    for (let cl = 50; cl < LEVEL2_WIDTH; cl += 100) {
        const cx = Math.floor(cl - game.camX);
        if (cx < -10 || cx > GAME_W + 10) continue;
        drawRect(cx - 1, 40, 3, 4, '#555555');
        // Light fixture
        drawRect(cx - 3, 44, 7, 3, '#aa9966');
        // Light glow
        const flicker = Math.sin(game.frameCount * 0.03 + cl) > -0.3;
        if (flicker) {
            drawRect(cx - 2, 47, 5, 2, PAL.yellow);
            bctx.fillStyle = 'rgba(255,236,39,0.06)';
            bctx.beginPath();
            bctx.arc(cx, 55, 20, 0, Math.PI * 2);
            bctx.fill();
        }
    }
}

function drawRoom_LOBBY(rx, camX) {
    const sx = Math.floor(rx - camX);
    // Welcome sign
    drawRect(sx + 140, 50, 120, 16, '#2a0a0a');
    drawRect(sx + 141, 51, 118, 14, '#3a1a1a');
    drawText('HOTELL VÄNNÄS', sx + 148, 54, PAL.yellow, 1);
    // Reception desk
    drawRect(sx + 50, GAME_H - 65, 80, 35, '#5a3020');
    drawRect(sx + 52, GAME_H - 63, 76, 5, '#6a4030');
    drawRect(sx + 52, GAME_H - 58, 76, 2, '#aa8833');
    // Bell on desk
    drawRect(sx + 85, GAME_H - 69, 5, 4, PAL.yellow);
    drawPixel(sx + 87, GAME_H - 70, '#ccaa33');
    // Potted plants
    drawRect(sx + 20, GAME_H - 55, 8, 20, '#5a3020');
    drawRect(sx + 17, GAME_H - 60, 14, 6, PAL.darkgreen);
    drawRect(sx + 19, GAME_H - 64, 10, 5, PAL.green);
    drawRect(sx + 350, GAME_H - 55, 8, 20, '#5a3020');
    drawRect(sx + 347, GAME_H - 60, 14, 6, PAL.darkgreen);
    drawRect(sx + 349, GAME_H - 64, 10, 5, PAL.green);
    // Framed painting on wall
    drawRect(sx + 260, 55, 40, 30, '#2a1a0a');
    drawRect(sx + 262, 57, 36, 26, '#3a6a3a');
    drawRect(sx + 270, 64, 8, 10, '#5a8a5a'); // Tree
    drawRect(sx + 268, 60, 12, 5, '#4a7a4a');
    drawPixel(sx + 280, 74, '#88aaff'); // Lake
    drawPixel(sx + 282, 74, '#88aaff');
    // Arrow sign to rooms
    drawRect(sx + 360, 70, 30, 10, PAL.white);
    drawText('DISCO', sx + 362, 72, PAL.red, 1);
    drawText('->', sx + 388, 72, PAL.red, 1);
}

function drawRoom_DISCO(rx, camX) {
    const sx = Math.floor(rx - camX);
    // Dark walls for disco
    drawRect(sx, 42, 500, GAME_H - 72, '#1a0a1a');

    // Dance floor - checkerboard pattern
    for (let dy = 0; dy < 30; dy += 6) {
        for (let dx = 0; dx < 500; dx += 6) {
            const checker = ((dx / 6 + dy / 6) % 2 === 0);
            const colorPulse = Math.sin(game.frameCount * 0.05 + dx * 0.02 + dy * 0.02);
            let floorColor;
            if (checker) {
                floorColor = colorPulse > 0.3 ? '#ff2266' : (colorPulse > -0.3 ? '#2244ff' : '#22ff44');
            } else {
                floorColor = '#111111';
            }
            drawRect(sx + dx, GAME_H - 30 + dy, 6, 6, floorColor);
        }
    }

    // Disco ball
    const ballX = sx + 250;
    const ballY = 48;
    drawRect(ballX - 1, 40, 2, 8, '#555555'); // String
    // Ball body
    for (let bx2 = -4; bx2 <= 4; bx2++) {
        for (let by2 = -4; by2 <= 4; by2++) {
            if (bx2 * bx2 + by2 * by2 <= 16) {
                const mirror = ((bx2 + by2 + Math.floor(game.frameCount * 0.1)) % 3 === 0);
                drawPixel(ballX + bx2, ballY + by2, mirror ? PAL.white : '#aaaacc');
            }
        }
    }
    // Disco light beams
    const beamColors = ['rgba(255,0,100,0.06)', 'rgba(0,100,255,0.06)', 'rgba(0,255,100,0.06)', 'rgba(255,255,0,0.06)'];
    for (let beam = 0; beam < 4; beam++) {
        const angle = (beam / 4) * Math.PI * 2 + game.frameCount * 0.02;
        const bx2 = Math.cos(angle) * 120;
        const by2 = Math.sin(angle) * 60;
        bctx.fillStyle = beamColors[beam];
        bctx.beginPath();
        bctx.moveTo(ballX, ballY);
        bctx.lineTo(ballX + bx2 - 15, ballY + Math.abs(by2) + 30);
        bctx.lineTo(ballX + bx2 + 15, ballY + Math.abs(by2) + 30);
        bctx.fill();
    }

    // DJ booth
    drawRect(sx + 420, GAME_H - 70, 60, 40, '#222222');
    drawRect(sx + 422, GAME_H - 68, 56, 5, '#333333');
    // Turntables
    drawRect(sx + 425, GAME_H - 66, 12, 3, '#444444');
    drawRect(sx + 445, GAME_H - 66, 12, 3, '#444444');
    // Spinning record
    const recordSpin = game.frameCount % 20 < 10;
    drawRect(sx + 427 + (recordSpin ? 1 : 0), GAME_H - 65, 8, 1, '#111111');
    drawRect(sx + 447 + (recordSpin ? 1 : 0), GAME_H - 65, 8, 1, '#111111');
    // Speakers
    drawRect(sx + 10, GAME_H - 80, 20, 48, '#222222');
    drawRect(sx + 12, GAME_H - 76, 16, 10, '#111111');
    drawRect(sx + 14, GAME_H - 66, 12, 12, '#111111');
    // Speaker pulse
    const pulse = Math.sin(game.frameCount * 0.15) > 0;
    if (pulse) {
        drawRect(sx + 15, GAME_H - 74, 10, 6, '#222233');
    }
    drawRect(sx + 470, GAME_H - 80, 20, 48, '#222222');
    drawRect(sx + 472, GAME_H - 76, 16, 10, '#111111');
    drawRect(sx + 474, GAME_H - 66, 12, 12, '#111111');

    // DISCO sign with lights
    drawRect(sx + 190, 48, 60, 14, '#000000');
    drawText('DISCO', sx + 197, 51, PAL.white, 1);
    // Blinking border lights
    for (let li = 0; li < 15; li++) {
        const on = (game.frameCount + li * 4) % 12 < 8;
        if (on) {
            const lc = li % 3 === 0 ? PAL.red : (li % 3 === 1 ? PAL.yellow : PAL.green);
            drawPixel(sx + 190 + li * 4, 47, lc);
            drawPixel(sx + 190 + li * 4, 62, lc);
        }
    }
}

function drawRoom_KARAOKE(rx, camX) {
    const sx = Math.floor(rx - camX);
    // Warmer walls
    drawRect(sx, 42, 500, GAME_H - 72, '#3a1a2a');

    // Stage platform
    drawRect(sx + 150, GAME_H - 60, 200, 30, '#5a3020');
    drawRect(sx + 148, GAME_H - 62, 204, 3, '#aa8833');
    // Stage lights
    for (let sl = 0; sl < 5; sl++) {
        const slx = sx + 170 + sl * 40;
        drawRect(slx, 42, 3, 5, '#333333');
        const spotOn = (game.frameCount + sl * 20) % 60 < 45;
        if (spotOn) {
            const spotCol = sl % 2 === 0 ? 'rgba(255,100,150,0.08)' : 'rgba(100,150,255,0.08)';
            bctx.fillStyle = spotCol;
            bctx.beginPath();
            bctx.moveTo(slx + 1, 47);
            bctx.lineTo(slx - 15, GAME_H - 60);
            bctx.lineTo(slx + 17, GAME_H - 60);
            bctx.fill();
            drawRect(slx - 1, 47, 5, 2, sl % 2 === 0 ? '#ff6688' : '#6688ff');
        }
    }

    // Microphone stand center stage
    drawRect(sx + 248, GAME_H - 95, 2, 35, '#555555');
    drawRect(sx + 244, GAME_H - 95, 10, 2, '#444444');
    // Microphone
    drawRect(sx + 247, GAME_H - 100, 4, 6, '#333333');
    drawRect(sx + 248, GAME_H - 101, 2, 2, '#444444');

    // KARAOKE sign
    drawRect(sx + 180, 48, 84, 14, '#2a0a1a');
    drawRect(sx + 181, 49, 82, 12, '#3a1a2a');
    drawText('KARAOKE', sx + 187, 52, PAL.pink, 1);

    // TV screen with lyrics
    drawRect(sx + 40, 55, 60, 40, '#111111');
    drawRect(sx + 42, 57, 56, 36, '#0000aa');
    const lyricScroll = Math.floor(game.frameCount / 30) % 3;
    const lyrics = ['DANCING', 'QUEEN!', 'ABBA!!'];
    drawText(lyrics[lyricScroll], sx + 50, 72, PAL.yellow, 1);

    // Couch
    drawRect(sx + 380, GAME_H - 55, 60, 25, '#882222');
    drawRect(sx + 382, GAME_H - 60, 15, 8, '#993333');
    drawRect(sx + 423, GAME_H - 60, 15, 8, '#993333');
    drawRect(sx + 382, GAME_H - 53, 56, 18, '#aa3333');

    // Table with drinks
    drawRect(sx + 350, GAME_H - 50, 20, 20, '#5a3020');
    drawRect(sx + 353, GAME_H - 55, 4, 4, '#44aaff'); // Glass
    drawRect(sx + 360, GAME_H - 55, 4, 4, '#ffaa44'); // Beer
}

function drawRoom_DINING(rx, camX) {
    const sx = Math.floor(rx - camX);
    // Elegant dining walls
    drawRect(sx, 42, 500, GAME_H - 72, '#4a2a1a');

    // Tables (round with tablecloth)
    for (let t = 0; t < 4; t++) {
        const tx = sx + 60 + t * 110;
        // Tablecloth
        drawRect(tx, GAME_H - 60, 40, 3, PAL.white);
        drawRect(tx - 2, GAME_H - 58, 44, 2, '#eeeedd');
        // Table leg
        drawRect(tx + 18, GAME_H - 57, 4, 27, '#5a3020');
        // Plates
        drawRect(tx + 5, GAME_H - 64, 8, 4, PAL.white);
        drawRect(tx + 27, GAME_H - 64, 8, 4, PAL.white);
        // Candle
        drawRect(tx + 18, GAME_H - 68, 2, 5, PAL.white);
        const candleFlicker = Math.sin(game.frameCount * 0.1 + t) > -0.3;
        if (candleFlicker) {
            drawPixel(tx + 18, GAME_H - 70, PAL.yellow);
            drawPixel(tx + 19, GAME_H - 69, PAL.orange);
        }
        // Wine glass
        drawRect(tx + 12, GAME_H - 66, 2, 3, '#aa2244');
        drawRect(tx + 11, GAME_H - 67, 4, 1, '#cccccc');
    }

    // Chandelier
    drawRect(sx + 230, 40, 2, 6, '#aa8833');
    drawRect(sx + 220, 46, 22, 3, '#aa8833');
    for (let ch = 0; ch < 5; ch++) {
        const chx = sx + 220 + ch * 5;
        drawRect(chx, 49, 1, 3, '#aa8833');
        const lit = Math.sin(game.frameCount * 0.04 + ch) > -0.2;
        if (lit) {
            drawPixel(chx, 52, PAL.yellow);
            drawPixel(chx, 53, PAL.orange);
        }
    }

    // MATSAL sign
    drawRect(sx + 200, 55, 60, 12, '#2a1a0a');
    drawText('MATSAL', sx + 208, 58, PAL.cream, 1);

    // Wine rack on wall
    drawRect(sx + 430, 55, 40, 50, '#3a1a0a');
    for (let wr = 0; wr < 5; wr++) {
        for (let wc = 0; wc < 4; wc++) {
            const bx = sx + 434 + wc * 9;
            const by = 58 + wr * 9;
            drawRect(bx, by, 6, 3, wr % 2 === 0 ? '#882222' : '#228822');
        }
    }
}

function drawRoom_FRASSES(rx, camX) {
    const sx = Math.floor(rx - camX);
    // Fast food restaurant interior
    drawRect(sx, 42, 500, GAME_H - 72, '#cc6600');
    // Tile pattern
    for (let ty = 42; ty < GAME_H - 30; ty += 8) {
        drawRect(sx, ty, 500, 1, '#bb5500');
    }

    // FRASSES sign (big!)
    drawRect(sx + 140, 46, 100, 20, '#cc0000');
    drawRect(sx + 141, 47, 98, 18, '#dd2222');
    drawText('FRASSES', sx + 152, 50, PAL.yellow, 2);

    // Counter
    drawRect(sx + 300, GAME_H - 70, 150, 40, '#884422');
    drawRect(sx + 302, GAME_H - 68, 146, 5, '#995533');
    drawRect(sx + 302, GAME_H - 63, 146, 2, '#aa8833');
    // Cash register
    drawRect(sx + 420, GAME_H - 80, 16, 12, '#333333');
    drawRect(sx + 422, GAME_H - 78, 12, 5, '#44ff44');
    // Menu board
    drawRect(sx + 310, 55, 100, 45, '#111111');
    drawRect(sx + 312, 57, 96, 41, '#1a1a1a');
    drawText('MENY', sx + 340, 60, PAL.yellow, 1);
    drawText('HAMBURGARE  59', sx + 316, 72, PAL.white, 1);
    drawText('POMMES      29', sx + 316, 82, PAL.white, 1);
    drawText('DRICKA      25', sx + 316, 92, PAL.white, 1);

    // French fry display (the soggy ones!)
    drawRect(sx + 340, GAME_H - 78, 20, 8, '#cc9922');
    // Sad soggy fries
    for (let f = 0; f < 5; f++) {
        const fy = GAME_H - 78 + Math.sin(f * 1.2) * 2;
        drawRect(sx + 342 + f * 3, fy, 2, 7, '#ddaa33');
        // Droop
        drawPixel(sx + 342 + f * 3, fy + 7, '#aa8822');
    }

    // Stools
    for (let st = 0; st < 4; st++) {
        const stx = sx + 50 + st * 65;
        drawRect(stx, GAME_H - 50, 14, 3, '#cc2222');
        drawRect(stx + 6, GAME_H - 47, 2, 17, '#555555');
    }

    // Tables with food
    for (let t = 0; t < 2; t++) {
        const tx = sx + 30 + t * 120;
        drawRect(tx, GAME_H - 56, 50, 3, '#dddddd');
        drawRect(tx + 22, GAME_H - 53, 4, 23, '#555555');
        // Burger on plate
        drawRect(tx + 8, GAME_H - 62, 10, 3, '#aa6622'); // Bottom bun
        drawRect(tx + 7, GAME_H - 65, 12, 3, '#884422'); // Patty
        drawRect(tx + 6, GAME_H - 63, 3, 1, '#44cc44');  // Lettuce
        drawRect(tx + 8, GAME_H - 68, 10, 3, '#bb7733'); // Top bun
        drawPixel(tx + 12, GAME_H - 69, '#ffee88'); // Sesame
        drawPixel(tx + 14, GAME_H - 69, '#ffee88');
        // Soggy fries (droopy)
        drawRect(tx + 28, GAME_H - 62, 12, 3, '#cc9922');
        for (let f2 = 0; f2 < 4; f2++) {
            drawRect(tx + 29 + f2 * 3, GAME_H - 65 + f2 % 2, 2, 4 + f2 % 2, '#ddaa33');
        }
    }

    // Grease stains on floor
    for (let g = 0; g < 8; g++) {
        const gx = sx + 20 + g * 60;
        bctx.fillStyle = 'rgba(80,50,10,0.3)';
        bctx.fillRect(gx, GAME_H - 28, 5, 2);
    }
}

function drawIndoorRooms() {
    rooms.forEach(r => {
        const rEnd = r.x + r.w;
        if (rEnd < game.camX - 10 || r.x > game.camX + GAME_W + 10) return;
        switch(r.type) {
            case 'lobby':   drawRoom_LOBBY(r.x, game.camX); break;
            case 'disco':   drawRoom_DISCO(r.x, game.camX); break;
            case 'karaoke': drawRoom_KARAOKE(r.x, game.camX); break;
            case 'dining':  drawRoom_DINING(r.x, game.camX); break;
            case 'frasses': drawRoom_FRASSES(r.x, game.camX); break;
        }
    });

    // Room dividers / doorways between rooms
    rooms.forEach((r, i) => {
        if (i === 0) return;
        const dx = Math.floor(r.x - game.camX);
        if (dx < -10 || dx > GAME_W + 10) return;
        // Door frame
        drawRect(dx - 3, 42, 6, GAME_H - 72, '#3a1a0a');
        drawRect(dx - 2, 42, 4, 3, '#aa8833');
        drawRect(dx - 2, GAME_H - 33, 4, 3, '#aa8833');
        // Arch top
        drawRect(dx - 8, 40, 16, 4, '#5a3020');
        drawRect(dx - 6, 38, 12, 3, '#aa8833');
    });
}

function getKockenSprite(frame, angry) {
    const _ = null;
    const Wh = PAL.white;    // Chef coat
    const Wd = '#dddddd';    // Coat shadow
    const Sk = PAL.peach;    // Skin
    const sh = '#cc9977';    // Skin shadow
    const Ey = PAL.black;    // Eyes
    const Ht = PAL.white;    // Chef hat
    const Hd = '#cccccc';    // Hat shadow
    const Pn = '#222222';    // Pants
    const Pd = '#111111';    // Pants dark
    const Bt = '#111111';    // Shoes
    const Rd = PAL.red;      // Angry mouth / bandana
    const Ms = '#8B6914';    // Mustache

    return [
        [_,_,_,_,Ht,Ht,Ht,Ht,Ht,_,_,_,_],
        [_,_,_,Ht,Ht,Ht,Ht,Ht,Ht,Ht,_,_,_],
        [_,_,_,Ht,Ht,Ht,Ht,Ht,Ht,Ht,_,_,_],
        [_,_,_,Hd,Hd,Hd,Hd,Hd,Hd,Hd,_,_,_],
        [_,_,sh,Sk,Sk,Sk,Sk,Sk,Sk,Sk,sh,_,_],
        [_,_,sh,Ey,Sk,Sk,Sk,Sk,Sk,Ey,sh,_,_],
        [_,_,_,Sk,Ms,Ms,Sk,Ms,Ms,Sk,_,_,_],
        [_,_,_,sh,Sk,angry?Rd:Sk,angry?Rd:Sk,angry?Rd:Sk,Sk,sh,_,_,_],
        [_,_,Rd,Rd,Wh,Wh,Wh,Wh,Wh,Rd,Rd,_,_],
        [_,sh,Wh,Wh,Wh,Wh,Wh,Wh,Wh,Wh,Wh,sh,_],
        [_,sh,Wh,Wd,Wh,Wh,Wh,Wh,Wd,Wh,Wh,sh,_],
        [_,_,Wh,Wh,Wh,Wh,Wh,Wh,Wh,Wh,Wh,_,_],
        [_,_,_,Wd,Wd,Wd,Wd,Wd,Wd,Wd,_,_,_],
        [_,_,_,Pn,Pn,Pd,Pd,Pd,Pn,Pn,_,_,_],
        [_,_,Pd,Pn,Pd,_,_,_,Pd,Pn,Pd,_,_],
        [_,_,Bt,Bt,Bt,_,_,_,Bt,Bt,Bt,_,_],
        [_,Bt,Bt,Bt,Bt,Bt,_,Bt,Bt,Bt,Bt,Bt,_],
    ];
}

// ============================================================
//  LEVEL 3: MYRANPARKEN, STREETS, DISC GOLF, ISHALL, POND
// ============================================================
// Area layout (x ranges in level3):
// 0-900:     Myranparken (park with playground, swings, dogs)
// 900-2200:  Långgatan & Stjärngatan (houses, pools, garages)
// 2200-3200: Disc golf field (green field, disc throwers)
// 3200-3800: Vännäs Ishall (ice hall building)
// 3800-5200: Pond + Stage (water, stage, Riff Raff Ruff boss)

let level3Areas = [];

function initLevel3() {
    game.level = 3;
    game.camX = 0;
    game.particles = [];
    game.pukeProjectiles = [];
    game.bullets = [];
    game.dogPoops = [];
    game.discProjectiles = [];
    game.puckProjectiles = [];
    game.bossActive = false;
    game.bossDefeated = false;
    game.bossIntroTimer = 0;
    game.bossWarningShown = false;
    game.gunMessageTimer = 0;
    game.level3BossIntroTimer = 0;
    game.level3BossActive = false;
    game.level3BossDefeated = false;
    game.bandMembersDefeated = 0;
    game.enteringLevel3 = false;

    player.x = 40;
    player.y = GAME_H - 50;
    player.facing = 1;
    player.attacking = false;
    player.invincible = 60;
    player.combo = 0;
    // Keep hp/lives/gun/ammo from level 2

    enemies = [];
    pickups = [];

    level3Areas = [
        { type: 'park',     x: 0,    w: 900 },
        { type: 'streets',  x: 900,  w: 1300 },
        { type: 'discgolf', x: 2200, w: 1000 },
        { type: 'ishall',   x: 3200, w: 600 },
        { type: 'pond',     x: 3800, w: 1400 },
    ];

    // === PARK ENEMIES: Dogs ===
    const dogSpawns = [
        { x: 200 }, { x: 400 }, { x: 550 }, { x: 700 }, { x: 850 },
    ];
    dogSpawns.forEach(sp => {
        enemies.push({
            type: 'dog',
            x: sp.x,
            y: GAME_H - 42,
            w: 14,
            h: 10,
            hp: 15,
            maxHp: 15,
            speed: 0.8 + Math.random() * 0.6,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0,
            active: true,
            flashTimer: 0,
            poopTimer: 80 + Math.random() * 100,
            pooping: false,
            poopDuration: 0,
        });
    });

    // === PARK ENEMIES: Drunks wandering the park ===
    const parkDrunks = [{ x: 150 }, { x: 350 }, { x: 600 }];
    parkDrunks.forEach(sp => {
        enemies.push({
            type: 'drunk',
            x: sp.x, y: GAME_H - 44, w: 12, h: 16,
            hp: 20, maxHp: 20,
            speed: 0.3 + Math.random() * 0.3,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0, active: true, puking: false,
            pukeTimer: 60 + Math.random() * 120,
            wobbleTimer: 0, flashTimer: 0,
        });
    });

    // === STREET ENEMIES: More drunks in the residential area ===
    const streetDrunks = [
        { x: 1000 }, { x: 1200 }, { x: 1600 },
        { x: 1800 }, { x: 2000 },
    ];
    streetDrunks.forEach(sp => {
        enemies.push({
            type: 'drunk',
            x: sp.x, y: GAME_H - 44, w: 12, h: 16,
            hp: 25, maxHp: 25,
            speed: 0.3 + Math.random() * 0.4,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0, active: true, puking: false,
            pukeTimer: 60 + Math.random() * 120,
            wobbleTimer: 0, flashTimer: 0,
        });
    });

    // === STREET ENEMIES: Skateboarders ===
    [{ x: 1100 }, { x: 1500 }, { x: 1900 }].forEach(sp => {
        enemies.push({
            type: 'skater',
            x: sp.x, y: GAME_H - 40,
            w: 18, h: 20,
            hp: 25, maxHp: 25,
            speed: 2.0 + Math.random() * 0.8,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0, active: true, flashTimer: 0,
            homeX: sp.x,
            trickTimer: 0,
        });
    });

    // === STREET ENEMIES: BMX riders ===
    [{ x: 1300 }, { x: 1700 }, { x: 2100 }].forEach(sp => {
        enemies.push({
            type: 'bmx',
            x: sp.x, y: GAME_H - 42,
            w: 22, h: 22,
            hp: 35, maxHp: 35,
            speed: 2.5 + Math.random() * 0.5,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0, active: true, flashTimer: 0,
            homeX: sp.x,
            chargeTimer: 60 + Math.random() * 60,
            charging: false,
        });
    });

    // === DISC GOLF ENEMIES: Disc throwers ===
    const discThrowers = [
        { x: 2400 }, { x: 2600 }, { x: 2800 }, { x: 3000 },
    ];
    discThrowers.forEach(sp => {
        enemies.push({
            type: 'discgolfer',
            x: sp.x,
            y: GAME_H - 44,
            w: 20,
            h: 14,
            hp: 30,
            maxHp: 30,
            speed: 0.2,
            dir: -1,
            frame: 0,
            active: true,
            flashTimer: 0,
            throwTimer: 50 + Math.random() * 60,
            throwing: false,
            throwAnim: 0,
        });
    });

    // === MORE DOGS near disc golf ===
    [{ x: 2350 }, { x: 2700 }].forEach(sp => {
        enemies.push({
            type: 'dog', x: sp.x, y: GAME_H - 42, w: 14, h: 10,
            hp: 15, maxHp: 15, speed: 0.8 + Math.random() * 0.5,
            dir: Math.random() > 0.5 ? 1 : -1, frame: 0, active: true,
            flashTimer: 0, poopTimer: 80 + Math.random() * 100,
            pooping: false, poopDuration: 0,
        });
    });

    // === ISHALL ENEMIES: Hockey players with puck shots ===
    [{ x: 3300 }, { x: 3450 }, { x: 3600 }].forEach(sp => {
        enemies.push({
            type: 'hockey',
            x: sp.x, y: GAME_H - 48,
            w: 18, h: 18,
            hp: 40, maxHp: 40,
            speed: 0.6 + Math.random() * 0.4,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0, active: true, flashTimer: 0,
            shootTimer: 70 + Math.random() * 50,
            shooting: false,
            shootAnim: 0,
        });
    });

    // === POND ENEMIES: Angry swans ===
    [{ x: 3900 }, { x: 4100 }, { x: 4300 }, { x: 4500 }].forEach(sp => {
        enemies.push({
            type: 'swan',
            x: sp.x, y: GAME_H - 70 - Math.random() * 30,
            w: 20, h: 14,
            hp: 20, maxHp: 20,
            speed: 1.2 + Math.random() * 0.6,
            dir: Math.random() > 0.5 ? 1 : -1,
            frame: 0, active: true, flashTimer: 0,
            swoopTimer: 50 + Math.random() * 40,
            swooping: false,
            swoopTarget: 0,
            baseY: GAME_H - 70 - Math.random() * 30,
        });
    });

    // === BOSS: Riff Raff Ruff band members (3 bosses!) ===
    // Guitar, Bass, Drums - each a boss-type enemy
    const bandMembers = [
        { role: 'guitar', x: LEVEL3_WIDTH - 220, hp: 120 },
        { role: 'bass',   x: LEVEL3_WIDTH - 140, hp: 100 },
        { role: 'drums',  x: LEVEL3_WIDTH - 60,  hp: 130 },
    ];
    bandMembers.forEach(bm => {
        enemies.push({
            type: 'boss',
            role: bm.role,
            x: bm.x,
            y: GAME_H - 62,
            w: 24,
            h: 28,
            hp: bm.hp,
            maxHp: bm.hp,
            speed: 0.5 + Math.random() * 0.3,
            frame: 0,
            active: true,
            flashTimer: 0,
            phase: 0,
            phaseTimer: 90,
            chargeDir: -1,
            chargeSpeed: 0,
            groundPoundY: 0,
            summonCooldown: 0,
            stunTimer: 0,
            introPlayed: false,
        });
    });

    // Health pickups
    const kebabPos3 = [120, 450, 800, 1100, 1500, 1900, 2300, 2700, 3100, 3500, 4000, 4600];
    kebabPos3.forEach(kx => {
        pickups.push({ type: 'kebab', x: kx, y: GAME_H - 42, w: 8, h: 8, active: true });
    });

    // Gun pickups
    [300, 2500, 3600].forEach(gx => {
        pickups.push({ type: 'gun', x: gx, y: GAME_H - 44, w: 10, h: 6, active: true });
    });

    // Ammo pickups (reduced)
    [500, 1100, 1700, 2400, 3200, 4000, 4800].forEach(ax => {
        pickups.push({ type: 'ammo', x: ax, y: GAME_H - 40, w: 6, h: 6, active: true });
    });

    // Baseball bat pickups
    [950, 1600, 2200, 3400, 4200].forEach(bx => {
        pickups.push({ type: 'bat', x: bx, y: GAME_H - 44, w: 10, h: 10, active: true });
    });
}

// ============================================================
//  LEVEL 3 OUTDOOR DRAWING FUNCTIONS
// ============================================================

function drawLevel3Sky() {
    // Morning/daytime sky - brighter than level 1
    const colors = ['#1a3a6e', '#2a4a8e', '#3a5aae', '#4a7acc', '#5a9ade', '#6abaee', '#8acaee', '#aadaee'];
    const bandH = Math.ceil(80 / colors.length);
    for (let i = 0; i < colors.length; i++) {
        drawRect(0, i * bandH, GAME_W, bandH + 1, colors[i]);
    }
    // Clouds
    const cloudShift = game.camX * 0.03;
    for (let c = 0; c < 8; c++) {
        const cx = ((c * 140 + 30) - cloudShift) % (GAME_W + 80) - 40;
        const cy = 15 + (c * 17) % 30;
        const cw = 20 + (c * 7) % 15;
        bctx.fillStyle = 'rgba(255,255,255,0.3)';
        bctx.fillRect(cx, cy, cw, 5);
        bctx.fillRect(cx + 3, cy - 2, cw - 6, 3);
        bctx.fillRect(cx + 5, cy + 4, cw - 8, 3);
    }
    // Sun
    const sunX = 340 - game.camX * 0.01;
    bctx.fillStyle = 'rgba(255,240,100,0.08)';
    bctx.beginPath(); bctx.arc(sunX, 25, 25, 0, Math.PI * 2); bctx.fill();
    bctx.fillStyle = '#ffee66';
    bctx.beginPath(); bctx.arc(sunX, 25, 10, 0, Math.PI * 2); bctx.fill();
    bctx.fillStyle = '#ffff88';
    bctx.beginPath(); bctx.arc(sunX, 25, 7, 0, Math.PI * 2); bctx.fill();
}

function drawLevel3Ground() {
    // Grass ground for park/field areas, sidewalk for streets
    const camX = game.camX;
    for (let px = 0; px < GAME_W; px++) {
        const worldX = px + camX;
        let groundColor, groundColorDark;
        if (worldX < 900 || (worldX >= 2200 && worldX < 3200)) {
            // Park / disc golf = grass
            groundColor = '#3a8a3a';
            groundColorDark = '#2a7a2a';
        } else if (worldX >= 3800) {
            // Pond area = grass near water
            groundColor = '#3a8a3a';
            groundColorDark = '#2a7a2a';
        } else if (worldX >= 3200 && worldX < 3800) {
            // Ishall area = pavement
            groundColor = '#6a6a6a';
            groundColorDark = '#5a5a5a';
        } else {
            // Streets = sidewalk/pavement
            groundColor = PAL.pavement;
            groundColorDark = '#7a7a6a';
        }
        drawPixel(px, GAME_H - 31, groundColorDark);
        for (let gy = GAME_H - 30; gy < GAME_H; gy++) {
            drawPixel(px, gy, (px + gy) % 3 === 0 ? groundColorDark : groundColor);
        }
    }
    // Grass tufts in park areas
    for (let gt = 0; gt < LEVEL3_WIDTH; gt += 15) {
        const gtx = Math.floor(gt - camX);
        if (gtx < -5 || gtx > GAME_W + 5) continue;
        const worldGt = gt;
        if (worldGt < 900 || (worldGt >= 2200 && worldGt < 3200) || worldGt >= 3800) {
            const gh = 2 + Math.sin(gt * 0.7) * 1;
            drawRect(gtx, GAME_H - 31 - gh, 1, gh, '#4a9a4a');
            if (gt % 30 === 0) drawRect(gtx + 1, GAME_H - 32 - gh, 1, gh + 1, '#5aaa5a');
        }
    }
}

// ---- MYRANPARKEN ----
function drawArea_PARK(areaX, camX) {
    const sx = Math.floor(areaX - camX);

    // Park sign
    drawRect(sx + 20, GAME_H - 80, 100, 14, '#5a3020');
    drawRect(sx + 22, GAME_H - 78, 96, 10, '#6a4030');
    drawText('MYRANPARKEN', sx + 26, GAME_H - 76, PAL.yellow, 1);

    // === PLAYGROUND AREA (x 80-350) ===
    // Sandbox
    drawRect(sx + 80, GAME_H - 36, 60, 6, '#ddcc88');
    drawRect(sx + 82, GAME_H - 35, 56, 4, '#eeDD99');
    // Sand toys
    drawRect(sx + 90, GAME_H - 39, 4, 3, PAL.red);
    drawRect(sx + 100, GAME_H - 38, 5, 2, PAL.blue);

    // Slide
    drawRect(sx + 170, GAME_H - 75, 3, 45, '#444444'); // Pole
    drawRect(sx + 162, GAME_H - 73, 12, 3, '#888888'); // Platform
    // Slide surface
    for (let si = 0; si < 20; si++) {
        drawPixel(sx + 173 + si, GAME_H - 73 + Math.floor(si * 1.8), '#ccaa22');
        drawPixel(sx + 174 + si, GAME_H - 73 + Math.floor(si * 1.8), '#ddbb33');
    }
    // Ladder
    for (let li = 0; li < 4; li++) {
        drawRect(sx + 163, GAME_H - 70 + li * 10, 8, 1, '#666666');
    }

    // Swings (x 260-350)
    // Frame
    drawRect(sx + 260, GAME_H - 85, 3, 55, '#555555');
    drawRect(sx + 340, GAME_H - 85, 3, 55, '#555555');
    drawRect(sx + 258, GAME_H - 87, 88, 3, '#555555');
    // Swing 1
    const swing1Angle = Math.sin(game.frameCount * 0.04) * 0.3;
    const s1x = sx + 285 + Math.sin(swing1Angle) * 15;
    const s1y = GAME_H - 48;
    drawRect(sx + 285, GAME_H - 85, 1, 37 + Math.floor(Math.cos(swing1Angle) * 2), '#666666'); // Chain
    drawRect(s1x - 3, s1y, 8, 2, '#8B4513'); // Seat
    // Kid on swing
    drawRect(s1x - 1, s1y - 6, 4, 5, PAL.blue); // Body
    drawRect(s1x, s1y - 9, 3, 3, PAL.peach); // Head

    // Swing 2
    const swing2Angle = Math.sin(game.frameCount * 0.04 + 2) * 0.3;
    const s2x = sx + 315 + Math.sin(swing2Angle) * 15;
    const s2y = GAME_H - 48;
    drawRect(sx + 315, GAME_H - 85, 1, 37 + Math.floor(Math.cos(swing2Angle) * 2), '#666666');
    drawRect(s2x - 3, s2y, 8, 2, '#8B4513');

    // === BENCHES ===
    drawRect(sx + 400, GAME_H - 48, 30, 3, '#8B4513');
    drawRect(sx + 402, GAME_H - 45, 3, 15, '#6a3a1a');
    drawRect(sx + 425, GAME_H - 45, 3, 15, '#6a3a1a');
    drawRect(sx + 400, GAME_H - 55, 30, 3, '#8B4513'); // Back

    drawRect(sx + 600, GAME_H - 48, 30, 3, '#8B4513');
    drawRect(sx + 602, GAME_H - 45, 3, 15, '#6a3a1a');
    drawRect(sx + 625, GAME_H - 45, 3, 15, '#6a3a1a');
    drawRect(sx + 600, GAME_H - 55, 30, 3, '#8B4513');

    // === TREES ===
    const treePositions = [50, 220, 450, 550, 750, 870];
    treePositions.forEach(tx => {
        const ttx = sx + tx;
        // Trunk
        drawRect(ttx, GAME_H - 70, 6, 40, '#6a4a2a');
        drawRect(ttx + 1, GAME_H - 70, 4, 40, '#7a5a3a');
        // Canopy
        drawRect(ttx - 10, GAME_H - 90, 26, 14, '#2a6a2a');
        drawRect(ttx - 8, GAME_H - 96, 22, 8, '#3a7a3a');
        drawRect(ttx - 5, GAME_H - 100, 16, 5, '#4a8a4a');
        // Leaf detail
        drawPixel(ttx - 6, GAME_H - 88, '#5a9a5a');
        drawPixel(ttx + 12, GAME_H - 92, '#5a9a5a');
    });

    // === TRASH BINS ===
    drawRect(sx + 380, GAME_H - 42, 6, 12, '#555555');
    drawRect(sx + 379, GAME_H - 43, 8, 2, '#666666');

    // === GRAVEL PATH ===
    for (let gp = 60; gp < 850; gp += 4) {
        const gpx = sx + gp;
        if ((gp + Math.floor(gp * 0.3)) % 7 < 4) {
            drawPixel(gpx, GAME_H - 31, '#aa9977');
            drawPixel(gpx, GAME_H - 30, '#bbaa88');
        }
    }

    // Dog poop warning sign - bigger and clearer
    drawRect(sx + 506, GAME_H - 65, 2, 30, '#555555');
    drawRect(sx + 488, GAME_H - 80, 40, 18, PAL.white);
    drawRect(sx + 490, GAME_H - 78, 36, 14, '#ffeeee');
    // Poop icon on sign
    drawRect(sx + 503, GAME_H - 76, 3, 2, '#6a4a2a');
    drawRect(sx + 504, GAME_H - 78, 2, 2, '#7a5a3a');
    drawRect(sx + 505, GAME_H - 79, 1, 1, '#6a4a2a');
    // Red diagonal cross
    drawRect(sx + 492, GAME_H - 75, 30, 1, PAL.red);
    drawRect(sx + 506, GAME_H - 78, 1, 10, PAL.red);
    // Text below icon
    drawText('PLOCKA', sx + 491, GAME_H - 70, PAL.red, 1);
    drawText('UPP!', sx + 498, GAME_H - 64, PAL.red, 1);
}

// ---- LÅNGGATAN & STJÄRNGATAN (Residential streets) ----
function drawArea_STREETS(areaX, camX) {
    const sx = Math.floor(areaX - camX);

    // Street name signs
    drawRect(sx + 30, GAME_H - 95, 2, 60, '#555555');
    drawRect(sx + 10, GAME_H - 100, 58, 12, '#2244aa');
    drawText('LÅNGGATAN', sx + 12, GAME_H - 98, PAL.white, 1);

    drawRect(sx + 640, GAME_H - 95, 2, 60, '#555555');
    drawRect(sx + 608, GAME_H - 100, 70, 12, '#2244aa');
    drawText('STJÄRNGATAN', sx + 610, GAME_H - 98, PAL.white, 1);

    // Road through the neighborhood
    drawRect(sx, GAME_H - 8, 1300, 8, '#3a3a3a');
    for (let ri = 0; ri < 1300; ri += 20) {
        drawRect(sx + ri, GAME_H - 5, 10, 2, PAL.yellow);
    }

    // === HOUSES with backyards ===
    const houses = [
        { x: 60,  color: '#cc4444', roofColor: '#882222', poolColor: '#44aaff', hasPool: true },
        { x: 260, color: '#4488cc', roofColor: '#225588', poolColor: '#44ccff', hasPool: false },
        { x: 460, color: '#cccc44', roofColor: '#888822', poolColor: '#44aaff', hasPool: true },
        { x: 680, color: '#88cc44', roofColor: '#558822', poolColor: '#44ccff', hasPool: true },
        { x: 880, color: '#cc8844', roofColor: '#885522', poolColor: '#44aaff', hasPool: false },
        { x: 1080, color: '#aa44cc', roofColor: '#662288', poolColor: '#44ccff', hasPool: true },
    ];

    houses.forEach((h, idx) => {
        const hx = sx + h.x;
        // === FENCE in front ===
        for (let fi = 0; fi < 160; fi += 8) {
            drawRect(hx + fi, GAME_H - 48, 2, 18, '#ddddcc');
        }
        drawRect(hx, GAME_H - 48, 160, 1, '#ddddcc');
        drawRect(hx, GAME_H - 38, 160, 1, '#ddddcc');

        // === MAILBOX ===
        drawRect(hx + 5, GAME_H - 56, 8, 8, '#444444');
        drawRect(hx + 4, GAME_H - 57, 10, 2, '#555555');
        drawRect(hx + 6, GAME_H - 54, 6, 1, '#ffeeaa'); // Letter sticking out
        drawRect(hx + 7, GAME_H - 64, 2, 10, '#444444'); // Post

        // === HOUSE ===
        const hy = GAME_H - 110;
        drawRect(hx + 25, hy, 80, 78, h.color);
        drawRect(hx + 27, hy + 2, 76, 74, h.color);
        // Darker shade on side
        drawRect(hx + 95, hy + 2, 8, 74, '#00000033');
        // Roof
        for (let ri = 0; ri < 15; ri++) {
            drawRect(hx + 20 - ri, hy - ri, 92 + ri * 2, 1, h.roofColor);
        }
        // Chimney
        drawRect(hx + 80, hy - 20, 8, 12, '#666655');
        drawRect(hx + 79, hy - 21, 10, 2, '#777766');
        // Smoke
        if (idx % 2 === 0) {
            const smokeOff = Math.sin(game.frameCount * 0.03 + idx) * 3;
            bctx.fillStyle = 'rgba(150,150,150,0.15)';
            bctx.fillRect(hx + 82 + smokeOff, hy - 28, 4, 6);
            bctx.fillRect(hx + 83 + smokeOff * 1.5, hy - 34, 3, 5);
        }
        // Windows
        for (let wr = 0; wr < 2; wr++) {
            for (let wc = 0; wc < 3; wc++) {
                const wx = hx + 32 + wc * 22;
                const wy = hy + 8 + wr * 30;
                drawRect(wx, wy, 14, 12, '#ffdd88');
                drawRect(wx + 1, wy + 1, 12, 10, '#ffeeaa');
                drawRect(wx + 6, wy + 1, 2, 10, '#8B6914');
                drawRect(wx + 1, wy + 5, 12, 1, '#8B6914');
            }
        }
        // Front door
        drawRect(hx + 55, hy + 48, 18, 28, '#5a3020');
        drawRect(hx + 57, hy + 50, 14, 26, '#6a4030');
        drawRect(hx + 69, hy + 62, 2, 3, PAL.yellow); // Doorknob

        // === GARAGE (attached to house) ===
        drawRect(hx + 110, hy + 20, 40, 56, '#888877');
        drawRect(hx + 112, hy + 22, 36, 52, '#999988');
        // Garage door
        drawRect(hx + 115, hy + 38, 30, 38, '#aaa999');
        for (let gdi = 0; gdi < 4; gdi++) {
            drawRect(hx + 115, hy + 38 + gdi * 9, 30, 1, '#888877');
        }

        // === BACKYARD ===
        // Grass area behind fence
        drawRect(hx + 25, GAME_H - 30, 130, 4, '#4a9a4a');

        // Swimming pool (some houses)
        if (h.hasPool) {
            const px2 = hx + 120;
            const py2 = GAME_H - 42;
            drawRect(px2, py2, 30, 12, '#336699');
            drawRect(px2 + 1, py2 + 1, 28, 10, h.poolColor);
            // Water shimmer
            const shimmer = Math.sin(game.frameCount * 0.06 + idx) * 2;
            drawRect(px2 + 5 + shimmer, py2 + 3, 8, 1, '#88ddff');
            drawRect(px2 + 15 - shimmer, py2 + 6, 6, 1, '#88ddff');
            // Pool edge
            drawRect(px2 - 1, py2 - 1, 32, 1, '#dddddd');
            drawRect(px2 - 1, py2 + 12, 32, 1, '#dddddd');
            drawRect(px2 - 1, py2, 1, 12, '#dddddd');
            drawRect(px2 + 30, py2, 1, 12, '#dddddd');
        }

        // Driveway
        drawRect(hx + 115, GAME_H - 32, 35, 2, '#777766');
    });
}

// ---- DISC GOLF FIELD ----
function drawArea_DISCGOLF(areaX, camX) {
    const sx = Math.floor(areaX - camX);

    // Open green field background
    drawRect(sx, 80, 1000, GAME_H - 110, '#5aaa4a');
    drawRect(sx, 80, 1000, 5, '#4a9a3a');

    // Disc golf course sign
    drawRect(sx + 40, GAME_H - 85, 100, 16, '#2a5a1a');
    drawRect(sx + 42, GAME_H - 83, 96, 12, '#3a6a2a');
    drawText('DISCGOLF', sx + 52, GAME_H - 80, PAL.yellow, 1);
    drawText('VÄNNÄS', sx + 56, GAME_H - 72, PAL.white, 1);

    // Disc golf baskets (targets)
    const baskets = [200, 400, 600, 800];
    baskets.forEach((bx, bi) => {
        const bbx = sx + bx;
        // Pole
        drawRect(bbx, GAME_H - 70, 2, 40, '#888888');
        // Basket
        drawRect(bbx - 5, GAME_H - 72, 12, 3, '#aaaaaa');
        // Chains
        for (let ch = 0; ch < 3; ch++) {
            drawRect(bbx - 3 + ch * 3, GAME_H - 78, 1, 6, '#999999');
        }
        // Top disc/cap
        drawRect(bbx - 4, GAME_H - 80, 10, 2, '#bbbbbb');
        // Number
        drawText(String(bi + 1), bbx - 2, GAME_H - 65, PAL.white, 1);
    });

    // Trees at edges
    [50, 950].forEach(tx => {
        const ttx = sx + tx;
        drawRect(ttx, GAME_H - 75, 6, 45, '#6a4a2a');
        drawRect(ttx - 12, GAME_H - 95, 30, 16, '#2a6a2a');
        drawRect(ttx - 8, GAME_H - 105, 22, 12, '#3a7a3a');
    });

    // Tee pads (flat concrete squares)
    [150, 350, 550, 750].forEach(tp => {
        drawRect(sx + tp, GAME_H - 33, 15, 3, '#999988');
    });

    // Warning sign: flying discs
    drawRect(sx + 510, GAME_H - 80, 2, 48, '#555555');
    drawRect(sx + 488, GAME_H - 92, 56, 14, PAL.yellow);
    drawRect(sx + 490, GAME_H - 90, 52, 10, '#ffee44');
    drawText('VARNING!', sx + 490, GAME_H - 89, PAL.red, 1);
    // Disc icon below text
    drawRect(sx + 506, GAME_H - 82, 6, 2, '#ff4444');
    drawRect(sx + 508, GAME_H - 83, 2, 1, '#ffaaaa');
}

// ---- VÄNNÄS ISHALL ----
function drawArea_ISHALL(areaX, camX) {
    const sx = Math.floor(areaX - camX);

    // Large ice hall building
    const by = GAME_H - 120;
    drawRect(sx + 50, by, 500, 90, '#667788');
    drawRect(sx + 52, by + 2, 496, 86, '#778899');
    // Metal roof with slight curve
    for (let ri = 0; ri < 10; ri++) {
        const roofW = 504 - ri * 0.5;
        const roofX = sx + 48 + (504 - roofW) / 2;
        drawRect(roofX, by - ri, roofW, 1, ri < 5 ? '#556677' : '#445566');
    }

    // VÄNNÄS ISHALL sign
    drawRect(sx + 150, by + 8, 160, 20, '#223344');
    drawRect(sx + 152, by + 10, 156, 16, '#334455');
    drawText('VÄNNÄS ISHALL', sx + 162, by + 14, PAL.white, 1);

    // Large entrance
    drawRect(sx + 230, by + 40, 50, 48, '#334455');
    drawRect(sx + 234, by + 44, 42, 44, '#445566');
    // Glass doors
    drawRect(sx + 236, by + 46, 18, 42, '#88aacc');
    drawRect(sx + 258, by + 46, 18, 42, '#88aacc');
    // Door handles
    drawRect(sx + 252, by + 66, 2, 5, '#aaaaaa');
    drawRect(sx + 258, by + 66, 2, 5, '#aaaaaa');

    // Windows
    for (let wi = 0; wi < 6; wi++) {
        const wx = sx + 70 + wi * 70;
        if (wx > sx + 220 && wx < sx + 290) continue; // Skip entrance
        drawRect(wx, by + 20, 30, 15, '#88aacc');
        drawRect(wx + 1, by + 21, 28, 13, '#99bbdd');
        drawRect(wx + 14, by + 21, 2, 13, '#778899');
    }

    // Parking lot lines in front
    for (let pi = 0; pi < 5; pi++) {
        drawRect(sx + 100 + pi * 60, GAME_H - 32, 1, 10, PAL.white);
    }

    // Hockey stick and puck decorative sign
    drawRect(sx + 450, by + 15, 30, 30, '#223344');
    // Stick (diagonal)
    for (let hi = 0; hi < 10; hi++) {
        drawPixel(sx + 455 + hi, by + 20 + hi, '#aa8833');
        drawPixel(sx + 456 + hi, by + 20 + hi, '#aa8833');
    }
    // Puck
    drawRect(sx + 465, by + 32, 6, 3, '#222222');
}

// ---- POND + STAGE (boss area) ----
function drawArea_POND(areaX, camX) {
    const sx = Math.floor(areaX - camX);

    // === BACKGROUND WATER POND (Röda Viken) ===
    const pondX = sx + 100;
    const pondW = 600;
    const pondY = GAME_H - 80;

    // Water body - drawn as horizontal bands (fast!)
    const waterBands = [
        { y: 0, h: 5, col: '#2288aa' },
        { y: 5, h: 5, col: '#1e7da0' },
        { y: 10, h: 5, col: '#1a7296' },
        { y: 15, h: 5, col: '#16678c' },
        { y: 20, h: 5, col: '#125c82' },
        { y: 25, h: 5, col: '#0e5178' },
        { y: 30, h: 5, col: '#0a466e' },
    ];
    waterBands.forEach(b => {
        drawRect(pondX, pondY + b.y, pondW, b.h, b.col);
    });

    // Animated wave highlights on surface (just a few rects, not per-pixel)
    const waveT = game.frameCount * 0.5;
    for (let w = 0; w < 12; w++) {
        const wx = pondX + w * 50 + Math.floor(Math.sin(waveT * 0.08 + w) * 6);
        const ww = 15 + Math.floor(Math.sin(waveT * 0.05 + w * 2) * 5);
        drawRect(wx, pondY, ww, 2, '#3399bb');
        drawRect(wx + 3, pondY + 1, Math.max(1, ww - 6), 1, '#55bbdd');
    }
    // Shimmer sparkles (just a handful)
    for (let ws = 0; ws < 10; ws++) {
        const wsx = pondX + Math.floor(Math.sin(game.frameCount * 0.03 + ws * 1.7) * 20) + ws * 60;
        const wsy = pondY + 2 + Math.floor(Math.sin(game.frameCount * 0.05 + ws) * 2);
        if ((game.frameCount + ws * 7) % 12 < 8) {
            drawRect(Math.floor(wsx), Math.floor(wsy), 2, 1, '#88ccee');
        }
    }
    // Wave edge line
    for (let we = 0; we < 10; we++) {
        const wex = pondX + we * 60 + Math.floor(Math.sin((we + game.frameCount * 0.6) * 0.1) * 4);
        drawRect(wex, pondY - 1, 20, 1, '#aaddee');
    }
    // Pond shore / beach edge
    drawRect(pondX - 10, pondY + 35, pondW + 20, 1, '#aa9966');
    drawRect(pondX - 10, pondY + 36, pondW + 20, 1, '#997755');

    // Reeds at pond edges
    for (let reed = 0; reed < 8; reed++) {
        const rx = pondX - 15 + reed * 6;
        const sway = Math.sin(game.frameCount * 0.04 + reed) * 1;
        drawRect(rx + Math.floor(sway), GAME_H - 92, 1, 18, '#556622');
        drawPixel(rx + Math.floor(sway), GAME_H - 94, '#667733');
        drawPixel(rx + Math.floor(sway) + 1, GAME_H - 93, '#667733');
    }
    for (let reed = 0; reed < 8; reed++) {
        const rx = pondX + pondW + 5 + reed * 6;
        const sway = Math.sin(game.frameCount * 0.04 + reed + 3) * 1;
        drawRect(rx + Math.floor(sway), GAME_H - 92, 1, 18, '#556622');
        drawPixel(rx + Math.floor(sway), GAME_H - 93, '#667733');
    }
    // Ducks floating on water
    for (let dk = 0; dk < 3; dk++) {
        const dkx = pondX + 80 + dk * 180 + Math.sin(game.frameCount * 0.02 + dk * 2) * 15;
        const dky = pondY + 8 + Math.sin(game.frameCount * 0.03 + dk) * 2;
        drawRect(Math.floor(dkx), Math.floor(dky), 5, 3, '#bb8822');
        drawRect(Math.floor(dkx) + 4, Math.floor(dky) - 1, 2, 2, '#aa7711');
        drawPixel(Math.floor(dkx) + 5, Math.floor(dky) - 1, '#dd8800');
    }

    // === RÖDA VIKEN SIGN ===
    // Big wooden sign post
    const signX = sx + 80;
    const signY = GAME_H - 120;
    // Two posts
    drawRect(signX + 5, signY + 10, 3, 50, '#5a3a1a');
    drawRect(signX + 82, signY + 10, 3, 50, '#5a3a1a');
    // Sign board
    drawRect(signX, signY, 90, 24, '#8B2500');
    drawRect(signX + 2, signY + 2, 86, 20, '#A52A0A');
    drawRect(signX + 2, signY + 2, 86, 2, '#BB3A1A'); // Top highlight
    // Text
    drawText('RÖDA VIKEN', signX + 10, signY + 7, PAL.yellow, 1);
    // Small wave decoration on sign
    for (let dw = 0; dw < 6; dw++) {
        drawPixel(signX + 10 + dw * 12, signY + 18, '#4488bb');
        drawPixel(signX + 13 + dw * 12, signY + 17, '#4488bb');
        drawPixel(signX + 16 + dw * 12, signY + 18, '#4488bb');
    }

    // === BBQ AREA ===
    const bbqX = sx + 850;
    const bbqY = GAME_H - 55;

    // Gravel / patio area (drawn as a few rects, not per-pixel)
    drawRect(bbqX - 30, bbqY + 12, 210, 22, '#918273');
    drawRect(bbqX - 28, bbqY + 14, 206, 18, '#897565');
    // Gravel texture - sparse dots
    for (let gt = 0; gt < 20; gt++) {
        const gx = bbqX - 25 + gt * 10 + (gt % 3) * 3;
        const gy = bbqY + 15 + (gt % 4) * 4;
        drawPixel(gx, gy, '#aa9988');
        drawPixel(gx + 5, gy + 2, '#776655');
    }

    // BBQ grill - round stone grill
    drawRect(bbqX, bbqY + 2, 20, 8, '#555555');
    drawRect(bbqX + 1, bbqY, 18, 3, '#666666'); // Top rim
    drawRect(bbqX + 2, bbqY + 1, 16, 1, '#777777'); // Highlight
    // Grill grate
    for (let gr = 0; gr < 6; gr++) {
        drawPixel(bbqX + 3 + gr * 3, bbqY + 3, '#444444');
    }
    // Legs
    drawRect(bbqX + 3, bbqY + 10, 2, 6, '#444444');
    drawRect(bbqX + 15, bbqY + 10, 2, 6, '#444444');
    // Fire glow / embers
    if (game.frameCount % 6 < 4) {
        drawRect(bbqX + 5, bbqY + 2, 3, 2, '#ff6600');
        drawRect(bbqX + 10, bbqY + 2, 2, 2, '#ff4400');
        drawPixel(bbqX + 13, bbqY + 2, '#ffaa00');
    }
    // Smoke rising
    for (let sm = 0; sm < 4; sm++) {
        const smokeOff = Math.sin(game.frameCount * 0.06 + sm) * 3;
        const smokeY = bbqY - 5 - sm * 5;
        const smokeAlpha = 0.3 - sm * 0.06;
        bctx.fillStyle = `rgba(180,180,180,${smokeAlpha})`;
        bctx.fillRect(bbqX + 8 + Math.floor(smokeOff), smokeY, 3, 3);
    }
    // Sausages on grill (korv!)
    drawRect(bbqX + 4, bbqY + 2, 5, 1, '#aa3322');
    drawRect(bbqX + 11, bbqY + 2, 5, 1, '#bb4433');
    drawRect(bbqX + 7, bbqY + 3, 4, 1, '#993322');

    // === PICNIC TABLE 1 (left of BBQ) ===
    const tbl1X = bbqX - 60;
    const tbl1Y = bbqY + 2;
    // Table top
    drawRect(tbl1X, tbl1Y, 30, 3, '#7a5a3a');
    drawRect(tbl1X + 1, tbl1Y, 28, 1, '#8a6a4a'); // Highlight
    // Table legs
    drawRect(tbl1X + 4, tbl1Y + 3, 2, 8, '#6a4a2a');
    drawRect(tbl1X + 24, tbl1Y + 3, 2, 8, '#6a4a2a');
    // Bench seats on sides
    drawRect(tbl1X - 4, tbl1Y + 5, 10, 2, '#7a5a3a');
    drawRect(tbl1X + 24, tbl1Y + 5, 10, 2, '#7a5a3a');
    // Bench legs
    drawRect(tbl1X - 2, tbl1Y + 7, 2, 5, '#6a4a2a');
    drawRect(tbl1X + 4, tbl1Y + 7, 2, 5, '#6a4a2a');
    drawRect(tbl1X + 26, tbl1Y + 7, 2, 5, '#6a4a2a');
    drawRect(tbl1X + 32, tbl1Y + 7, 2, 5, '#6a4a2a');
    // Ketchup & mustard bottles on table
    drawRect(tbl1X + 10, tbl1Y - 4, 3, 4, '#cc2222');
    drawPixel(tbl1X + 11, tbl1Y - 5, '#dd3333');
    drawRect(tbl1X + 16, tbl1Y - 4, 3, 4, '#cccc22');
    drawPixel(tbl1X + 17, tbl1Y - 5, '#dddd33');

    // === PICNIC TABLE 2 (right of BBQ) ===
    const tbl2X = bbqX + 70;
    const tbl2Y = bbqY + 2;
    drawRect(tbl2X, tbl2Y, 30, 3, '#7a5a3a');
    drawRect(tbl2X + 1, tbl2Y, 28, 1, '#8a6a4a');
    drawRect(tbl2X + 4, tbl2Y + 3, 2, 8, '#6a4a2a');
    drawRect(tbl2X + 24, tbl2Y + 3, 2, 8, '#6a4a2a');
    drawRect(tbl2X - 4, tbl2Y + 5, 10, 2, '#7a5a3a');
    drawRect(tbl2X + 24, tbl2Y + 5, 10, 2, '#7a5a3a');
    drawRect(tbl2X - 2, tbl2Y + 7, 2, 5, '#6a4a2a');
    drawRect(tbl2X + 4, tbl2Y + 7, 2, 5, '#6a4a2a');
    drawRect(tbl2X + 26, tbl2Y + 7, 2, 5, '#6a4a2a');
    drawRect(tbl2X + 32, tbl2Y + 7, 2, 5, '#6a4a2a');
    // Plates on table
    drawRect(tbl2X + 8, tbl2Y - 2, 5, 2, PAL.white);
    drawRect(tbl2X + 18, tbl2Y - 2, 5, 2, PAL.white);

    // === EXTRA BENCH (near water) ===
    const benchX = sx + 500;
    const benchY = GAME_H - 48;
    drawRect(benchX, benchY, 20, 2, '#7a5a3a');
    drawRect(benchX + 1, benchY - 6, 18, 2, '#6a4a2a'); // Backrest
    drawRect(benchX + 2, benchY + 2, 2, 5, '#5a3a1a');
    drawRect(benchX + 16, benchY + 2, 2, 5, '#5a3a1a');

    // === TRASH BIN near BBQ ===
    drawRect(bbqX + 40, bbqY + 4, 7, 9, '#555555');
    drawRect(bbqX + 39, bbqY + 3, 9, 2, '#666666');
    drawPixel(bbqX + 42, bbqY + 7, '#333333'); // Hole

    // === STAGE by the pond ===
    const stageX = sx + 800;
    const stageY = GAME_H - 75;
    // Stage platform
    drawRect(stageX, stageY, 400, 45, '#4a3020');
    drawRect(stageX + 2, stageY + 2, 396, 4, '#5a4030');
    // Stage front
    drawRect(stageX, stageY + 42, 400, 3, '#3a2010');
    // Stage floor
    drawRect(stageX + 5, stageY + 6, 390, 36, '#6a5040');

    // Speaker stacks on sides
    for (let side = 0; side < 2; side++) {
        const spkX = side === 0 ? stageX + 5 : stageX + 370;
        for (let spk = 0; spk < 3; spk++) {
            drawRect(spkX, stageY + 6 + spk * 12, 25, 11, '#222222');
            drawRect(spkX + 3, stageY + 8 + spk * 12, 6, 6, '#333333');
            drawRect(spkX + 12, stageY + 9 + spk * 12, 10, 4, '#333333');
            // Speaker pulse
            if (game.level3BossActive && game.frameCount % 8 < 4) {
                drawRect(spkX + 4, stageY + 9 + spk * 12, 4, 4, '#444455');
            }
        }
    }

    // Banner: RIFF RAFF RUFF
    drawRect(stageX + 80, stageY - 18, 240, 20, '#111111');
    drawRect(stageX + 82, stageY - 16, 236, 16, '#222222');
    const bannerBlink = game.frameCount % 30 < 20;
    drawText('RIFF RAFF RUFF', stageX + 104, stageY - 12, bannerBlink ? PAL.red : PAL.orange, 1);

    // Stage lights
    for (let sl = 0; sl < 5; sl++) {
        const slx = stageX + 60 + sl * 70;
        drawRect(slx, stageY - 5, 3, 7, '#333333');
        const spotOn = (game.frameCount + sl * 15) % 40 < 30;
        if (spotOn && game.level3BossActive) {
            const spotCol = ['rgba(255,50,50,0.06)', 'rgba(50,50,255,0.06)', 'rgba(255,255,50,0.06)', 'rgba(50,255,50,0.06)', 'rgba(255,50,255,0.06)'][sl];
            bctx.fillStyle = spotCol;
            bctx.beginPath();
            bctx.moveTo(slx + 1, stageY + 2);
            bctx.lineTo(slx - 20, stageY + 42);
            bctx.lineTo(slx + 22, stageY + 42);
            bctx.fill();
            drawRect(slx - 1, stageY - 3, 5, 3, sl % 2 === 0 ? '#ff4444' : '#4444ff');
        }
    }

    // Trees near pond and BBQ area
    [50, 750, 1300].forEach(tx => {
        const ttx = sx + tx;
        drawRect(ttx, GAME_H - 70, 5, 40, '#5a3a1a');
        drawRect(ttx - 8, GAME_H - 85, 22, 12, '#2a7a2a');
        drawRect(ttx - 5, GAME_H - 93, 16, 10, '#3a8a3a');
    });
    // Birch trees (white trunks)
    [300, 680].forEach(tx => {
        const ttx = sx + tx;
        drawRect(ttx, GAME_H - 65, 4, 35, '#ddddcc');
        drawRect(ttx + 1, GAME_H - 58, 1, 10, '#666666'); // Birch stripe
        drawRect(ttx + 1, GAME_H - 45, 1, 6, '#666666');
        drawRect(ttx - 7, GAME_H - 78, 18, 10, '#3a9a3a');
        drawRect(ttx - 4, GAME_H - 85, 12, 8, '#4aaa4a');
    });

    // Gravel path along area
    for (let pp = 0; pp < 800; pp += 5) {
        const ppx = sx + pp;
        if (pp % 8 < 5) {
            drawPixel(ppx, GAME_H - 31, '#aa9977');
        }
    }
}

function drawLevel3Areas() {
    level3Areas.forEach(a => {
        const aEnd = a.x + a.w;
        if (aEnd < game.camX - 50 || a.x > game.camX + GAME_W + 50) return;
        switch (a.type) {
            case 'park':     drawArea_PARK(a.x, game.camX); break;
            case 'streets':  drawArea_STREETS(a.x, game.camX); break;
            case 'discgolf': drawArea_DISCGOLF(a.x, game.camX); break;
            case 'ishall':   drawArea_ISHALL(a.x, game.camX); break;
            case 'pond':     drawArea_POND(a.x, game.camX); break;
        }
    });
}

// ---- LEVEL 3 ENEMY SPRITES ----
function getDogSprite(frame, pooping) {
    const _ = null;
    const Br = '#8B6914';
    const Bd = '#6a4a0a';
    const Bk = '#111111';
    const Ey = PAL.black;
    const Ns = '#333333';
    const Tg = '#ff6666';
    const tail = frame % 10 < 5;
    if (pooping) {
        return [
            [_,_,Br,Br,_,_,_,_,_,_,_],
            [_,Br,Ey,Br,Br,Br,Br,Br,_,_,_],
            [_,Br,Br,Br,Br,Br,Br,Br,Br,_,_],
            [Ns,Br,Br,Bd,Bd,Bd,Bd,Bd,Br,_,_],
            [_,_,Bd,Bd,Bd,Bd,Bd,Bd,_,_,_],
            [_,_,Bd,_,_,_,_,Bd,_,'#6a4a2a',_],
        ];
    }
    return [
        [_,_,Br,Br,_,_,_,_,_,_,tail?Br:_],
        [_,Br,Ey,Br,Br,Br,Br,Br,_,tail?Br:_,_],
        [_,Br,Br,Br,Br,Br,Br,Br,Br,_,_],
        [Ns,Br,Tg,Bd,Bd,Bd,Bd,Bd,Br,_,_],
        [_,_,Bd,_,Bd,_,Bd,_,Bd,_,_],
    ];
}

function getDiscGolferSprite(frame, throwing) {
    const _ = null;
    const Sk = PAL.peach;
    const sh = '#cc9977';
    const Ht = '#44aa44'; // Green sporty cap
    const Sh = '#226622'; // Shirt
    const Sd = '#115511';
    const Pn = '#334455'; // Pants
    const Bt = '#333333';
    const Ey = PAL.black;
    const Dc = '#ff4444'; // Disc color

    if (throwing) {
        return [
            [_,_,Ht,Ht,Ht,Ht,_,_,_,_],
            [_,_,Sk,Sk,Sk,Sk,_,_,_,_],
            [_,_,sh,Ey,Sk,Ey,_,_,_,_],
            [_,Sh,Sh,Sh,Sh,Sh,Sk,Dc,Dc,_],
            [_,Sd,Sh,Sh,Sh,Sh,_,_,_,_],
            [_,_,Pn,_,Pn,_,_,_,_,_],
            [_,_,Bt,_,Bt,_,_,_,_,_],
        ];
    }
    return [
        [_,_,Ht,Ht,Ht,Ht,_,_],
        [_,_,Sk,Sk,Sk,Sk,_,_],
        [_,_,sh,Ey,Sk,Ey,_,_],
        [_,Sk,Sh,Sh,Sh,Sh,Sk,_],
        [_,_,Sd,Sh,Sh,Sd,_,_],
        [_,_,Pn,_,Pn,_,_,_],
        [_,_,Bt,_,Bt,_,_,_],
    ];
}

// Skateboarder enemy sprite
function getSkaterSprite(frame) {
    const _ = null;
    const Sk = PAL.peach;
    const sh = '#cc9977';
    const Ey = PAL.black;
    const Cp = '#cc2222'; // Red cap backwards
    const Ts = '#2244aa'; // Blue t-shirt
    const Td = '#1a3388';
    const Pn = '#554433'; // Khaki shorts
    const Bt = '#ff4444'; // Red shoes
    const Bd = '#aaaaaa'; // Board
    const Wh = '#444444'; // Wheels
    const lean = frame % 40 < 20 ? 0 : 1;
    return [
        [_,_,Cp,Cp,Cp,Cp,_,_,_,_],
        [_,_,Cp,Cp,Sk,Sk,Sk,_,_,_],
        [_,_,_,Sk,Sk,Sk,Sk,_,_,_],
        [_,_,_,sh,Ey,Sk,Ey,_,_,_],
        [_,_,Sk,Ts,Ts,Ts,Ts,Sk,_,_],
        [_,_,_,Td,Ts,Ts,Td,_,_,_],
        [_,_,_,Pn,Pn,Pn,_,_,_,_],
        [_,_,_,Bt,_,_,Bt,_,_,_],
        [_,Wh,Bd,Bd,Bd,Bd,Bd,Bd,Wh,_],
        [_,Wh,_,_,_,_,_,_,Wh,_],
    ];
}

// BMX rider enemy sprite
function getBMXSprite(frame) {
    const _ = null;
    const Sk = PAL.peach;
    const sh = '#cc9977';
    const Ey = PAL.black;
    const Hl = '#ffcc00'; // Helmet yellow
    const Hd = '#ddaa00';
    const Ts = '#222222'; // Dark shirt
    const Pn = '#333344'; // Jeans
    const Bt = '#222222'; // Shoes
    const Fr = '#888888'; // Frame
    const Fd = '#666666';
    const Wh = '#555555'; // Wheel rim
    const Sp = '#aaaaaa'; // Spokes
    const Hb = '#444444'; // Handlebar
    return [
        [_,_,_,Hl,Hl,Hl,_,_,_,_,_,_],
        [_,_,Hl,Hd,Hd,Hl,_,_,_,_,_,_],
        [_,_,Sk,Sk,Sk,Sk,_,_,_,_,_,_],
        [_,_,sh,Ey,Sk,Ey,_,_,Hb,_,_,_],
        [_,_,Sk,Ts,Ts,Ts,Sk,Sk,Hb,_,_,_],
        [_,_,_,Ts,Ts,Ts,_,_,_,_,_,_],
        [_,_,_,Pn,_,Pn,_,_,_,_,_,_],
        [_,_,Bt,Pn,_,Pn,Bt,_,_,_,_,_],
        [_,Wh,Sp,Wh,Fr,Fr,Fr,Wh,Sp,Wh,_,_],
        [Wh,Sp,_,Sp,Wh,_,Wh,Sp,_,Sp,Wh,_],
        [_,Wh,Sp,Wh,_,_,_,Wh,Sp,Wh,_,_],
    ];
}

// Hockey player enemy sprite
function getHockeyPlayerSprite(frame, shooting) {
    const _ = null;
    const Sk = PAL.peach;
    const sh = '#cc9977';
    const Ey = PAL.black;
    const Hl = '#cccccc'; // Hockey helmet
    const Hd = '#aaaaaa';
    const Gd = '#222288'; // Jersey (blue/gold - Vännäs Hockey)
    const Gs = '#4444aa';
    const Pn = '#222244'; // Hockey pants
    const Sk2 = '#dddddd'; // Skates
    const St = '#886611'; // Stick
    const Sd = '#aa8822';
    if (shooting) {
        return [
            [_,_,Hl,Hl,Hl,Hl,_,_,_,_,_],
            [_,_,Hd,Hl,Hl,Hd,_,_,_,_,_],
            [_,_,Sk,Sk,Sk,Sk,_,_,_,_,_],
            [_,_,sh,Ey,Sk,Ey,_,_,_,_,_],
            [_,Sk,Gd,Gd,Gd,Gd,Sk,St,St,St,St],
            [_,_,Gs,Gd,Gd,Gs,_,_,_,_,_],
            [_,_,Pn,Pn,Pn,Pn,_,_,_,_,_],
            [_,_,Pn,_,_,Pn,_,_,_,_,_],
            [_,Sk2,Sk2,_,_,Sk2,Sk2,_,_,_,_],
        ];
    }
    return [
        [_,_,Hl,Hl,Hl,Hl,_,_,_],
        [_,_,Hd,Hl,Hl,Hd,_,_,_],
        [_,_,Sk,Sk,Sk,Sk,_,_,_],
        [_,_,sh,Ey,Sk,Ey,_,_,_],
        [_,Sk,Gd,Gd,Gd,Gd,Sk,_,_],
        [_,_,Gs,Gd,Gd,Gs,_,_,_],
        [_,_,Pn,Pn,Pn,Pn,_,_,_],
        [_,_,Pn,_,_,Pn,_,_,_],
        [_,Sk2,Sk2,_,_,Sk2,Sk2,_,_],
        [_,_,_,_,_,_,_,St,St],
    ];
}

// Swan enemy sprite (angry swan)
function getSwanSprite(frame, attacking) {
    const _ = null;
    const Wh = PAL.white;
    const Wd = '#dddddd';
    const Bk = '#ff6600'; // Beak orange
    const Ey = PAL.black;
    const Wg = '#cccccc'; // Wing shade
    const wingUp = frame % 16 < 8;
    if (attacking) {
        // Attack pose - neck forward, wings spread
        return [
            [_,_,_,_,_,_,_,_,Ey,Bk,Bk],
            [_,_,_,_,_,_,_,Wh,Wh,Bk,_],
            [_,_,_,_,_,_,Wh,Wh,_,_,_],
            [Wg,_,_,_,Wh,Wh,Wh,_,_,_,_],
            [Wg,Wg,Wh,Wh,Wh,Wh,Wh,_,_,_,_],
            [_,Wh,Wh,Wd,Wh,Wh,_,_,_,_,_],
            [_,_,Wh,Wh,Wh,_,_,_,_,_,_],
        ];
    }
    if (wingUp) {
        return [
            [_,Ey,Bk,_,_,_,_,_,_],
            [Wh,Wh,_,_,_,_,_,_,_],
            [_,Wh,Wh,_,_,_,Wg,Wg,_],
            [_,_,Wh,Wh,Wh,Wg,Wg,_,_],
            [_,_,Wh,Wd,Wh,Wh,_,_,_],
            [_,_,_,Wh,Wh,_,_,_,_],
        ];
    }
    return [
        [_,Ey,Bk,_,_,_,_,_,_],
        [Wh,Wh,_,_,_,_,_,_,_],
        [_,Wh,Wh,_,_,_,_,_,_],
        [_,_,Wh,Wh,Wh,Wh,Wg,_,_],
        [_,_,Wh,Wd,Wh,Wh,_,_,_],
        [_,_,_,Wh,Wh,_,_,_,_],
    ];
}

// Band member sprites for Riff Raff Ruff
function getBandMemberSprite(role, frame, angry) {
    const _ = null;
    const Sk = PAL.peach;
    const sh = '#cc9977';
    const Ey = PAL.black;
    const Hr = '#111111'; // Dark hair (rock band!)

    if (role === 'guitar') {
        // Guitarist - leather jacket, long hair
        const Lj = '#222222'; // Leather
        const Ld = '#111111';
        const Gt = '#aa6622'; // Guitar body
        const Gn = '#886611'; // Guitar neck
        return [
            [_,_,Hr,Hr,Hr,Hr,Hr,Hr,_,_,_,_,_],
            [_,Hr,Hr,Hr,Hr,Hr,Hr,Hr,Hr,_,_,_,_],
            [_,Hr,Sk,Sk,Sk,Sk,Sk,Sk,Hr,_,_,_,_],
            [_,_,sh,Ey,Sk,Sk,Ey,Sk,sh,_,_,_,_],
            [_,_,_,Sk,Sk,angry?'#cc3333':Sk,Sk,Sk,_,_,_,_,_],
            [_,Lj,Lj,Lj,Lj,Lj,Lj,Lj,Lj,_,_,_,_],
            [Sk,Lj,Ld,Lj,Gt,Gt,Gt,Lj,Ld,Sk,Gn,Gn,Gn],
            [_,Lj,Lj,Lj,Gt,Gt,Gt,Lj,Lj,_,_,_,_],
            [_,_,Lj,Lj,Gt,Gt,Gt,Lj,Lj,_,_,_,_],
            [_,_,_,Ld,Ld,Ld,Ld,Ld,_,_,_,_,_],
            [_,_,'#1a1a44','#1a1a44',_,_,'#1a1a44','#1a1a44',_,_,_,_,_],
            [_,_,'#111111','#111111',_,_,'#111111','#111111',_,_,_,_,_],
        ];
    } else if (role === 'bass') {
        // Bass player - mohawk, band t-shirt
        const Ts = '#cc2222'; // Red shirt
        const Td = '#aa1111';
        const Mh = '#ff4444'; // Red mohawk
        return [
            [_,_,_,_,Mh,Mh,_,_,_,_,_,_,_],
            [_,_,_,Mh,Mh,Mh,Mh,_,_,_,_,_,_],
            [_,_,Sk,Sk,Sk,Sk,Sk,Sk,_,_,_,_,_],
            [_,_,sh,Ey,Sk,Sk,Ey,Sk,_,_,_,_,_],
            [_,_,_,Sk,Sk,angry?'#cc3333':Sk,Sk,_,_,_,_,_,_],
            [_,Ts,Ts,Ts,Ts,Ts,Ts,Ts,Ts,_,_,_,_],
            [Sk,Ts,Td,Ts,Ts,Ts,Ts,Td,Ts,Sk,_,_,_],
            [_,Ts,Ts,Ts,Ts,Ts,Ts,Ts,Ts,_,_,_,_],
            [_,_,Td,Td,Td,Td,Td,Td,_,_,_,_,_],
            [_,_,'#222244','#222244',_,'#222244','#222244',_,_,_,_,_,_],
            [_,_,'#111133','#111133',_,'#111133','#111133',_,_,_,_,_,_],
        ];
    } else {
        // Drummer - headband, tank top, big arms
        const Tt = '#333333'; // Tank top
        const Hb = '#ff8800'; // Headband
        const Ds = '#aa8833'; // Drumstick color
        const pump = Math.floor(Math.sin(frame * 0.3) * 2);
        return [
            [_,_,Hr,Hr,Hr,Hr,Hr,_,_,_,_,_,_],
            [_,_,Hb,Hb,Hb,Hb,Hb,_,_,_,_,_,_],
            [_,_,Sk,Sk,Sk,Sk,Sk,Sk,_,_,_,_,_],
            [_,_,sh,Ey,Sk,Sk,Ey,Sk,_,_,_,_,_],
            [_,_,_,Sk,Sk,angry?'#cc3333':Sk,Sk,_,_,_,_,_,_],
            [_,Sk,Tt,Tt,Tt,Tt,Tt,Tt,Sk,_,_,_,_],
            [Sk,Sk,Tt,Tt,Tt,Tt,Tt,Tt,Sk,Sk,Ds,_,_],
            [_,_,Tt,Tt,Tt,Tt,Tt,Tt,_,_,Ds,_,_],
            [_,_,_,Tt,Tt,Tt,Tt,_,_,_,_,_,_],
            [_,_,'#222244','#222244',_,'#222244','#222244',_,_,_,_,_,_],
            [_,_,'#111133','#111133',_,'#111133','#111133',_,_,_,_,_,_],
        ];
    }
}

// ---- LEVEL 3 HUD ----
function drawHUDLevel3() {
    // Health bar - same style
    drawRect(3, 3, 56, 12, '#000000');
    drawRect(4, 4, 54, 10, '#220000');
    drawRect(5, 5, 52, 8, '#330000');
    const hpWidth = Math.floor(50 * player.hp / player.maxHp);
    const hpColor = player.hp > 60 ? PAL.green : (player.hp > 30 ? PAL.yellow : PAL.red);
    const hpColorDark = player.hp > 60 ? '#006600' : (player.hp > 30 ? '#666600' : '#660000');
    drawRect(6, 6, hpWidth, 3, hpColor);
    drawRect(6, 9, hpWidth, 3, hpColorDark);
    if (hpWidth > 4) drawRect(6, 6, Math.min(hpWidth, 10), 1, '#ffffff');

    // HP heart icon
    drawPixel(62, 6, PAL.red); drawPixel(64, 6, PAL.red);
    drawPixel(61, 7, PAL.red); drawPixel(62, 7, PAL.red);
    drawPixel(63, 7, PAL.red); drawPixel(64, 7, PAL.red);
    drawPixel(65, 7, PAL.red); drawPixel(62, 8, PAL.red);
    drawPixel(63, 8, PAL.red); drawPixel(64, 8, PAL.red);
    drawPixel(63, 9, PAL.red);

    // Lives
    for (let i = 0; i < player.lives; i++) {
        const lx = 6 + i * 10;
        drawPixel(lx + 1, 17, PAL.red); drawPixel(lx + 3, 17, PAL.red);
        drawPixel(lx, 18, PAL.red); drawPixel(lx + 1, 18, '#ff4444');
        drawPixel(lx + 2, 18, PAL.red); drawPixel(lx + 3, 18, '#ff4444');
        drawPixel(lx + 4, 18, PAL.red); drawPixel(lx + 1, 19, PAL.red);
        drawPixel(lx + 2, 19, PAL.red); drawPixel(lx + 3, 19, PAL.red);
        drawPixel(lx + 2, 20, PAL.red);
    }

    // Score
    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W - 99, 7, '#333300', 1);
    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W - 100, 6, PAL.yellow, 1);

    // Level indicator - show current area name
    const areaName = player.x < 900 ? 'MYRANPARKEN' :
                     player.x < 2200 ? 'GATORNA' :
                     player.x < 3200 ? 'DISCGOLF' :
                     player.x < 3800 ? 'ISHALLEN' : 'RÖDA VIKEN';
    drawText('NIVÅ 3 - ' + areaName, GAME_W / 2 - 62, 3, PAL.green, 1);

    // Progress
    const progress = Math.floor((player.x / LEVEL3_WIDTH) * 100);
    drawText('VÄNNÄS ' + progress + '%', GAME_W - 90, 16, PAL.grey, 1);
    drawRect(GAME_W - 90, 24, 80, 3, '#222222');
    drawRect(GAME_W - 90, 24, Math.floor(80 * progress / 100), 3, '#44aa44');
    drawPixel(GAME_W - 90 + Math.floor(80 * progress / 100), 24, PAL.white);

    // Gun / Ammo indicator
    if (player.hasGun) {
        drawRect(4, 28, 14, 7, '#000000');
        drawRect(5, 29, 9, 3, '#555555');
        drawRect(13, 29, 3, 2, '#444444');
        drawRect(6, 32, 3, 3, '#3a2a1a');
        const ammoColor = player.ammo > 6 ? PAL.yellow : (player.ammo > 0 ? PAL.orange : PAL.red);
        drawText(String(player.ammo).padStart(3, '0'), 20, 29, ammoColor, 1);
        for (let ai = 0; ai < Math.min(player.ammo, 12); ai++) {
            drawPixel(20 + ai * 3, 36, '#ccaa44');
            drawPixel(20 + ai * 3, 37, '#aa8833');
        }
    }

    // Bat indicator
    if (player.hasBat) {
        const batY = player.hasGun ? 40 : 28;
        drawRect(4, batY, 4, 10, '#b8860b');
        drawRect(3, batY, 6, 4, '#d4a020');
        drawText(String(player.batDurability), 12, batY + 2, player.batDurability > 5 ? '#d4a020' : PAL.red, 1);
    }

    // Boss warning approaching Röda Viken stage
    if (player.x > LEVEL3_WIDTH - 1600 && !game.level3BossActive && !game.level3BossDefeated) {
        if (game.frameCount % 30 < 15) {
            drawText('! RÖDA VIKEN SCENEN !', GAME_W / 2 - 64, 30, PAL.red, 1);
        }
    }

    // Boss intro text
    if (game.level3BossIntroTimer > 0) {
        if (game.level3BossIntroTimer > 80) {
            drawText('VARNING!', GAME_W / 2 - 26, 50, PAL.red, 1);
        }
        if (game.level3BossIntroTimer > 40 && game.level3BossIntroTimer < 100) {
            drawText('RIFF RAFF RUFF', GAME_W / 2 - 44, 62, PAL.white, 1);
            drawText('SPELAR LIVE!', GAME_W / 2 - 36, 74, PAL.yellow, 1);
            drawText('SLÅSS MOT BANDET!', GAME_W / 2 - 54, 86, PAL.orange, 1);
        }
        if (game.level3BossIntroTimer < 50 && game.frameCount % 6 < 4) {
            drawText('ROCK!', GAME_W / 2 - 16, 60, PAL.red, 2);
        }
    }

    // Band member boss HP bars
    if (game.level3BossActive && !game.level3BossDefeated) {
        const bosses = enemies.filter(e => e.type === 'boss' && e.active);
        const barW = 80;
        const startX = GAME_W / 2 - (bosses.length * (barW + 10)) / 2;
        bosses.forEach((boss, idx) => {
            const barX = startX + idx * (barW + 10);
            drawRect(barX - 1, 220, barW + 2, 16, PAL.black);
            drawRect(barX, 221, barW, 14, '#330000');
            const bossHpW = Math.floor(barW * boss.hp / boss.maxHp);
            const colors = { guitar: PAL.red, bass: '#ff4444', drums: PAL.orange };
            drawRect(barX, 221, bossHpW, 14, colors[boss.role] || PAL.red);
            if (boss.hp > 0) {
                const shimmer = (game.frameCount * 2) % barW;
                drawRect(barX + shimmer, 222, 3, 2, PAL.white);
            }
            const names = { guitar: 'GITARR', bass: 'BAS', drums: 'TRUMMOR' };
            const name = names[boss.role] || 'BOSS';
            drawText(name, barX + barW / 2 - name.length * 3, 225, PAL.white, 1);
        });
    }
}

// ============================================================
//  PARTICLES
// ============================================================
function spawnParticles(x, y, color, count, speed) {
    for (let i = 0; i < count; i++) {
        game.particles.push({
            x, y,
            vx: (Math.random() - 0.5) * speed,
            vy: -Math.random() * speed,
            life: 20 + Math.random() * 20,
            color,
        });
    }
}

function updateParticles() {
    for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) game.particles.splice(i, 1);
    }
}

function drawParticles() {
    game.particles.forEach(p => {
        drawPixel(Math.floor(p.x - game.camX), Math.floor(p.y), p.color);
    });
}

// ============================================================
//  COLLISION
// ============================================================
function boxOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// ============================================================
//  UPDATE
// ============================================================
function updatePlayer() {
    const moving = keys['ArrowLeft'] || keys['ArrowRight'] || keys['KeyA'] || keys['KeyD'];

    // Horizontal movement
    if (keys['ArrowLeft'] || keys['KeyA']) {
        player.vx = -player.speed;
        player.facing = -1;
    } else if (keys['ArrowRight'] || keys['KeyD']) {
        player.vx = player.speed;
        player.facing = 1;
    } else {
        player.vx *= 0.7;
    }

    // Jump
    if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && player.grounded) {
        player.vy = -4;
        player.grounded = false;
        playTone(300, 0.06);
    }

    // Attack
    if ((keys['KeyZ'] || keys['KeyJ'] || keys['Enter']) && player.attackCooldown <= 0) {
        player.attacking = true;
        player.attackTimer = 12;
        player.attackCooldown = 18;
        sfxPunch();
    }

    // Shoot gun (X, K, or Mouse click)
    if ((keys['KeyX'] || keys['KeyK'] || keys['Mouse0']) && player.hasGun && player.ammo > 0 && player.shootCooldown <= 0) {
        player.ammo--;
        player.shootCooldown = 15;
        sfxGunShot();
        game.bullets.push({
            x: player.x + (player.facing > 0 ? 18 : -6),
            y: player.y + 14,
            vx: player.facing * 5,
            w: 4,
            h: 2,
            active: true,
            life: 80,
        });
        // Muzzle flash particles
        const mfx = player.x + (player.facing > 0 ? 20 : -4);
        spawnParticles(mfx, player.y + 14, PAL.yellow, 3, 2);
        spawnParticles(mfx, player.y + 14, PAL.orange, 2, 1.5);
    }
    if (player.shootCooldown > 0) player.shootCooldown--;

    // Physics
    player.vy += 0.25; // Gravity
    player.x += player.vx;
    player.y += player.vy;

    // Ground collision
    const groundY = GAME_H - 50;
    if (player.y >= groundY) {
        player.y = groundY;
        player.vy = 0;
        player.grounded = true;
    }

    // Keep in bounds
    const currentLevelWidth = game.level === 3 ? LEVEL3_WIDTH : (game.level === 2 ? LEVEL2_WIDTH : LEVEL_WIDTH);
    if (player.x < 5) player.x = 5;
    if (player.x > currentLevelWidth - 20) player.x = currentLevelWidth - 20;

    // Walking animation
    if (Math.abs(player.vx) > 0.3) {
        player.walkTimer++;
        if (player.walkTimer > 8) {
            player.walkTimer = 0;
            player.frame++;
        }
    } else {
        player.frame = 0;
    }

    // Attack timer
    if (player.attackTimer > 0) player.attackTimer--;
    else player.attacking = false;
    if (player.attackCooldown > 0) player.attackCooldown--;
    if (player.invincible > 0) player.invincible--;

    // Combo timer
    if (player.comboTimer > 0) player.comboTimer--;
    else player.combo = 0;

    // Camera follow
    let targetCamX = player.x - GAME_W / 3;
    game.camX += (targetCamX - game.camX) * 0.1;
    if (game.camX < 0) game.camX = 0;
    if (game.camX > currentLevelWidth - GAME_W) game.camX = currentLevelWidth - GAME_W;

    if (game.level === 1) {
        // Boss arena lock: when player reaches the boss zone, lock camera
        const BOSS_ZONE_START = LEVEL_WIDTH - GAME_W - 20;
        if (player.x > BOSS_ZONE_START && !game.bossDefeated) {
            game.camX = LEVEL_WIDTH - GAME_W;
            if (player.x > LEVEL_WIDTH - 30) player.x = LEVEL_WIDTH - 30;
            if (player.x < BOSS_ZONE_START + 10) player.x = BOSS_ZONE_START + 10;

            if (!game.bossActive) {
                game.bossActive = true;
                game.bossIntroTimer = 120;
                playTone(80, 0.4, 'sawtooth', 0.1);
                playTone(60, 0.6, 'square', 0.08);
                playBossMusic();
            }
        }

        // Transition: walk into hotel door after boss is defeated -> go to level 2
        if (game.bossDefeated && !game.enteringHotel) {
            const hotelX = LEVEL_WIDTH - 140;
            const doorLeft = hotelX + 50;
            const doorRight = hotelX + 85;
            if (player.x + player.w > doorLeft && player.x < doorRight) {
                game.enteringHotel = true;
                game.enterHotelTimer = 90;
            }
        }
        if (game.enteringHotel) {
            game.enterHotelTimer--;
            if (game.enterHotelTimer <= 0) {
                game.enteringHotel = false;
                initLevel2();
                playMusic();
            }
        }
    }

    if (game.level === 2) {
        // Level 2 boss zone: FRASSES area (x > 1900)
        const BOSS2_ZONE_START = LEVEL2_WIDTH - GAME_W - 20;
        if (player.x > BOSS2_ZONE_START && !game.level2BossDefeated) {
            game.camX = LEVEL2_WIDTH - GAME_W;
            if (player.x > LEVEL2_WIDTH - 30) player.x = LEVEL2_WIDTH - 30;
            if (player.x < BOSS2_ZONE_START + 10) player.x = BOSS2_ZONE_START + 10;

            if (!game.level2BossActive) {
                game.level2BossActive = true;
                game.level2BossIntroTimer = 120;
                playTone(100, 0.4, 'sawtooth', 0.1);
                playTone(80, 0.5, 'square', 0.08);
                playBossMusic();
            }
        }

        // Victory: boss defeated in level 2 -> transition to level 3
        if (game.level2BossDefeated && !game.enteringLevel3) {
            game.enteringLevel3 = true;
            game.enterLevel3Timer = 90;
        }
        if (game.enteringLevel3) {
            game.enterLevel3Timer--;
            if (game.enterLevel3Timer <= 0) {
                game.enteringLevel3 = false;
                initLevel3();
                playMusic();
            }
        }
    }

    if (game.level === 3) {
        // Level 3 boss zone: Pond stage area (x > ~4400)
        const currentLevelWidth = LEVEL3_WIDTH;
        const BOSS3_ZONE_START = currentLevelWidth - GAME_W - 20;
        if (player.x > BOSS3_ZONE_START && !game.level3BossDefeated) {
            game.camX = currentLevelWidth - GAME_W;
            if (player.x > currentLevelWidth - 30) player.x = currentLevelWidth - 30;
            if (player.x < BOSS3_ZONE_START + 10) player.x = BOSS3_ZONE_START + 10;

            if (!game.level3BossActive) {
                game.level3BossActive = true;
                game.level3BossIntroTimer = 120;
                playTone(120, 0.4, 'sawtooth', 0.1);
                playTone(90, 0.5, 'square', 0.08);
                playTone(150, 0.3, 'triangle', 0.06);
                playBossMusic();
            }
        }

        // Check if all band members defeated
        if (game.level3BossActive) {
            const aliveBosses = enemies.filter(e => e.type === 'boss' && e.active);
            if (aliveBosses.length === 0 && !game.level3BossDefeated) {
                game.level3BossDefeated = true;
                game.state = 'cutscene';
                game.cutscenePhase = 'fadeout';
                game.cutsceneTimer = 120;
                game.highScore = Math.max(game.highScore, game.score);
                stopMusic();
            }
        }
    }

    // Boss intro timer
    if (game.bossIntroTimer > 0) game.bossIntroTimer--;
    if (game.level2BossIntroTimer > 0) game.level2BossIntroTimer--;
    if (game.level3BossIntroTimer > 0) game.level3BossIntroTimer--;

    // Attack hitbox check
    if (player.attacking && player.attackTimer === 10) {
        // Baseball bat gives wider reach and more damage
        const batBonus = player.hasBat ? 1 : 0;
        const attackBox = {
            x: player.facing > 0 ? player.x + 12 : player.x - (14 + batBonus * 10),
            y: player.y + 2 - batBonus * 2,
            w: 14 + batBonus * 10,
            h: 10 + batBonus * 4,
        };

        enemies.forEach(e => {
            if (!e.active) return;
            if (boxOverlap(attackBox, e)) {
                const batDmg = player.hasBat ? 6 : 0;
                const dmg = 8 + player.combo * 2 + batDmg;
                e.hp -= dmg;
                e.flashTimer = 6;
                sfxHit();
                if (player.hasBat) {
                    playTone(180, 0.08, 'square', 0.05); // Bat crack sound
                    player.batDurability--;
                    if (player.batDurability <= 0) {
                        player.hasBat = false;
                        playTone(100, 0.15, 'sawtooth', 0.08);
                    }
                }
                player.combo++;
                player.comboTimer = 60;

                spawnParticles(e.x + e.w / 2, e.y + e.h / 2, PAL.yellow, 5, 3);
                spawnParticles(e.x + e.w / 2, e.y + e.h / 2, PAL.white, 3, 2);

                // Knockback
                if (e.type === 'drunk') {
                    e.x += player.facing * 8;
                }
                if (e.type === 'dog') {
                    e.x += player.facing * 10;
                }
                if (e.type === 'discgolfer') {
                    e.x += player.facing * 6;
                }
                if (e.type === 'skater') {
                    e.x += player.facing * 12;
                }
                if (e.type === 'bmx') {
                    e.x += player.facing * 8;
                }
                if (e.type === 'hockey') {
                    e.x += player.facing * 6;
                }
                if (e.type === 'swan') {
                    e.x += player.facing * 10;
                    e.y -= 5; // Knock upward
                }
                if (e.type === 'boss') {
                    e.x += player.facing * 3;
                    e.stunTimer = 8;
                }

                if (e.hp <= 0) {
                    e.active = false;
                    const scoreVal = e.type === 'boss' ? 1000 : (e.type === 'epa' ? 200 : (e.type === 'discgolfer' ? 150 : (e.type === 'skater' ? 120 : (e.type === 'bmx' ? 150 : (e.type === 'hockey' ? 180 : (e.type === 'swan' ? 100 : (e.type === 'dog' ? 80 : 100)))))));
                    game.score += scoreVal;
                    spawnParticles(e.x + e.w / 2, e.y + e.h / 2, PAL.orange, 12, 4);
                    spawnParticles(e.x + e.w / 2, e.y + e.h / 2, PAL.red, 8, 3);
                    game.shakeTimer = 8;
                    game.shakeIntensity = 3;
                    playTone(80, 0.2, 'sawtooth', 0.08);

                    // Boss defeated!
                    if (e.type === 'boss') {
                        if (game.level === 3) {
                            game.bandMembersDefeated++;
                        } else if (game.level === 2) {
                            game.level2BossDefeated = true;
                        } else {
                            game.bossDefeated = true;
                        }
                        game.shakeTimer = 30;
                        game.shakeIntensity = 5;
                        game.score += 500; // Bonus
                        spawnParticles(e.x + e.w / 2, e.y + e.h / 2, PAL.yellow, 20, 5);
                        spawnParticles(e.x + e.w / 2, e.y + e.h / 2, PAL.pink, 15, 4);
                        for (let d = 0; d < 8; d++) {
                            setTimeout(() => playTone(200 + d * 50, 0.15, 'square', 0.06), d * 80);
                        }
                    }
                }
            }
        });
    }

    // Update bullets
    if (game.bullets) {
        for (let i = game.bullets.length - 1; i >= 0; i--) {
            const b = game.bullets[i];
            b.x += b.vx;
            b.life--;
            if (b.life <= 0 || b.x < game.camX - 20 || b.x > game.camX + GAME_W + 20) {
                game.bullets.splice(i, 1);
                continue;
            }
            // Check bullet-enemy collision
            enemies.forEach(e => {
                if (!e.active || !b.active) return;
                if (boxOverlap(b, e)) {
                    b.active = false;
                    const dmg = 20;
                    e.hp -= dmg;
                    e.flashTimer = 6;
                    sfxHit();
                    spawnParticles(b.x, b.y, PAL.yellow, 4, 3);
                    spawnParticles(b.x, b.y, PAL.orange, 3, 2);
                    game.score += 15;
                    if (e.type === 'drunk') e.x += b.vx > 0 ? 12 : -12;
                    if (e.type === 'dog') e.x += b.vx > 0 ? 14 : -14;
                    if (e.type === 'discgolfer') e.x += b.vx > 0 ? 10 : -10;
                    if (e.type === 'boss') { e.x += b.vx > 0 ? 4 : -4; e.stunTimer = 5; }
                    if (e.hp <= 0) {
                        e.active = false;
                        game.score += e.type === 'epa' ? 100 : (e.type === 'boss' ? 500 : 50);
                        sfxDeath();
                        spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.red, 8, 4);
                        if (e.type === 'boss') {
                            if (game.level === 3) {
                                game.bandMembersDefeated++;
                            } else if (game.level === 2) {
                                game.level2BossDefeated = true;
                            } else {
                                game.bossDefeated = true;
                            }
                            game.shakeTimer = 30;
                            game.shakeIntensity = 5;
                            spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.yellow, 20, 5);
                        }
                    }
                }
            });
            if (!b.active) { game.bullets.splice(i, 1); }
        }
    }

    // Pickup collection
    pickups.forEach(p => {
        if (!p.active) return;
        if (boxOverlap(player, { x: p.x, y: p.y, w: p.w, h: p.h })) {
            p.active = false;
            if (p.type === 'kebab') {
                player.hp = Math.min(player.hp + 25, player.maxHp);
                game.score += 50;
                sfxPickup();
                spawnParticles(p.x, p.y, PAL.green, 6, 2);
                game.flashTimer = 4;
                game.flashColor = PAL.green;
            } else if (p.type === 'gun') {
                player.hasGun = true;
                player.ammo += 8;
                game.score += 100;
                sfxGunPickup();
                spawnParticles(p.x, p.y, PAL.yellow, 8, 3);
                spawnParticles(p.x, p.y, PAL.orange, 4, 2);
                game.flashTimer = 6;
                game.flashColor = PAL.yellow;
                game.gunMessageTimer = 180; // Show shoot instruction for 3 seconds
            } else if (p.type === 'ammo') {
                if (player.hasGun) {
                    player.ammo += 3;
                } else {
                    player.ammo += 3;
                }
                game.score += 25;
                sfxAmmoPickup();
                spawnParticles(p.x, p.y, PAL.orange, 4, 2);
                game.flashTimer = 3;
                game.flashColor = PAL.orange;
            } else if (p.type === 'bat') {
                player.hasBat = true;
                player.batDurability = 20; // 20 hits before it breaks
                game.score += 75;
                sfxPickup();
                spawnParticles(p.x, p.y, '#8B6914', 6, 3);
                spawnParticles(p.x, p.y, PAL.yellow, 4, 2);
                game.flashTimer = 6;
                game.flashColor = '#8B6914';
                game.gunMessageTimer = 120;
            }
        }
    });

}

function updateEnemies() {
    enemies.forEach(e => {
        if (!e.active) return;
        if (e.flashTimer > 0) e.flashTimer--;

        // Only activate when near camera view
        if (e.x > game.camX + GAME_W + 60 || e.x < game.camX - 60) return;

        if (e.type === 'epa') {
            e.x += e.speed;
            e.frame++;
            e.honkTimer--;
            if (e.honkTimer <= 0) {
                sfxEPA();
                e.honkTimer = 90 + Math.random() * 60;
            }

            // Re-spawn on far right when driven off left
            if (e.x < game.camX - 40) {
                e.x = game.camX + GAME_W + 30 + Math.random() * 100;
                e.hp = e.maxHp;
            }

            // Collision with player - check if stomping (landing on top)
            if (boxOverlap(player, e)) {
                const playerBottom = player.y + player.h;
                const epaTop = e.y;
                const isFalling = player.vy > 0;
                const isAbove = playerBottom < epaTop + 8;

                if (isFalling && isAbove) {
                    // STOMP! Player bounces off EPA
                    player.vy = -4.5;
                    player.grounded = false;
                    e.hp -= 15;
                    e.flashTimer = 6;
                    sfxStomp();
                    game.score += 25;
                    spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 6, 3);
                    spawnParticles(e.x + e.w/2, e.y, PAL.white, 3, 2);
                    if (e.hp <= 0) {
                        e.active = false;
                        game.score += 200;
                        spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 12, 4);
                        game.shakeTimer = 6;
                        game.shakeIntensity = 2;
                        sfxDeath();
                    }
                } else if (player.invincible <= 0) {
                    // Side collision - take damage
                    hurtPlayer(15);
                }
            }
        }

        if (e.type === 'drunk') {
            e.wobbleTimer++;
            e.frame = Math.floor(e.wobbleTimer / 10);

            // Wobble movement
            e.x += Math.sin(e.wobbleTimer * 0.05) * e.speed;

            // Puking logic
            e.pukeTimer--;
            if (e.pukeTimer <= 0 && !e.puking) {
                e.puking = true;
                e.pukeTimer = 40;
                sfxPuke();
                // Spawn puke projectile
                const pukeDir = player.x > e.x ? 1 : -1;
                game.pukeProjectiles.push(new PukeProjectile(e.x + 6, e.y + 3, pukeDir));
            }
            if (e.puking) {
                e.pukeTimer--;
                if (e.pukeTimer <= 0) {
                    e.puking = false;
                    e.pukeTimer = 80 + Math.random() * 80;
                }
            }

            // Contact damage - check if stomping
            if (boxOverlap(player, e)) {
                const playerBottom = player.y + player.h;
                const drunkTop = e.y;
                const isFalling = player.vy > 0;
                const isAbove = playerBottom < drunkTop + 6;

                if (isFalling && isAbove) {
                    // STOMP! Bounce off drunk
                    player.vy = -4;
                    player.grounded = false;
                    e.hp -= 12;
                    e.flashTimer = 6;
                    sfxStomp();
                    game.score += 20;
                    spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 5, 2);
                    e.x += player.facing * 6;
                    if (e.hp <= 0) {
                        e.active = false;
                        game.score += 100;
                        spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 8, 3);
                        game.shakeTimer = 5;
                        game.shakeIntensity = 2;
                        sfxDeath();
                    }
                } else if (player.invincible <= 0) {
                    hurtPlayer(8);
                }
            }
        }
    });

    // Update dogs (level 3)
    enemies.forEach(e => {
        if (e.type !== 'dog' || !e.active) return;
        if (e.x > game.camX + GAME_W + 60 || e.x < game.camX - 60) return;
        e.frame++;

        if (e.pooping) {
            e.poopDuration--;
            if (e.poopDuration <= 0) {
                e.pooping = false;
                e.poopTimer = 100 + Math.random() * 80;
                // Spawn dog poop hazard
                game.dogPoops.push({
                    x: e.x + 5,
                    y: GAME_H - 34,
                    w: 6, h: 4,
                    life: 600, // Lasts 10 seconds
                });
            }
        } else {
            // Wander around
            e.x += e.dir * e.speed;
            if (Math.random() < 0.01) e.dir *= -1;
            // Keep in reasonable area
            const homeX = e.x;
            if (homeX < game.camX - 30) e.dir = 1;
            if (homeX > game.camX + GAME_W + 30) e.dir = -1;

            e.poopTimer--;
            if (e.poopTimer <= 0) {
                e.pooping = true;
                e.poopDuration = 40;
            }
        }

        // Dog bite contact damage
        if (boxOverlap(player, e)) {
            const playerBottom = player.y + player.h;
            const dogTop = e.y;
            const isFalling = player.vy > 0;
            const isAbove = playerBottom < dogTop + 5;
            if (isFalling && isAbove) {
                player.vy = -3.5;
                player.grounded = false;
                e.hp -= 10;
                e.flashTimer = 6;
                sfxStomp();
                game.score += 15;
                spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 4, 2);
                if (e.hp <= 0) {
                    e.active = false;
                    game.score += 80;
                    spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 6, 3);
                    sfxDeath();
                }
            } else if (player.invincible <= 0) {
                hurtPlayer(6);
            }
        }
    });

    // Update dog poop hazards
    for (let i = game.dogPoops.length - 1; i >= 0; i--) {
        const poop = game.dogPoops[i];
        poop.life--;
        if (poop.life <= 0) { game.dogPoops.splice(i, 1); continue; }
        if (player.invincible <= 0 && boxOverlap(player, poop)) {
            hurtPlayer(10);
            spawnParticles(poop.x, poop.y, '#6a4a2a', 4, 2);
            game.dogPoops.splice(i, 1);
        }
    }

    // Update disc golfers (level 3)
    enemies.forEach(e => {
        if (e.type !== 'discgolfer' || !e.active) return;
        if (e.x > game.camX + GAME_W + 60 || e.x < game.camX - 60) return;
        e.frame++;

        // Face player
        e.dir = player.x < e.x ? -1 : 1;

        e.throwTimer--;
        if (e.throwTimer <= 0 && !e.throwing) {
            e.throwing = true;
            e.throwAnim = 20;
            // Launch disc projectile
            const throwDir = player.x < e.x ? -1 : 1;
            game.discProjectiles.push({
                x: e.x + (throwDir > 0 ? 20 : -10),
                y: e.y + 6,
                vx: throwDir * 3.5,
                vy: -0.3 + Math.random() * 0.4,
                w: 10, h: 4,
                life: 120,
                spin: 0,
            });
            playTone(500, 0.05, 'sine', 0.04);
        }
        if (e.throwing) {
            e.throwAnim--;
            if (e.throwAnim <= 0) {
                e.throwing = false;
                e.throwTimer = 60 + Math.random() * 50;
            }
        }

        // Slow movement
        e.x += Math.sin(e.frame * 0.02) * 0.2;

        // Contact damage
        if (boxOverlap(player, e)) {
            const playerBottom = player.y + player.h;
            const eTop = e.y;
            const isFalling = player.vy > 0;
            const isAbove = playerBottom < eTop + 6;
            if (isFalling && isAbove) {
                player.vy = -4;
                player.grounded = false;
                e.hp -= 12;
                e.flashTimer = 6;
                sfxStomp();
                game.score += 20;
                spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 5, 2);
                if (e.hp <= 0) {
                    e.active = false;
                    game.score += 150;
                    spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 8, 3);
                    sfxDeath();
                }
            } else if (player.invincible <= 0) {
                hurtPlayer(8);
            }
        }
    });

    // Update disc projectiles
    for (let i = game.discProjectiles.length - 1; i >= 0; i--) {
        const d = game.discProjectiles[i];
        d.x += d.vx;
        d.y += d.vy;
        d.spin += 0.3;
        d.life--;
        if (d.life <= 0 || d.x < game.camX - 20 || d.x > game.camX + GAME_W + 20) {
            game.discProjectiles.splice(i, 1);
            continue;
        }
        if (player.invincible <= 0 && boxOverlap(player, d)) {
            hurtPlayer(12);
            spawnParticles(d.x, d.y, PAL.red, 4, 2);
            game.discProjectiles.splice(i, 1);
        }
    }

    // Update skaters (level 3 streets)
    enemies.forEach(e => {
        if (e.type !== 'skater' || !e.active) return;
        if (e.x > game.camX + GAME_W + 80 || e.x < game.camX - 80) return;
        e.frame++;

        // Fast skating back and forth
        e.x += e.dir * e.speed;
        // Reverse when far from home
        if (Math.abs(e.x - e.homeX) > 200) e.dir *= -1;
        if (e.x < 900) { e.dir = 1; } // Keep in streets area
        if (e.x > 2200) { e.dir = -1; }

        // Trick timer (occasional jump)
        e.trickTimer--;
        if (e.trickTimer <= 0) {
            e.trickTimer = 80 + Math.random() * 60;
        }

        // Contact damage - fast collision
        if (boxOverlap(player, e)) {
            const playerBottom = player.y + player.h;
            const eTop = e.y;
            const isFalling = player.vy > 0;
            const isAbove = playerBottom < eTop + 6;
            if (isFalling && isAbove) {
                player.vy = -4;
                player.grounded = false;
                e.hp -= 12;
                e.flashTimer = 6;
                sfxStomp();
                game.score += 20;
                spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 5, 2);
                if (e.hp <= 0) {
                    e.active = false;
                    game.score += 120;
                    spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 8, 3);
                    sfxDeath();
                }
            } else if (player.invincible <= 0) {
                hurtPlayer(10);
            }
        }
    });

    // Update BMX riders (level 3 streets)
    enemies.forEach(e => {
        if (e.type !== 'bmx' || !e.active) return;
        if (e.x > game.camX + GAME_W + 80 || e.x < game.camX - 80) return;
        e.frame++;

        // Charge at player periodically
        e.chargeTimer--;
        if (e.chargeTimer <= 0 && !e.charging) {
            e.charging = true;
            e.dir = player.x > e.x ? 1 : -1;
            e.chargeTimer = 80;
        }
        if (e.charging) {
            e.x += e.dir * e.speed * 1.5;
            e.chargeTimer--;
            if (e.chargeTimer <= 0) {
                e.charging = false;
                e.chargeTimer = 60 + Math.random() * 50;
            }
        } else {
            // Cruise around
            e.x += e.dir * e.speed * 0.4;
            if (Math.abs(e.x - e.homeX) > 250) e.dir *= -1;
        }
        if (e.x < 900) { e.dir = 1; }
        if (e.x > 2200) { e.dir = -1; }

        // Contact damage
        if (boxOverlap(player, e)) {
            const playerBottom = player.y + player.h;
            const eTop = e.y;
            const isFalling = player.vy > 0;
            const isAbove = playerBottom < eTop + 6;
            if (isFalling && isAbove) {
                player.vy = -4.5;
                player.grounded = false;
                e.hp -= 12;
                e.flashTimer = 6;
                sfxStomp();
                game.score += 25;
                spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 6, 3);
                if (e.hp <= 0) {
                    e.active = false;
                    game.score += 150;
                    spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 10, 4);
                    sfxDeath();
                }
            } else if (player.invincible <= 0) {
                hurtPlayer(e.charging ? 15 : 10);
            }
        }
    });

    // Update hockey players (level 3 ishall)
    enemies.forEach(e => {
        if (e.type !== 'hockey' || !e.active) return;
        if (e.x > game.camX + GAME_W + 60 || e.x < game.camX - 60) return;
        e.frame++;

        // Face player
        e.dir = player.x < e.x ? -1 : 1;

        // Patrol slowly
        e.x += Math.sin(e.frame * 0.03) * 0.4;

        // Shoot pucks
        e.shootTimer--;
        if (e.shootTimer <= 0 && !e.shooting) {
            e.shooting = true;
            e.shootAnim = 18;
            const shootDir = player.x < e.x ? -1 : 1;
            game.puckProjectiles.push({
                x: e.x + (shootDir > 0 ? 18 : -8),
                y: e.y + 8,
                vx: shootDir * 4,
                vy: -0.5 + Math.random() * 0.3,
                w: 6, h: 4,
                life: 100,
            });
            playTone(300, 0.06, 'square', 0.04); // Slap shot sound
        }
        if (e.shooting) {
            e.shootAnim--;
            if (e.shootAnim <= 0) {
                e.shooting = false;
                e.shootTimer = 55 + Math.random() * 40;
            }
        }

        // Contact damage
        if (boxOverlap(player, e)) {
            const playerBottom = player.y + player.h;
            const eTop = e.y;
            const isFalling = player.vy > 0;
            const isAbove = playerBottom < eTop + 6;
            if (isFalling && isAbove) {
                player.vy = -4;
                player.grounded = false;
                e.hp -= 12;
                e.flashTimer = 6;
                sfxStomp();
                game.score += 25;
                spawnParticles(e.x + e.w/2, e.y, PAL.yellow, 5, 2);
                if (e.hp <= 0) {
                    e.active = false;
                    game.score += 180;
                    spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.orange, 8, 3);
                    sfxDeath();
                }
            } else if (player.invincible <= 0) {
                hurtPlayer(10);
            }
        }
    });

    // Update puck projectiles
    for (let i = game.puckProjectiles.length - 1; i >= 0; i--) {
        const p = game.puckProjectiles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0 || p.x < game.camX - 20 || p.x > game.camX + GAME_W + 20) {
            game.puckProjectiles.splice(i, 1);
            continue;
        }
        if (player.invincible <= 0 && boxOverlap(player, p)) {
            hurtPlayer(14);
            spawnParticles(p.x, p.y, '#222222', 4, 2);
            game.puckProjectiles.splice(i, 1);
        }
    }

    // Update swans (level 3 pond area)
    enemies.forEach(e => {
        if (e.type !== 'swan' || !e.active) return;
        if (e.x > game.camX + GAME_W + 80 || e.x < game.camX - 80) return;
        e.frame++;

        e.swoopTimer--;
        if (e.swoopTimer <= 0 && !e.swooping) {
            // Start swoop attack toward player
            e.swooping = true;
            e.swoopTarget = 0;
            e.dir = player.x > e.x ? 1 : -1;
        }

        if (e.swooping) {
            // Dive toward player then rise back up
            e.swoopTarget++;
            e.x += e.dir * e.speed * 1.5;
            if (e.swoopTarget < 30) {
                e.y += 1.5; // Dive down
            } else {
                e.y -= 1.5; // Rise up
            }
            if (e.swoopTarget >= 60) {
                e.swooping = false;
                e.swoopTimer = 40 + Math.random() * 30;
                e.y = e.baseY;
            }
        } else {
            // Fly around lazily
            e.x += Math.sin(e.frame * 0.03) * 0.8;
            e.y = e.baseY + Math.sin(e.frame * 0.05) * 5;
        }
        // Keep in pond area
        if (e.x < 3800) e.x = 3800;
        if (e.x > 5100) e.x = 5100;

        // Contact damage
        if (boxOverlap(player, e)) {
            const playerBottom = player.y + player.h;
            const eTop = e.y;
            const isFalling = player.vy > 0;
            const isAbove = playerBottom < eTop + 4;
            if (isFalling && isAbove) {
                player.vy = -3.5;
                player.grounded = false;
                e.hp -= 10;
                e.flashTimer = 6;
                sfxStomp();
                game.score += 15;
                spawnParticles(e.x + e.w/2, e.y, PAL.white, 5, 2);
                if (e.hp <= 0) {
                    e.active = false;
                    game.score += 100;
                    spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.white, 8, 3);
                    sfxDeath();
                }
            } else if (player.invincible <= 0) {
                hurtPlayer(8);
            }
        }
    });

    // Update boss
    enemies.forEach(e => {
        if (e.type !== 'boss' || !e.active) return;
        const bossIsActive = game.level === 3 ? game.level3BossActive : (game.level === 2 ? game.level2BossActive : game.bossActive);
        const bossIntro = game.level === 3 ? game.level3BossIntroTimer : (game.level === 2 ? game.level2BossIntroTimer : game.bossIntroTimer);
        if (!bossIsActive) return;
        if (bossIntro > 0) return; // Wait for intro

        e.frame++;
        if (e.stunTimer > 0) { e.stunTimer--; return; }

        e.phaseTimer--;

        // Phase logic
        if (e.phaseTimer <= 0) {
            e.phase = (e.phase + 1) % 4;
            switch (e.phase) {
                case 0: e.phaseTimer = 60; break;  // Idle/walk
                case 1: e.phaseTimer = 50; e.chargeDir = player.x < e.x ? -1 : 1; e.chargeSpeed = 3; playTone(70, 0.3, 'sawtooth', 0.1); break; // Charge
                case 2: e.phaseTimer = 45; e.groundPoundY = e.y; playTone(50, 0.2, 'square', 0.08); break; // Ground pound
                case 3: e.phaseTimer = 80; break;  // Summon minions
            }
        }

        switch (e.phase) {
            case 0: // Walk towards player
                const dir = player.x < e.x ? -1 : 1;
                e.x += dir * e.speed;
                if (player.invincible <= 0 && boxOverlap(player, e)) hurtPlayer(10);
                break;

            case 1: // Charge attack
                e.x += e.chargeDir * e.chargeSpeed;
                // Keep in boss arena
                const bossLevelW = game.level === 3 ? LEVEL3_WIDTH : (game.level === 2 ? LEVEL2_WIDTH : LEVEL_WIDTH);
                const zoneL = bossLevelW - GAME_W;
                const zoneR = bossLevelW - 30;
                if (e.x < zoneL) { e.x = zoneL; e.chargeDir = 1; }
                if (e.x + e.w > zoneR) { e.x = zoneR - e.w; e.chargeDir = -1; }
                if (player.invincible <= 0 && boxOverlap(player, e)) hurtPlayer(20);
                // Charge particles
                if (e.frame % 3 === 0) spawnParticles(e.x + (e.chargeDir < 0 ? e.w : 0), e.y + e.h / 2, PAL.red, 2, 2);
                break;

            case 2: // Ground pound
                if (e.phaseTimer > 30) {
                    // Jump up
                    e.y = e.groundPoundY - (30 - (e.phaseTimer - 30)) * 1.5;
                } else if (e.phaseTimer === 30) {
                    // Slam down
                    e.y = GAME_H - 62;
                    game.shakeTimer = 12;
                    game.shakeIntensity = 4;
                    playTone(40, 0.3, 'sawtooth', 0.12);
                    spawnParticles(e.x + e.w / 2, e.y + e.h, PAL.grey, 10, 3);
                    // Shockwave damage in wide area
                    if (player.invincible <= 0 && Math.abs(player.x - e.x) < 60 && player.grounded) {
                        hurtPlayer(15);
                    }
                } else {
                    e.y = GAME_H - 62; // Stay grounded after slam
                }
                break;

            case 3: // Summon drunk minions
                if (e.phaseTimer === 70) {
                    playTone(200, 0.1); playTone(250, 0.1);
                    for (let m = 0; m < 2; m++) {
                        enemies.push({
                            type: 'drunk',
                            x: e.x + (m === 0 ? -40 : 50),
                            y: GAME_H - 44,
                            w: 12, h: 16,
                            hp: 10, maxHp: 10,
                            speed: 0.5 + Math.random() * 0.3,
                            dir: m === 0 ? 1 : -1,
                            frame: 0, active: true,
                            puking: false,
                            pukeTimer: 30 + Math.random() * 40,
                            wobbleTimer: 0, flashTimer: 0,
                        });
                    }
                }
                // Walk slowly
                const d2 = player.x < e.x ? -1 : 1;
                e.x += d2 * e.speed * 0.4;
                if (player.invincible <= 0 && boxOverlap(player, e)) hurtPlayer(10);
                break;
        }
    });

    // Update puke projectiles
    for (let i = game.pukeProjectiles.length - 1; i >= 0; i--) {
        const p = game.pukeProjectiles[i];
        p.update();
        if (p.life <= 0) {
            game.pukeProjectiles.splice(i, 1);
            continue;
        }
        // Check collision with player
        if (player.invincible <= 0 && boxOverlap(player, p.getHitbox(0))) {
            hurtPlayer(5);
            game.pukeProjectiles.splice(i, 1);
        }
    }
}

function hurtPlayer(dmg) {
    player.hp -= dmg;
    player.invincible = 45;
    sfxHurt();
    game.shakeTimer = 5;
    game.shakeIntensity = 2;
    game.flashTimer = 3;
    game.flashColor = PAL.red;
    spawnParticles(player.x + 8, player.y + 8, PAL.red, 6, 2);

    if (player.hp <= 0) {
        player.lives--;
        if (player.lives <= 0) {
            game.state = 'gameover';
            game.highScore = Math.max(game.highScore, game.score);
            sfxDeath();
        } else {
            player.hp = player.maxHp;
            player.invincible = 90;
        }
    }
}

// ============================================================
//  DRAW
// ============================================================
function drawSky() {
    // Rich gradient sky - late evening festival atmosphere
    const colors = ['#0a0a1e', '#111133', '#1a1a4e', '#0f3460', '#1a4070', '#2a4a7a', '#4a3a6e', '#6a3a6a'];
    const bandH = Math.ceil(80 / colors.length);
    for (let i = 0; i < colors.length; i++) {
        drawRect(0, i * bandH, GAME_W, bandH + 1, colors[i]);
    }

    // Horizon glow (sunset/festival lights reflection)
    for (let g = 0; g < 10; g++) {
        const alpha = (10 - g) * 0.02;
        bctx.fillStyle = `rgba(120,60,100,${alpha})`;
        bctx.fillRect(0, 80 - g, GAME_W, 2);
    }

    // Many twinkling stars with variety
    const starPositions = [
        [23,8],[67,15],[112,5],[156,22],[201,12],[289,3],[312,18],[45,25],
        [178,7],[234,20],[56,30],[90,14],[145,9],[267,26],[334,4],[78,17],
        [123,11],[189,23],[256,6],[301,19],[380,8],[150,28],[210,2],[340,16],
        [50,35],[280,10],[170,32],[360,21],[30,13],[250,35],[100,38],[320,28],
    ];
    starPositions.forEach(([sx2, sy2], i) => {
        const parallax = game.camX * (0.02 + i * 0.001);
        const sxFinal = ((sx2 * 3 - parallax) % GAME_W + GAME_W) % GAME_W;
        const twinkle = Math.sin(game.frameCount * 0.03 + i * 1.7);
        if (twinkle > -0.3) {
            const brightness = twinkle > 0.5 ? PAL.white : (twinkle > 0 ? PAL.cream : '#8888aa');
            drawPixel(Math.floor(sxFinal), sy2, brightness);
            // Brighter stars get a cross pattern
            if (twinkle > 0.7 && i % 4 === 0) {
                drawPixel(Math.floor(sxFinal) + 1, sy2, '#6666aa');
                drawPixel(Math.floor(sxFinal) - 1, sy2, '#6666aa');
                drawPixel(Math.floor(sxFinal), sy2 + 1, '#6666aa');
                drawPixel(Math.floor(sxFinal), sy2 - 1, '#6666aa');
            }
        }
    });

    // Moon with proper crescent and glow
    const moonX = 320 - game.camX * 0.02;
    // Moon glow
    bctx.fillStyle = 'rgba(200,200,255,0.06)';
    bctx.beginPath();
    bctx.arc(moonX, 25, 20, 0, Math.PI * 2);
    bctx.fill();
    bctx.fillStyle = 'rgba(200,200,255,0.04)';
    bctx.beginPath();
    bctx.arc(moonX, 25, 26, 0, Math.PI * 2);
    bctx.fill();
    // Moon body
    bctx.fillStyle = '#eeeeff';
    bctx.beginPath();
    bctx.arc(moonX, 25, 12, 0, Math.PI * 2);
    bctx.fill();
    // Moon surface details
    bctx.fillStyle = '#ccccdd';
    bctx.beginPath();
    bctx.arc(moonX - 3, 22, 3, 0, Math.PI * 2);
    bctx.fill();
    bctx.beginPath();
    bctx.arc(moonX + 4, 27, 2, 0, Math.PI * 2);
    bctx.fill();
    // Crescent shadow
    bctx.fillStyle = '#0a0a1e';
    bctx.beginPath();
    bctx.arc(moonX + 5, 23, 10, 0, Math.PI * 2);
    bctx.fill();
}

function drawBackground() {
    const bgShift = game.camX * 0.15;
    const bgShift2 = game.camX * 0.25;

    // ---- Distant building silhouettes (furthest back, with variety) ----
    const bgShift3 = game.camX * 0.3;
    for (let i = 0; i < 20; i++) {
        const bx = i * 60 - (bgShift3 % 60);
        const bh = 15 + Math.sin(i * 2.5) * 10 + (i % 3) * 5;
        const shade = i % 2 === 0 ? '#1a1a3e' : '#1d1d42';
        drawRect(bx, GAME_H - 115 - bh, 50, bh, shade);
        // Roof variation
        if (i % 3 === 0) {
            // Peaked roof
            for (let pk = 0; pk < 6; pk++) {
                drawRect(bx + 20 - pk, GAME_H - 115 - bh - pk, pk * 2 + 10, 1, shade);
            }
        }
        // Lit windows
        for (let wy = 0; wy < bh - 6; wy += 8) {
            for (let wx = 4; wx < 46; wx += 10) {
                if (Math.sin(i * 7 + wx + wy) > 0.3) {
                    const lit = (game.frameCount + i * 23 + wx) % 400 < 360;
                    if (lit) {
                        drawPixel(bx + wx, GAME_H - 115 - bh + 4 + wy, '#ffcc44');
                        drawPixel(bx + wx + 1, GAME_H - 115 - bh + 4 + wy, '#ffaa22');
                    }
                }
            }
        }
        // Chimney on some
        if (i % 4 === 1) {
            drawRect(bx + 10, GAME_H - 115 - bh - 4, 4, 6, '#151530');
        }
    }

    // ---- LAMPPOSTS (between background and foreground) ----
    const lampShift = game.camX * 0.25;
    for (let lp = 80; lp < LEVEL_WIDTH; lp += 200) {
        const lpx = Math.floor(lp - lampShift) % (GAME_W + 100) - 50;
        if (lpx > -20 && lpx < GAME_W + 20) {
            // Pole
            drawRect(lpx + 1, GAME_H - 100, 2, 66, '#444444');
            drawRect(lpx + 2, GAME_H - 100, 1, 66, '#555555');
            // Arm
            drawRect(lpx - 2, GAME_H - 100, 8, 2, '#444444');
            // Lamp housing
            drawRect(lpx - 1, GAME_H - 103, 6, 4, '#333333');
            // Light cone
            const lampFlicker = Math.sin(game.frameCount * 0.05 + lp) > -0.2;
            if (lampFlicker) {
                bctx.fillStyle = 'rgba(255,220,140,0.12)';
                bctx.beginPath();
                bctx.moveTo(lpx, GAME_H - 99);
                bctx.lineTo(lpx - 8, GAME_H - 70);
                bctx.lineTo(lpx + 12, GAME_H - 70);
                bctx.fill();
                drawRect(lpx, GAME_H - 102, 4, 2, '#ffdd88');
            }
            // Base
            drawRect(lpx - 1, GAME_H - 35, 6, 3, '#444444');
        }
    }

    // ---- ROLLERCOASTER (far background, slow parallax) ----
    drawRollercoaster(bgShift);

    // ---- FERRIS WHEEL / TIVOLI ----
    drawFerrisWheel(bgShift);

    // ---- TIVOLI TENTS & LIGHTS ----
    drawTivoliTents(bgShift);

    // ---- MARKET STALLS (closer parallax, drawn last = in front) ----
    drawMarketStalls(bgShift2);
}

// ---- ROLLERCOASTER ----
function drawRollercoaster(bgShift) {
    const rcColor = '#3a2255';
    const rcLight = '#6644aa';
    const railY = GAME_H - 160;
    // Draw track rails with hills
    for (let px = 0; px < GAME_W; px++) {
        const worldX = px + bgShift;
        // Track profile: two big hills + dips
        const h1 = Math.sin(worldX * 0.008) * 30;
        const h2 = Math.sin(worldX * 0.015 + 1) * 15;
        const h3 = Math.cos(worldX * 0.004) * 10;
        const trackY = railY + h1 + h2 + h3;
        // Track rail
        drawPixel(px, Math.floor(trackY), rcColor);
        drawPixel(px, Math.floor(trackY) + 1, rcColor);
        // Support beams every 12 pixels
        if (Math.floor(worldX) % 12 === 0) {
            const beamTop = Math.floor(trackY) + 2;
            const beamBot = GAME_H - 90;
            for (let by = beamTop; by < beamBot; by += 2) {
                drawPixel(px, by, '#2a1545');
            }
        }
    }
    // Rollercoaster cart moving along the track
    const cartWorldX = (game.frameCount * 1.5) % 2000;
    const cartScreenX = cartWorldX - bgShift;
    if (cartScreenX > -20 && cartScreenX < GAME_W + 20) {
        const ch1 = Math.sin(cartWorldX * 0.008) * 30;
        const ch2 = Math.sin(cartWorldX * 0.015 + 1) * 15;
        const ch3 = Math.cos(cartWorldX * 0.004) * 10;
        const cartY = railY + ch1 + ch2 + ch3 - 5;
        drawRect(Math.floor(cartScreenX), Math.floor(cartY), 8, 5, PAL.red);
        drawRect(Math.floor(cartScreenX) + 1, Math.floor(cartY) - 2, 2, 2, PAL.peach);
        drawRect(Math.floor(cartScreenX) + 4, Math.floor(cartY) - 2, 2, 2, PAL.peach);
    }
    // Track label
    const labelX = 180 - bgShift % 400;
    if (labelX > -40 && labelX < GAME_W + 40) {
        drawText('TIVOLI', Math.floor(labelX), railY - 40, '#5533aa', 1);
    }
}

// ---- FERRIS WHEEL ----
function drawFerrisWheel(bgShift) {
    const cx = 300 - bgShift % 600;
    const cy = GAME_H - 155;
    const radius = 28;
    if (cx < -50 || cx > GAME_W + 50) return;

    // Support structure
    drawRect(Math.floor(cx) - 1, Math.floor(cy), 3, 60, '#443366');
    drawRect(Math.floor(cx) - 12, Math.floor(cy) + 58, 25, 3, '#443366');
    // Draw support legs
    for (let ly = 0; ly < 58; ly++) {
        const legSpread = Math.floor(ly * 0.2);
        drawPixel(Math.floor(cx) - legSpread, Math.floor(cy) + ly, '#332255');
        drawPixel(Math.floor(cx) + legSpread, Math.floor(cy) + ly, '#332255');
    }

    // Wheel spokes and gondolas
    const numGondolas = 8;
    const rotSpeed = game.frameCount * 0.008;
    for (let i = 0; i < numGondolas; i++) {
        const angle = (i / numGondolas) * Math.PI * 2 + rotSpeed;
        const gx = cx + Math.cos(angle) * radius;
        const gy = cy + Math.sin(angle) * radius;
        // Spoke
        const steps = 10;
        for (let s = 0; s < steps; s++) {
            const t = s / steps;
            drawPixel(Math.floor(cx + (gx - cx) * t), Math.floor(cy + (gy - cy) * t), '#554488');
        }
        // Gondola
        const gondolaColors = [PAL.red, PAL.yellow, PAL.blue, PAL.green, PAL.pink, PAL.orange, PAL.red, PAL.yellow];
        drawRect(Math.floor(gx) - 2, Math.floor(gy), 5, 4, gondolaColors[i]);
        // Tiny person in gondola
        drawPixel(Math.floor(gx), Math.floor(gy) - 1, PAL.peach);
    }
    // Rim circle
    for (let a = 0; a < 60; a++) {
        const angle = (a / 60) * Math.PI * 2;
        drawPixel(Math.floor(cx + Math.cos(angle) * radius), Math.floor(cy + Math.sin(angle) * radius), '#665599');
    }
    // Center hub
    drawRect(Math.floor(cx) - 1, Math.floor(cy) - 1, 3, 3, PAL.yellow);
}

// ---- TIVOLI TENTS ----
function drawTivoliTents(bgShift) {
    const tentPositions = [80, 400, 720];
    const tentColors = [['#cc2244', PAL.white], ['#2244cc', PAL.yellow], ['#22cc44', PAL.white]];
    tentPositions.forEach((tx, idx) => {
        const sx = Math.floor(tx - bgShift % 800);
        if (sx < -40 || sx > GAME_W + 40) return;
        const tc = tentColors[idx % tentColors.length];
        const tentW = 36;
        const tentH = 20;
        const tentY = GAME_H - 110;
        // Tent body with stripes
        for (let row = 0; row < tentH; row++) {
            const rowW = Math.floor(tentW * (row / tentH));
            const lx = sx + (tentW / 2) - rowW / 2;
            for (let col = 0; col < rowW; col++) {
                const stripe = (col + row) % 8 < 4 ? tc[0] : tc[1];
                drawPixel(Math.floor(lx + col), tentY + row, stripe);
            }
        }
        // Tent pole / flag
        drawRect(sx + tentW / 2 - 1, tentY - 6, 2, 8, PAL.darkgrey);
        drawRect(sx + tentW / 2 + 1, tentY - 6, 4, 3, PAL.yellow);
        // Bunting lights
        for (let li = 0; li < 5; li++) {
            const lcolor = [PAL.red, PAL.yellow, PAL.green, PAL.blue, PAL.pink][li];
            const blinkOn = (game.frameCount + li * 7) % 20 < 14;
            if (blinkOn) {
                drawPixel(sx + 6 + li * 6, tentY - 1, lcolor);
            }
        }
    });
}

// ---- MARKET STALLS ----
function drawMarketStalls(bgShift) {
    const stalls = [
        { x: 60,  type: 'tshirt', label: 'T-SHIRTS' },
        { x: 180, type: 'caps',   label: 'KEPSAR' },
        { x: 300, type: 'langos', label: 'LANGOS' },
        { x: 420, type: 'tshirt', label: 'HOODIES' },
        { x: 540, type: 'langos', label: 'KORV' },
        { x: 660, type: 'caps',   label: 'HATTAR' },
        { x: 780, type: 'langos', label: 'LANGOS' },
    ];

    stalls.forEach(st => {
        const sx = Math.floor(st.x - bgShift % 850);
        if (sx < -50 || sx > GAME_W + 50) return;
        const stallY = GAME_H - 96;
        const stallW = 40;
        const stallH = 16;

        // Stall canopy
        const canopyColor = st.type === 'langos' ? '#cc6600' : (st.type === 'caps' ? '#2266cc' : '#cc2266');
        const stripeColor = st.type === 'langos' ? '#ffaa44' : (st.type === 'caps' ? '#44aaff' : '#ff88aa');
        for (let row = 0; row < 6; row++) {
            for (let col = 0; col < stallW + 4; col++) {
                const stripe = col % 6 < 3 ? canopyColor : stripeColor;
                drawPixel(sx - 2 + col, stallY + row, stripe);
            }
        }

        // Stall table/counter
        drawRect(sx, stallY + 6, stallW, stallH, '#8B6914');
        drawRect(sx + 1, stallY + 7, stallW - 2, stallH - 2, '#A07828');

        // Table legs
        drawRect(sx + 2, stallY + stallH + 6, 2, 6, '#6B4914');
        drawRect(sx + stallW - 4, stallY + stallH + 6, 2, 6, '#6B4914');

        // Items on display
        if (st.type === 'tshirt') {
            // T-shirts hanging
            const tColors = [PAL.red, PAL.blue, PAL.green, PAL.yellow, PAL.pink];
            for (let t = 0; t < 4; t++) {
                const tx = sx + 4 + t * 9;
                drawRect(tx, stallY + 7, 6, 7, tColors[t % tColors.length]);
                drawRect(tx - 1, stallY + 8, 1, 3, tColors[t % tColors.length]);
                drawRect(tx + 6, stallY + 8, 1, 3, tColors[t % tColors.length]);
            }
        } else if (st.type === 'caps') {
            // Caps
            const cColors = [PAL.red, PAL.darkblue, PAL.darkgreen, PAL.orange];
            for (let c = 0; c < 4; c++) {
                const cx2 = sx + 4 + c * 9;
                drawRect(cx2, stallY + 9, 7, 3, cColors[c % cColors.length]);
                drawRect(cx2 + 1, stallY + 7, 5, 2, cColors[c % cColors.length]);
                drawRect(cx2 + 5, stallY + 10, 3, 1, cColors[c % cColors.length]); // Brim
            }
        } else if (st.type === 'langos') {
            // Långos / food - golden fried circles
            for (let f = 0; f < 3; f++) {
                const fx = sx + 5 + f * 12;
                const fy = stallY + 9;
                drawRect(fx, fy, 8, 5, '#daa520');
                drawRect(fx + 1, fy + 1, 6, 3, '#f0c040');
                // Toppings
                drawPixel(fx + 2, fy + 1, PAL.white);
                drawPixel(fx + 4, fy + 2, PAL.white);
            }
            // Steam from hot food
            if (game.frameCount % 16 < 10) {
                const steamOff = Math.sin(game.frameCount * 0.1) * 2;
                drawPixel(sx + 10, stallY + 6 + steamOff, PAL.grey);
                drawPixel(sx + 22, stallY + 5 + steamOff, PAL.grey);
            }
        }

        // Seller behind stall (little person)
        const sellerX = sx + stallW / 2 - 3;
        const sellerY = stallY - 8;
        // Head
        drawRect(sellerX + 1, sellerY, 4, 4, PAL.peach);
        drawRect(sellerX, sellerY - 1, 6, 2, PAL.brown); // Hair
        drawPixel(sellerX + 2, sellerY + 1, PAL.black); // Eye
        drawPixel(sellerX + 4, sellerY + 1, PAL.black); // Eye
        // Body
        const sellerShirt = st.type === 'langos' ? '#cc6600' : (st.type === 'caps' ? '#2266cc' : '#cc2266');
        drawRect(sellerX, sellerY + 4, 6, 5, sellerShirt);

        // Sign above
        drawText(st.label, sx + 2, stallY - 4, PAL.yellow, 1);
    });
}

function drawTivoliLightsBg() {
    // Far background twinkling carnival lights
    const lightShift = game.camX * 0.05;
    for (let i = 0; i < 40; i++) {
        const lx = (i * 29 + 10 - lightShift) % GAME_W;
        const ly = 75 + Math.sin(i * 1.7) * 8;
        const colors = [PAL.red, PAL.yellow, PAL.green, PAL.blue, PAL.pink, PAL.orange];
        const blinkPhase = (game.frameCount + i * 5) % 24;
        if (blinkPhase < 16) {
            drawPixel(lx, ly, colors[i % colors.length]);
            if (blinkPhase < 8) {
                drawPixel(lx + 1, ly, colors[i % colors.length]);
            }
        }
    }
    // "VANNASDAGARNA" text banner in the far sky
    const bannerX = 130 - game.camX * 0.04;
    if (game.frameCount % 60 < 50) {
        drawText('VANNASDAGARNA', Math.floor(bannerX) % GAME_W, 82, '#443366', 1);
    }
}

function drawStreet() {
    // Sidewalk with paving pattern
    drawRect(0, GAME_H - 36, GAME_W, 6, '#999988');
    drawRect(0, GAME_H - 34, GAME_W, 4, PAL.pavement);
    // Paving stones
    for (let i = 0; i < GAME_W; i += 12) {
        const px = i - (game.camX * 0.9) % 12;
        drawRect(Math.floor(px), GAME_H - 35, 1, 5, '#888877');
    }

    // Curb (raised edge detail)
    drawRect(0, GAME_H - 31, GAME_W, 1, '#aaa999');
    drawRect(0, GAME_H - 30, GAME_W, 1, '#666655');

    // Main road with subtle texture
    drawRect(0, GAME_H - 29, GAME_W, 29, PAL.asphalt);
    // Road texture grain
    for (let i = 0; i < GAME_W; i += 7) {
        const rx = i - (game.camX * 0.95) % 7;
        const ry = GAME_H - 29 + (i * 3) % 28;
        drawPixel(Math.floor(rx), ry, '#333340');
    }

    // Center road marking (dashed yellow line)
    for (let i = 0; i < GAME_W; i += 20) {
        const rx = i - (game.camX * 0.9) % 20;
        drawRect(Math.floor(rx), GAME_H - 16, 10, 2, PAL.yellow);
        drawRect(Math.floor(rx) + 1, GAME_H - 15, 8, 1, '#ddaa00');
    }

    // Manhole covers at intervals
    const manholeInterval = 300;
    for (let m = 0; m < LEVEL_WIDTH; m += manholeInterval) {
        const mx = Math.floor(m - game.camX * 0.9);
        if (mx > -10 && mx < GAME_W + 10) {
            drawRect(mx, GAME_H - 22, 8, 8, '#2a2a2a');
            drawRect(mx + 1, GAME_H - 21, 6, 6, '#333333');
            drawRect(mx + 2, GAME_H - 20, 4, 1, '#444444');
            drawRect(mx + 2, GAME_H - 17, 4, 1, '#444444');
        }
    }

    // Occasional puddle (reflective)
    const puddleShift = game.camX * 0.9;
    for (let pu = 150; pu < LEVEL_WIDTH; pu += 500) {
        const px2 = Math.floor(pu - puddleShift);
        if (px2 > -15 && px2 < GAME_W + 15) {
            bctx.fillStyle = 'rgba(100,120,150,0.3)';
            bctx.fillRect(px2, GAME_H - 12, 12, 3);
            // Reflection shimmer
            if (game.frameCount % 20 < 10) {
                drawPixel(px2 + 3, GAME_H - 12, '#8899bb');
                drawPixel(px2 + 7, GAME_H - 11, '#8899bb');
            }
        }
    }

    // Road edge line (white)
    drawRect(0, GAME_H - 5, GAME_W, 1, '#555555');
}

function drawBuilding_HOTELL(x, y, camX) {
    const sx = Math.floor(x - camX);
    const by = GAME_H - 110;

    // Grand hotel building - taller than others
    drawRect(sx, by, 130, 80, '#8B0000');
    drawRect(sx + 2, by + 2, 126, 76, '#A52A2A');

    // Ornate roof
    drawRect(sx - 4, by - 6, 138, 8, '#600000');
    drawRect(sx - 2, by - 4, 134, 4, '#700000');
    // Roof peak decoration
    drawRect(sx + 55, by - 14, 20, 10, '#700000');
    drawRect(sx + 57, by - 12, 16, 6, '#800000');
    // Flag on top
    drawRect(sx + 64, by - 22, 2, 10, PAL.grey);
    const flagWave = Math.sin(game.frameCount * 0.08) * 2;
    drawRect(sx + 66, by - 22 + flagWave, 8, 5, PAL.blue);
    drawRect(sx + 66, by - 19 + flagWave, 8, 2, PAL.yellow);

    // Main sign
    drawRect(sx + 10, by + 5, 110, 18, '#2a0a0a');
    drawRect(sx + 11, by + 6, 108, 16, '#3a1a1a');
    drawText('HOTELL VÄNNÄS', sx + 16, by + 9, PAL.yellow, 1);
    // Stars
    for (let s = 0; s < 3; s++) {
        drawPixel(sx + 40 + s * 8, by + 17, PAL.yellow);
        drawPixel(sx + 41 + s * 8, by + 16, PAL.yellow);
        drawPixel(sx + 42 + s * 8, by + 17, PAL.yellow);
    }

    // Windows (3 rows)
    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 5; col++) {
            const wx = sx + 8 + col * 24;
            const wy = by + 26 + row * 15;
            drawRect(wx, wy, 14, 10, '#ffdd88');
            drawRect(wx + 1, wy + 1, 12, 8, '#ffeeaa');
            // Curtains
            drawRect(wx + 1, wy + 1, 3, 8, '#cc4444');
            drawRect(wx + 10, wy + 1, 3, 8, '#cc4444');
            // Window cross
            drawRect(wx + 6, wy + 1, 2, 8, '#8B6914');
            drawRect(wx + 1, wy + 4, 12, 1, '#8B6914');
        }
    }

    // Grand entrance
    drawRect(sx + 45, by + 48, 40, 32, '#1a0a0a');
    drawRect(sx + 47, by + 50, 36, 30, '#2a1515');
    // Door arch
    for (let a = 0; a < 18; a++) {
        const angle = (a / 17) * Math.PI;
        const ax = Math.cos(angle) * 18;
        const ay = -Math.sin(angle) * 8;
        drawPixel(sx + 65 + Math.floor(ax), by + 50 + Math.floor(ay), '#ffcc00');
    }
    // Double doors
    drawRect(sx + 50, by + 55, 14, 25, '#3a2020');
    drawRect(sx + 66, by + 55, 14, 25, '#3a2020');
    drawRect(sx + 52, by + 57, 10, 23, '#4a2a2a');
    drawRect(sx + 68, by + 57, 10, 23, '#4a2a2a');
    // Door handles
    drawRect(sx + 60, by + 66, 2, 5, PAL.yellow);
    drawRect(sx + 68, by + 66, 2, 5, PAL.yellow);

    // Entrance carpet
    drawRect(sx + 48, by + 78, 34, 2, PAL.red);

    // "ENTER" glow when boss is defeated
    if (game.bossDefeated && game.frameCount % 40 < 28) {
        drawText('GÅ IN!', sx + 48, by + 42, PAL.green, 1);
    }

    // Entrance lanterns
    drawRect(sx + 42, by + 48, 3, 8, PAL.darkgrey);
    drawRect(sx + 85, by + 48, 3, 8, PAL.darkgrey);
    const lanternFlicker = game.frameCount % 8 < 6;
    if (lanternFlicker) {
        drawRect(sx + 41, by + 46, 5, 3, PAL.orange);
        drawRect(sx + 84, by + 46, 5, 3, PAL.orange);
    }
}

function drawBuildings() {
    buildings.forEach(b => {
        // Only draw if visible
        const widths = { system: 130, hotell: 140, ica: 180, gojvut: 150, texaco: 150, jarnia: 130 };
        const bw = widths[b.type] || 140;
        if (b.x + bw < game.camX - 10 || b.x > game.camX + GAME_W + 10) return;

        switch(b.type) {
            case 'ica':    drawBuilding_ICA(b.x, 0, game.camX); break;
            case 'gojvut': drawBuilding_GOJVUT(b.x, 0, game.camX); break;
            case 'system': drawBuilding_SYSTEM(b.x, 0, game.camX); break;
            case 'texaco': drawBuilding_TEXACO(b.x, 0, game.camX); break;
            case 'jarnia': drawBuilding_JARNIA(b.x, 0, game.camX); break;
            case 'hotell': drawBuilding_HOTELL(b.x, 0, game.camX); break;
        }
    });
}

function drawPlayer() {
    if (player.invincible > 0 && game.frameCount % 4 < 2) return; // Blink

    const sprite = getPlayerSprite(player.frame, player.attacking);
    const flipX = player.facing < 0;
    const px = Math.floor(player.x - game.camX);
    const py = Math.floor(player.y);

    // Drop shadow
    bctx.fillStyle = 'rgba(0,0,0,0.25)';
    bctx.fillRect(px + 2, py + 30, 14, 3);

    // Draw player sprite at 2x for better visibility
    drawSprite2x(sprite, px, py, flipX);

    // Gun in hand (when player has gun, draw it on the sprite)
    if (player.hasGun && !player.attacking) {
        const gunX = player.facing > 0 ? px + 22 : px - 8;
        const gunY = py + 14;
        // Small pistol in hand
        drawRect(gunX, gunY, 6, 2, '#555555');
        drawRect(gunX + (player.facing > 0 ? 5 : 0), gunY, 2, 2, '#333333');
        drawRect(gunX + 2, gunY + 2, 2, 2, '#3a2a1a');
    }

    // Baseball bat in hand
    if (player.hasBat && !player.attacking) {
        const batX = player.facing > 0 ? px + 20 : px - 10;
        const batY = py + 6;
        // Bat shaft
        drawRect(batX, batY, 2, 14, '#b8860b');
        drawRect(batX + 1, batY, 1, 14, '#d4a020');
        // Bat barrel (thicker top)
        drawRect(batX - 1, batY, 4, 5, '#d4a020');
        drawRect(batX, batY + 1, 2, 3, '#e8c040');
        // Grip tape
        drawRect(batX, batY + 11, 2, 3, '#222222');
    }

    // Bat swing effect
    if (player.hasBat && player.attacking && player.attackTimer > 6) {
        const swooshX = player.facing > 0 ? px + 26 : px - 16;
        const swooshPhase = 12 - player.attackTimer;
        // Bigger swoosh for bat
        bctx.fillStyle = 'rgba(200,160,50,0.5)';
        for (let s = 0; s < 5; s++) {
            const sy2 = py + 4 + s * 4 - swooshPhase;
            const sw = 6 + swooshPhase * 2;
            bctx.fillRect(swooshX + (player.facing > 0 ? swooshPhase : -swooshPhase - sw + 6), sy2, sw, 2);
        }
    }

    // Muzzle flash when shooting
    if (player.hasGun && player.shootCooldown > 12) {
        const mfx = player.facing > 0 ? px + 30 : px - 10;
        const mfy = py + 13;
        drawRect(mfx, mfy, 4, 3, PAL.yellow);
        drawRect(mfx + (player.facing > 0 ? 3 : -2), mfy, 3, 2, PAL.white);
        drawPixel(mfx + (player.facing > 0 ? 5 : -3), mfy + 1, PAL.orange);
    }

    // Attack swoosh effect (fist only, bat has its own effect)
    if (!player.hasBat && player.attacking && player.attackTimer > 6) {
        const swooshX = player.facing > 0 ? px + 28 : px - 12;
        const swooshPhase = 12 - player.attackTimer;
        bctx.fillStyle = 'rgba(255,255,200,0.4)';
        for (let s = 0; s < 3; s++) {
            const sy2 = py + 8 + s * 4 - swooshPhase;
            const sw = 4 + swooshPhase;
            bctx.fillRect(swooshX + (player.facing > 0 ? swooshPhase : -swooshPhase), sy2, sw, 1);
        }
    }

    // Dust particles when running
    if (Math.abs(player.vx) > 1 && player.grounded && game.frameCount % 6 === 0) {
        const dustX = player.facing > 0 ? player.x : player.x + 14;
        spawnParticles(dustX, player.y + 30, '#aa9977', 2, 1);
    }

    // Combo indicator with style
    if (player.combo > 1 && player.comboTimer > 0) {
        const comboY = py - 12 - Math.sin(player.comboTimer * 0.1) * 2;
        drawRect(px - 1, Math.floor(comboY) - 1, 22, 8, '#00000088');
        drawText(player.combo + 'x', px, Math.floor(comboY), player.combo > 4 ? PAL.red : PAL.yellow, 1);
    }
}

function drawEnemies() {
    enemies.forEach(e => {
        if (!e.active) return;
        if (e.x + e.w < game.camX - 20 || e.x > game.camX + GAME_W + 20) return;

        const sx = Math.floor(e.x - game.camX);
        const sy = Math.floor(e.y);

        if (e.flashTimer > 0 && game.frameCount % 2 === 0) return; // Flash on hit

        if (e.type === 'epa') {
            drawSprite(getEPASprite(e.frame), sx, sy);

            // Exhaust smoke (from rear/right side)
            if (game.frameCount % 3 === 0) {
                spawnParticles(e.x + 28, e.y + 8, '#666666', 2, 1.5);
                spawnParticles(e.x + 29, e.y + 7, '#888888', 1, 1);
            }

            // Headlight glow at front (left side) - brighter with light cone
            if (game.frameCount % 3 !== 0) {
                bctx.fillStyle = 'rgba(255, 255, 100, 0.1)';
                bctx.beginPath();
                bctx.arc(sx + 1, sy + 10, 10, 0, Math.PI * 2);
                bctx.fill();
                // Light cone ahead (pointing left)
                bctx.fillStyle = 'rgba(255, 240, 120, 0.04)';
                bctx.beginPath();
                bctx.moveTo(sx + 1, sy + 8);
                bctx.lineTo(sx - 20, sy + 4);
                bctx.lineTo(sx - 20, sy + 18);
                bctx.fill();
            }

            // Rear light glow (right side)
            bctx.fillStyle = 'rgba(255, 0, 0, 0.06)';
            bctx.fillRect(sx + 28, sy + 8, 4, 6);

            // Ground shadow
            bctx.fillStyle = 'rgba(0,0,0,0.2)';
            bctx.fillRect(sx + 3, sy + 19, 26, 2);

            // HP bar with outline
            if (e.hp < e.maxHp) {
                drawRect(sx + 4, sy - 6, 24, 4, PAL.black);
                drawRect(sx + 5, sy - 5, 22, 2, '#330000');
                drawRect(sx + 5, sy - 5, Math.floor(22 * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        if (e.type === 'drunk') {
            const sprite = getDrunkSprite(e.frame, e.puking);
            const flipX = player.x < e.x;
            drawSprite(sprite, sx, sy, flipX);

            // Drunk stars above head - more elaborate
            const t = game.frameCount * 0.1;
            const starR = 6;
            for (let s = 0; s < 3; s++) {
                const angle = t + s * (Math.PI * 2 / 3);
                const stx = sx + 5 + Math.cos(angle) * starR;
                const sty = sy - 5 + Math.sin(angle) * 2;
                const starCol = s === 0 ? PAL.yellow : (s === 1 ? '#ffcc00' : '#ffaa00');
                drawPixel(Math.floor(stx), Math.floor(sty), starCol);
            }

            // Blush on cheeks (drunk effect)
            drawPixel(sx + 2, sy + 5, '#ff8888');
            drawPixel(sx + 7, sy + 5, '#ff8888');

            // Stink lines (wobbling)
            if (!e.puking && game.frameCount % 20 < 14) {
                const stinkWave = Math.sin(game.frameCount * 0.15);
                drawPixel(sx + 1 + Math.floor(stinkWave), sy - 2, '#88aa66');
                drawPixel(sx + 8 - Math.floor(stinkWave), sy - 3, '#88aa66');
            }

            // HP bar
            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 8, e.w, 3, PAL.black);
                drawRect(sx, sy - 7, e.w, 2, '#330000');
                drawRect(sx, sy - 7, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // DOG RENDERING
        if (e.type === 'dog') {
            const dogSprite = getDogSprite(e.frame, e.pooping);
            const flipDog = player.x < e.x;
            drawSprite(dogSprite, sx, sy, flipDog);

            // Tail wag particles when happy
            if (!e.pooping && game.frameCount % 12 === 0) {
                const tailX = flipDog ? sx + 1 : sx + e.w - 1;
                drawPixel(tailX, sy, '#996633');
            }

            // Pooping animation - stink lines
            if (e.pooping) {
                const stinkWave = Math.sin(game.frameCount * 0.2);
                drawPixel(sx + 5 + Math.floor(stinkWave), sy - 2, '#88aa44');
                drawPixel(sx + 7 - Math.floor(stinkWave), sy - 3, '#88aa44');
                // Little brown drops
                if (game.frameCount % 6 < 3) {
                    drawPixel(sx + 5, sy + 5, '#553311');
                    drawPixel(sx + 6, sy + 6, '#442200');
                }
            }

            // Bark indicator
            if (!e.pooping && game.frameCount % 40 < 5) {
                drawText('VOFF!', sx - 2, sy - 8, PAL.white, 1);
            }

            // Ground shadow
            bctx.fillStyle = 'rgba(0,0,0,0.15)';
            bctx.fillRect(sx + 1, sy + 6, e.w - 2, 1);

            // HP bar
            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 10, e.w, 3, PAL.black);
                drawRect(sx, sy - 9, e.w, 2, '#330000');
                drawRect(sx, sy - 9, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // DISC GOLFER RENDERING
        if (e.type === 'discgolfer') {
            const golferSprite = getDiscGolferSprite(e.frame, e.throwing);
            const flipGolfer = player.x < e.x;
            drawSprite2x(golferSprite, sx, sy, flipGolfer);

            // Throwing wind-up effect
            if (e.throwing) {
                // Speed lines from arm
                const armSide = flipGolfer ? sx - 4 : sx + e.w + 4;
                for (let sl = 0; sl < 4; sl++) {
                    const lineX = flipGolfer ? armSide + sl * 3 : armSide - sl * 3;
                    drawRect(lineX, sy + 6 + sl * 2, 2, 1, '#aaddff');
                }
            }

            // Disc golf text when idle
            if (!e.throwing && game.frameCount % 80 < 10) {
                drawText('KAST!', sx - 2, sy - 12, PAL.yellow, 1);
            }

            // Ground shadow
            bctx.fillStyle = 'rgba(0,0,0,0.2)';
            bctx.fillRect(sx + 2, sy + e.h, e.w - 4, 3);

            // HP bar
            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 14, e.w, 3, PAL.black);
                drawRect(sx, sy - 13, e.w, 2, '#330000');
                drawRect(sx, sy - 13, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // SKATER RENDERING
        if (e.type === 'skater') {
            const skaterSprite = getSkaterSprite(e.frame);
            const flipSkater = e.dir < 0;
            drawSprite2x(skaterSprite, sx, sy, flipSkater);

            // Speed lines when moving fast
            if (Math.abs(e.speed) > 1.5) {
                const trailDir = e.dir > 0 ? -1 : 1;
                for (let sl = 0; sl < 3; sl++) {
                    drawRect(sx + trailDir * (sl * 5 + 5) + (e.dir > 0 ? 0 : e.w), sy + 8 + sl * 3, 3, 1, 'rgba(200,200,200,0.3)');
                }
            }

            // Taunt text
            if (game.frameCount % 90 < 8) {
                drawText('SKATE!', sx - 2, sy - 12, '#44aaff', 1);
            }

            // Ground shadow
            bctx.fillStyle = 'rgba(0,0,0,0.2)';
            bctx.fillRect(sx + 2, sy + e.h, e.w - 4, 2);

            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 14, e.w, 3, PAL.black);
                drawRect(sx, sy - 13, e.w, 2, '#330000');
                drawRect(sx, sy - 13, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // BMX RENDERING
        if (e.type === 'bmx') {
            const bmxSprite = getBMXSprite(e.frame);
            const flipBMX = e.dir < 0;
            drawSprite2x(bmxSprite, sx, sy, flipBMX);

            // Charging effect
            if (e.charging) {
                const trailDir = e.dir > 0 ? -1 : 1;
                for (let sl = 0; sl < 4; sl++) {
                    const alpha = 0.4 - sl * 0.08;
                    bctx.fillStyle = `rgba(255,200,50,${alpha})`;
                    bctx.fillRect(sx + trailDir * (sl * 6 + 4) + (e.dir > 0 ? 0 : e.w), sy + 10 + sl * 2, 4, 2);
                }
                if (game.frameCount % 3 < 2) {
                    drawText('WHEE!', sx + 2, sy - 14, PAL.red, 1);
                }
            }

            // Ground shadow
            bctx.fillStyle = 'rgba(0,0,0,0.2)';
            bctx.fillRect(sx + 2, sy + e.h, e.w - 4, 3);

            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 16, e.w, 3, PAL.black);
                drawRect(sx, sy - 15, e.w, 2, '#330000');
                drawRect(sx, sy - 15, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // HOCKEY PLAYER RENDERING
        if (e.type === 'hockey') {
            const hockeySprite = getHockeyPlayerSprite(e.frame, e.shooting);
            const flipHockey = player.x < e.x;
            drawSprite2x(hockeySprite, sx, sy, flipHockey);

            // Shooting effect
            if (e.shooting && e.shootAnim > 12) {
                const armSide = flipHockey ? sx - 4 : sx + e.w + 2;
                drawRect(armSide, sy + 8, 6, 2, '#886611');
                // Ice spray
                for (let sp = 0; sp < 3; sp++) {
                    drawPixel(sx + e.w/2 + (Math.random()-0.5)*10, sy + e.h + 1, '#aaddff');
                }
            }

            // "PUCK!" text
            if (e.shooting && e.shootAnim > 8) {
                drawText('PUCK!', sx - 2, sy - 14, PAL.yellow, 1);
            }

            // Ground shadow (ice skating)
            bctx.fillStyle = 'rgba(100,180,255,0.15)';
            bctx.fillRect(sx + 1, sy + e.h, e.w - 2, 2);

            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 16, e.w, 3, PAL.black);
                drawRect(sx, sy - 15, e.w, 2, '#330000');
                drawRect(sx, sy - 15, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // SWAN RENDERING
        if (e.type === 'swan') {
            const swanSprite = getSwanSprite(e.frame, e.swooping);
            const flipSwan = e.dir < 0;
            drawSprite2x(swanSprite, sx, sy, flipSwan);

            // Angry red eye flash when swooping
            if (e.swooping && game.frameCount % 4 < 2) {
                bctx.fillStyle = 'rgba(255,50,50,0.3)';
                bctx.fillRect(sx + 2, sy + 2, e.w - 4, e.h - 4);
            }

            // Hiss text
            if (e.swooping && game.frameCount % 6 < 4) {
                drawText('HSSS!', sx - 2, sy - 10, PAL.red, 1);
            } else if (!e.swooping && game.frameCount % 100 < 6) {
                drawText('HONK!', sx - 2, sy - 10, PAL.white, 1);
            }

            // Wing flap particles
            if (game.frameCount % 8 === 0) {
                spawnParticles(e.x + e.w/2, e.y + e.h/2, PAL.white, 2, 1);
            }

            if (e.hp < e.maxHp) {
                drawRect(sx, sy - 12, e.w, 3, PAL.black);
                drawRect(sx, sy - 11, e.w, 2, '#330000');
                drawRect(sx, sy - 11, Math.floor(e.w * e.hp / e.maxHp), 2, PAL.green);
            }
        }

        // BOSS RENDERING
        if (e.type === 'boss') {
            const flipBoss = player.x < e.x;
            const bx = sx;
            const by = sy;
            const _ = null;
            const angry = e.phase === 1 || e.phase === 2;

            // Ground shadow
            bctx.fillStyle = 'rgba(0,0,0,0.3)';
            bctx.fillRect(bx + 1, by + 27, 24, 3);

            if (game.level === 3) {
                // RIFF RAFF RUFF band member sprites
                const bandSprite = getBandMemberSprite(e.role, e.frame, angry);
                drawSprite2x(bandSprite, bx, by - 8, flipBoss);

                // Role-specific weapon animations
                if (e.role === 'guitar') {
                    // Guitar swing attack
                    const swingAnim = e.phase === 1 ? Math.floor(Math.sin(e.frame * 0.4) * 4) : 0;
                    const gx = flipBoss ? bx - 6 : bx + 26;
                    // Guitar neck extended
                    drawRect(gx, by + 2 + swingAnim, 6, 2, '#8B4513');
                    drawRect(gx + (flipBoss ? -3 : 4), by + swingAnim, 3, 2, '#DAA520');
                    // Rock sparks when attacking
                    if (e.phase === 1 && game.frameCount % 4 < 2) {
                        for (let sp = 0; sp < 3; sp++) {
                            const spx = gx + (Math.random() - 0.5) * 10;
                            const spy = by + swingAnim + (Math.random() - 0.5) * 6;
                            drawPixel(Math.floor(spx), Math.floor(spy), PAL.yellow);
                        }
                    }
                } else if (e.role === 'bass') {
                    // Bass guitar bob
                    const bassBob = Math.floor(Math.sin(e.frame * 0.2) * 2);
                    const bassX = flipBoss ? bx - 4 : bx + 26;
                    drawRect(bassX, by + 4 + bassBob, 4, 2, '#8B0000');
                    drawRect(bassX + (flipBoss ? -5 : 3), by + 2 + bassBob, 3, 6, '#660000');
                    // Bass vibration lines when attacking
                    if (e.phase === 1 && game.frameCount % 3 < 2) {
                        drawPixel(bassX + (flipBoss ? -6 : 7), by + 3 + bassBob, '#ff4444');
                        drawPixel(bassX + (flipBoss ? -7 : 8), by + 5 + bassBob, '#ff2222');
                    }
                } else if (e.role === 'drums') {
                    // Drumstick swing
                    const stickSwing = e.phase === 1 ? Math.floor(Math.sin(e.frame * 0.5) * 3) : 0;
                    const dsx = flipBoss ? bx - 3 : bx + 26;
                    drawRect(dsx, by + 2 + stickSwing, 5, 1, '#DAA520');
                    drawRect(dsx + 1, by + 6 - stickSwing, 5, 1, '#DAA520');
                    // Cymbal crash sparks
                    if (e.phase === 2 && e.phaseTimer <= 30 && game.frameCount % 2 === 0) {
                        for (let c = 0; c < 4; c++) {
                            const cx = bx + 12 + (Math.random() - 0.5) * 20;
                            const cy = by - 4 + (Math.random() - 0.5) * 8;
                            drawPixel(Math.floor(cx), Math.floor(cy), PAL.yellow);
                        }
                    }
                }

                // Rock energy aura when angry
                if (angry && game.frameCount % 6 < 3) {
                    const auraColors = ['#ff4400', '#ff6600', '#ffaa00'];
                    for (let a = 0; a < 5; a++) {
                        const ax = bx + 2 + Math.random() * 22;
                        const ay = by - 10 + Math.random() * 4;
                        drawPixel(Math.floor(ax), Math.floor(ay), auraColors[Math.floor(Math.random() * 3)]);
                    }
                }
            } else if (game.level === 2) {
                // KOCKEN (The Chef) sprite
                const kockenSprite = getKockenSprite(e.frame, angry);
                drawSprite2x(kockenSprite, bx, by - 8, flipBoss);

                // Animated frying pan swinging
                const panSwing = e.phase === 1 ? Math.floor(Math.sin(e.frame * 0.3) * 3) : 0;
                const panX = flipBoss ? bx - 8 : bx + 26;
                const panY = by + 4 + panSwing;
                // Frying pan
                drawRect(panX, panY, 8, 2, '#555555'); // Handle
                drawRect(panX + (flipBoss ? -6 : 6), panY - 2, 6, 5, '#444444'); // Pan head
                drawRect(panX + (flipBoss ? -5 : 7), panY - 1, 4, 3, '#333333');
                // Other hand fist
                drawRect(flipBoss ? bx + 26 : bx - 4, by + 6, 4, 4, PAL.peach);
            } else {
                // DÖRRVAKT (Bouncer) sprite
                const Sk = PAL.peach;
                const sh = SH.skinLo;
                const sk = SH.skinHi;
                const Bk = '#111111';
                const bk = '#222222';
                const bl = '#333333';
                const Yl = PAL.yellow;
                const Ey = PAL.black;
                const Sg = '#333366';
                const Sg2= '#222255';
                const Hr = '#111111';
                const Pn = '#1a2a55';
                const Pd = '#0d1533';
                const Bt = '#0a0a0a';
                const Bt2= '#1a1a1a';
                const Ea = PAL.yellow;
                const Ch = '#445566';

                const armPump = e.phase === 1 ? Math.floor(Math.sin(e.frame * 0.3) * 1) : 0;

                const bossSprite = [
                    [_,_,_,Hr,Hr,Hr,Hr,Hr,Hr,Hr,_,_,_],
                    [_,_,Hr,Hr,Hr,Hr,Hr,Hr,Hr,Hr,Hr,_,_],
                    [_,_,Hr,Sk,Sk,Sk,Sk,Sk,Sk,Sk,Hr,_,_],
                    [_,Ea,sh,Ey,Sg,Sg2,Ey,Sg2,Sg,Ey,sh,_,_],
                    [_,_,sh,Sk,Sk,Sk,Sk,Sk,Sk,Sk,sh,_,_],
                    [_,_,_,sh,Sk,angry?'#cc3333':sh,angry?'#cc3333':sh,angry?'#cc3333':sh,Sk,sh,_,_,_],
                    [_,sh,bk,bk,Bk,Bk,Ch,Bk,Bk,bk,bk,sh,_],
                    [sh,bk,Bk,Bk,bl,Bk,Yl,Bk,bl,Bk,Bk,bk,sh],
                    [sh,bk,Bk,Bk,Bk,Bk,Bk,Bk,Bk,Bk,Bk,bk,sh],
                    [_,sh,bk,Bk,Yl,Bk,Bk,Bk,Yl,Bk,bk,sh,_],
                    [_,_,sh,Bk,Bk,Bk,Bk,Bk,Bk,Bk,sh,_,_],
                    [_,_,_,Yl,Yl,'#aa8833',Yl,'#aa8833',Yl,Yl,_,_,_],
                    [_,_,_,Pn,Pn,Pn,Pd,Pn,Pn,Pn,_,_,_],
                    [_,_,_,Pn,Pd,_,Pd,_,Pd,Pn,_,_,_],
                    [_,_,Pd,Pn,Pd,_,_,_,Pd,Pn,Pd,_,_],
                    [_,_,Bt,Bt2,Bt,_,_,_,Bt,Bt2,Bt,_,_],
                    [_,Bt,Bt,Bt,Bt,Bt,_,Bt,Bt,Bt,Bt,Bt,_],
                ];

                drawSprite2x(bossSprite, bx, by - 8, flipBoss);

                // Animated fists
                const fistY = by + 6 + armPump * 2;
                drawRect(flipBoss ? bx + 26 : bx - 4, fistY, 4, 4, PAL.peach);
                drawRect(flipBoss ? bx - 4 : bx + 26, fistY - armPump * 2, 4, 4, PAL.peach);
                drawRect(flipBoss ? bx + 26 : bx - 4, fistY, 4, 1, SH.skinLo);
                drawRect(flipBoss ? bx - 4 : bx + 26, fistY - armPump * 2, 4, 1, SH.skinLo);
            }

            // Phase indicators (much more dramatic)
            if (e.phase === 1) {
                // Charge: speed lines with red glow
                for (let sl = 0; sl < 5; sl++) {
                    const slx = bx + (e.chargeDir < 0 ? 28 + sl * 3 : -sl * 3 - 3);
                    const slLen = 2 + sl;
                    drawRect(slx, by + 2 + sl * 4, slLen, 1, PAL.red);
                    drawRect(slx, by + 3 + sl * 4, slLen - 1, 1, '#ff4444');
                }
                // Angry eye glow
                bctx.fillStyle = 'rgba(255,0,0,0.15)';
                bctx.fillRect(bx + 4, by - 10, 18, 6);
            }
            if (e.phase === 2 && e.phaseTimer <= 30) {
                // Ground pound: expanding shockwave with multiple rings
                const ringR = (30 - e.phaseTimer) * 2;
                drawRect(bx + 12 - ringR, by + 27, ringR * 2, 2, PAL.yellow);
                drawRect(bx + 12 - ringR + 2, by + 26, Math.max(0, ringR * 2 - 4), 1, '#ffff88');
                // Dust particles
                for (let d = 0; d < 4; d++) {
                    const dx = bx + 12 + (d - 2) * ringR * 0.5;
                    drawPixel(Math.floor(dx), by + 25, PAL.grey);
                }
            }
            if (e.phase === 3 && e.phaseTimer > 60) {
                // Summoning: magic circle and sparkles
                const summonRad = 16;
                for (let sp = 0; sp < 8; sp++) {
                    const angle = (sp / 8) * Math.PI * 2 + e.frame * 0.1;
                    const px = bx + 12 + Math.cos(angle) * summonRad;
                    const py = by + 10 + Math.sin(angle) * (summonRad * 0.5);
                    const sparkCol = sp % 2 === 0 ? PAL.pink : '#ff88ff';
                    drawPixel(Math.floor(px), Math.floor(py), sparkCol);
                    drawPixel(Math.floor(px) + 1, Math.floor(py), sparkCol);
                }
                // Pentagram hint on ground
                for (let a = 0; a < 30; a++) {
                    const angle = (a / 30) * Math.PI * 2;
                    drawPixel(bx + 12 + Math.floor(Math.cos(angle) * 14), by + 26 + Math.floor(Math.sin(angle) * 3), '#aa44aa');
                }
            }

            // Boss name plate
            if (game.level === 3) {
                if (game.level3BossIntroTimer > 0 && game.level3BossIntroTimer < 80) {
                    const roleName = e.role === 'guitar' ? 'GITARR' : (e.role === 'bass' ? 'BAS' : 'TRUMMOR');
                    const nameW = roleName.length * 6 + 8;
                    drawRect(bx - 4, by - 16, nameW, 7, '#000000');
                    drawText(roleName, bx - 2, by - 15, PAL.red, 1);
                }
            } else if (game.level === 2) {
                if (game.level2BossIntroTimer > 0 && game.level2BossIntroTimer < 80) {
                    drawRect(bx - 4, by - 16, 42, 7, '#000000');
                    drawText('KOCKEN', bx - 2, by - 15, PAL.red, 1);
                }
            } else {
                if (game.bossIntroTimer > 0 && game.bossIntroTimer < 80) {
                    drawRect(bx - 4, by - 16, 52, 7, '#000000');
                    drawText('DÖRRVAKT', bx - 2, by - 15, PAL.red, 1);
                }
            }
        }
    });
}

function drawPickups() {
    pickups.forEach(p => {
        if (!p.active) return;
        if (p.x < game.camX - 10 || p.x > game.camX + GAME_W + 10) return;

        const sx = Math.floor(p.x - game.camX);
        const bob = Math.sin(game.frameCount * 0.08) * 2;
        const sy = Math.floor(p.y + bob);

        if (p.type === 'kebab') {
            // Glow underneath
            bctx.fillStyle = 'rgba(255,200,50,0.15)';
            bctx.fillRect(sx - 2, sy + 10, 10, 3);

            // Kebab stick
            drawRect(sx + 2, sy, 2, 12, '#8B6914');
            drawRect(sx + 3, sy, 1, 12, '#A07828');
            // Meat chunks
            drawRect(sx, sy + 1, 6, 2, '#8B4513');
            drawRect(sx + 1, sy + 1, 4, 2, '#a05a23');
            drawRect(sx, sy + 3, 6, 2, PAL.peach);
            drawRect(sx + 1, sy + 3, 4, 2, '#ffe0c0');
            drawRect(sx, sy + 5, 6, 2, '#cc5533');
            drawRect(sx + 1, sy + 5, 4, 2, '#dd6644');
            drawRect(sx, sy + 7, 6, 2, PAL.peach);
            drawRect(sx + 1, sy + 7, 4, 2, '#ffe0c0');
            drawPixel(sx + 1, sy + 2, '#663311');
            drawPixel(sx + 3, sy + 4, '#663311');
            drawPixel(sx + 2, sy + 6, '#663311');

            // Sparkle
            const sparkPhase = (game.frameCount + sx) % 30;
            if (sparkPhase < 6) {
                const sparkY2 = sy - 3 + Math.floor(sparkPhase * 0.5);
                drawPixel(sx + 5, sparkY2, PAL.yellow);
                drawPixel(sx + 6, sparkY2 - 1, PAL.white);
            }
            if (Math.abs(player.x - p.x) < 30) {
                drawText('+HP', sx - 2, sy - 6, PAL.green, 1);
            }
        } else if (p.type === 'gun') {
            // Gun pickup - pixel art pistol
            bctx.fillStyle = 'rgba(255,255,100,0.12)';
            bctx.fillRect(sx - 2, sy + 8, 14, 3);

            // Pistol body
            drawRect(sx, sy + 1, 10, 3, '#444444');
            drawRect(sx + 1, sy + 1, 8, 3, '#555555');
            drawRect(sx + 1, sy + 1, 3, 1, '#777777'); // Highlight
            // Barrel
            drawRect(sx + 8, sy + 1, 3, 2, '#333333');
            drawPixel(sx + 10, sy + 1, '#666666'); // Barrel tip
            // Grip
            drawRect(sx + 2, sy + 4, 3, 3, '#3a2a1a');
            drawRect(sx + 3, sy + 4, 1, 3, '#4a3a2a');
            // Trigger
            drawPixel(sx + 5, sy + 4, '#333333');
            // Trigger guard
            drawPixel(sx + 4, sy + 4, '#444444');
            drawPixel(sx + 6, sy + 4, '#444444');

            // Glow pulse
            if (game.frameCount % 20 < 12) {
                drawPixel(sx + 5, sy - 1, PAL.yellow);
                drawPixel(sx + 4, sy - 2, PAL.orange);
                drawPixel(sx + 6, sy - 2, PAL.orange);
            }
            if (Math.abs(player.x - p.x) < 35) {
                drawText('GUN!', sx - 1, sy - 6, PAL.yellow, 1);
            }
        } else if (p.type === 'ammo') {
            // Ammo box pickup
            bctx.fillStyle = 'rgba(255,150,50,0.1)';
            bctx.fillRect(sx - 1, sy + 7, 8, 3);

            // Ammo box
            drawRect(sx, sy, 6, 5, '#886622');
            drawRect(sx + 1, sy + 1, 4, 3, '#aa8833');
            // Bullet tips visible
            drawPixel(sx + 1, sy + 1, '#ccaa44');
            drawPixel(sx + 3, sy + 1, '#ccaa44');
            drawPixel(sx + 2, sy + 2, '#ddbb55');
            drawPixel(sx + 4, sy + 2, '#ddbb55');
            // Box latch
            drawPixel(sx + 3, sy, '#555555');

            if (game.frameCount % 24 < 14) {
                drawPixel(sx + 3, sy - 2, PAL.orange);
            }
            if (Math.abs(player.x - p.x) < 30) {
                drawText('AMMO', sx - 3, sy - 6, PAL.orange, 1);
            }
        } else if (p.type === 'bat') {
            // Baseball bat pickup
            bctx.fillStyle = 'rgba(200,150,50,0.12)';
            bctx.fillRect(sx - 2, sy + 12, 14, 3);

            // Bat handle
            drawRect(sx + 1, sy + 6, 3, 5, '#4a3010');
            drawRect(sx + 2, sy + 6, 1, 5, '#5a4020');
            // Bat grip tape
            drawRect(sx + 1, sy + 8, 3, 1, '#222222');
            // Bat barrel
            drawRect(sx, sy, 5, 6, '#b8860b');
            drawRect(sx + 1, sy + 1, 3, 4, '#d4a020');
            // Bat tip
            drawRect(sx, sy, 5, 1, '#c89830');
            // Highlight
            drawPixel(sx + 2, sy + 2, '#e8c040');

            // Glow pulse
            if (game.frameCount % 20 < 12) {
                drawPixel(sx + 3, sy - 2, '#d4a020');
                drawPixel(sx + 4, sy - 1, PAL.yellow);
            }
            if (Math.abs(player.x - p.x) < 35) {
                drawText('BAT!', sx - 1, sy - 6, '#d4a020', 1);
            }
        }
    });
}

function drawBullets() {
    if (!game.bullets) return;
    game.bullets.forEach(b => {
        if (!b.active) return;
        const bx = Math.floor(b.x - game.camX);
        const by = Math.floor(b.y);
        // Long bullet trail
        bctx.fillStyle = 'rgba(255,200,100,0.25)';
        bctx.fillRect(bx + (b.vx > 0 ? -10 : 6), by, 10, 2);
        bctx.fillStyle = 'rgba(255,220,140,0.15)';
        bctx.fillRect(bx + (b.vx > 0 ? -18 : 12), by, 8, 2);
        // Bullet body (bigger)
        drawRect(bx, by - 1, 6, 3, PAL.yellow);
        drawRect(bx + (b.vx > 0 ? 4 : 0), by - 1, 2, 3, PAL.white);
        // Bright tip
        drawPixel(bx + (b.vx > 0 ? 6 : -1), by, '#ffffff');
        drawPixel(bx + (b.vx > 0 ? 5 : 0), by - 1, '#ffee88');
        drawPixel(bx + (b.vx > 0 ? 5 : 0), by + 1, '#ffee88');
    });
}

function drawHUD() {
    // Health bar - stylish with gradient feel
    drawRect(3, 3, 56, 12, '#000000');
    drawRect(4, 4, 54, 10, '#220000');
    drawRect(5, 5, 52, 8, '#330000');
    // Health bar fill with gradient effect
    const hpWidth = Math.floor(50 * player.hp / player.maxHp);
    const hpColor = player.hp > 60 ? PAL.green : (player.hp > 30 ? PAL.yellow : PAL.red);
    const hpColorDark = player.hp > 60 ? '#006600' : (player.hp > 30 ? '#666600' : '#660000');
    drawRect(6, 6, hpWidth, 3, hpColor);
    drawRect(6, 9, hpWidth, 3, hpColorDark);
    // Health bar shine
    if (hpWidth > 4) {
        drawRect(6, 6, Math.min(hpWidth, 10), 1, '#ffffff');
    }

    // HP icon (heart)
    drawPixel(62, 6, PAL.red);
    drawPixel(64, 6, PAL.red);
    drawPixel(61, 7, PAL.red);
    drawPixel(62, 7, PAL.red);
    drawPixel(63, 7, PAL.red);
    drawPixel(64, 7, PAL.red);
    drawPixel(65, 7, PAL.red);
    drawPixel(62, 8, PAL.red);
    drawPixel(63, 8, PAL.red);
    drawPixel(64, 8, PAL.red);
    drawPixel(63, 9, PAL.red);

    // Lives (heart icons)
    for (let i = 0; i < player.lives; i++) {
        const lx = 6 + i * 10;
        drawPixel(lx + 1, 17, PAL.red);
        drawPixel(lx + 3, 17, PAL.red);
        drawPixel(lx, 18, PAL.red);
        drawPixel(lx + 1, 18, '#ff4444');
        drawPixel(lx + 2, 18, PAL.red);
        drawPixel(lx + 3, 18, '#ff4444');
        drawPixel(lx + 4, 18, PAL.red);
        drawPixel(lx + 1, 19, PAL.red);
        drawPixel(lx + 2, 19, PAL.red);
        drawPixel(lx + 3, 19, PAL.red);
        drawPixel(lx + 2, 20, PAL.red);
    }

    // Score with shadow
    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W - 99, 7, '#333300', 1);
    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W - 100, 6, PAL.yellow, 1);

    // Distance indicator
    const progress = Math.floor((player.x / LEVEL_WIDTH) * 100);
    drawText('VÄNNÄS ' + progress + '%', GAME_W - 90, 16, PAL.grey, 1);

    // Mini progress bar
    drawRect(GAME_W - 90, 24, 80, 3, '#222222');
    drawRect(GAME_W - 90, 24, Math.floor(80 * progress / 100), 3, '#4466aa');
    drawPixel(GAME_W - 90 + Math.floor(80 * progress / 100), 24, PAL.white);

    // Gun / Ammo indicator
    if (player.hasGun) {
        // Gun icon
        drawRect(4, 28, 14, 7, '#000000');
        drawRect(5, 29, 9, 3, '#555555');
        drawRect(13, 29, 3, 2, '#444444');
        drawRect(6, 32, 3, 3, '#3a2a1a');
        // Ammo count
        const ammoColor = player.ammo > 6 ? PAL.yellow : (player.ammo > 0 ? PAL.orange : PAL.red);
        drawText(String(player.ammo).padStart(3, '0'), 20, 29, ammoColor, 1);
        // Bullet icons
        for (let ai = 0; ai < Math.min(player.ammo, 12); ai++) {
            drawPixel(20 + ai * 3, 36, '#ccaa44');
            drawPixel(20 + ai * 3, 37, '#aa8833');
        }
    } else {
        // "Find a gun" hint
        if (game.frameCount % 120 < 80) {
            drawText('X=SKJUT', 4, 30, '#444444', 1);
        }
    }

    // Boss warning when approaching
    if (player.x > LEVEL_WIDTH - 600 && !game.bossActive && !game.bossDefeated) {
        if (game.frameCount % 30 < 15) {
            drawText('! HOTELL VÄNNÄS NÄRA !', GAME_W / 2 - 68, 30, PAL.red, 1);
        }
    }

    // Boss intro text
    if (game.bossIntroTimer > 0) {
        const introAlpha = game.bossIntroTimer > 60 ? 1 : game.bossIntroTimer / 60;
        if (game.bossIntroTimer > 80) {
            drawText('VARNING!', GAME_W / 2 - 26, 50, PAL.red, 1);
        }
        if (game.bossIntroTimer > 40 && game.bossIntroTimer < 100) {
            drawText('DÖRRVAKTEN STOPPAR', GAME_W / 2 - 56, 65, PAL.white, 1);
            drawText('DIG VID DÖRREN!', GAME_W / 2 - 46, 78, PAL.yellow, 1);
        }
        if (game.bossIntroTimer < 50 && game.frameCount % 6 < 4) {
            drawText('SLÅSS!', GAME_W / 2 - 20, 60, PAL.red, 2);
        }
    }

    // Boss HP bar (big bar at top center)
    if (game.bossActive && !game.bossDefeated) {
        const boss = enemies.find(e => e.type === 'boss' && e.active);
        if (boss) {
            const barW = 140;
            const barX = GAME_W / 2 - barW / 2;
            drawRect(barX - 1, 224, barW + 2, 12, PAL.black);
            drawRect(barX, 225, barW, 10, '#330000');
            const bossHpW = Math.floor(barW * boss.hp / boss.maxHp);
            const bossHpColor = boss.hp > boss.maxHp * 0.5 ? PAL.red : (boss.hp > boss.maxHp * 0.25 ? PAL.orange : '#ff0066');
            drawRect(barX, 225, bossHpW, 10, bossHpColor);
            // Animated shimmer on HP bar
            if (boss.hp > 0) {
                const shimmer = (game.frameCount * 2) % barW;
                drawRect(barX + shimmer, 226, 3, 2, PAL.white);
            }
            drawText('DÖRRVAKT', barX + barW / 2 - 24, 227, PAL.white, 1);
        }
    }

    // Boss defeated - enter hotel prompt
    if (game.bossDefeated) {
        if (game.frameCount % 40 < 28) {
            drawText('GÅ IN PÅ HOTELLET!', GAME_W / 2 - 56, 30, PAL.green, 1);
        }
    }
}

function drawHUDLevel2() {
    // Health bar - same style as level 1
    drawRect(3, 3, 56, 12, '#000000');
    drawRect(4, 4, 54, 10, '#220000');
    drawRect(5, 5, 52, 8, '#330000');
    const hpWidth = Math.floor(50 * player.hp / player.maxHp);
    const hpColor = player.hp > 60 ? PAL.green : (player.hp > 30 ? PAL.yellow : PAL.red);
    const hpColorDark = player.hp > 60 ? '#006600' : (player.hp > 30 ? '#666600' : '#660000');
    drawRect(6, 6, hpWidth, 3, hpColor);
    drawRect(6, 9, hpWidth, 3, hpColorDark);
    if (hpWidth > 4) drawRect(6, 6, Math.min(hpWidth, 10), 1, '#ffffff');

    // HP heart icon
    drawPixel(62, 6, PAL.red); drawPixel(64, 6, PAL.red);
    drawPixel(61, 7, PAL.red); drawPixel(62, 7, PAL.red);
    drawPixel(63, 7, PAL.red); drawPixel(64, 7, PAL.red);
    drawPixel(65, 7, PAL.red); drawPixel(62, 8, PAL.red);
    drawPixel(63, 8, PAL.red); drawPixel(64, 8, PAL.red);
    drawPixel(63, 9, PAL.red);

    // Lives
    for (let i = 0; i < player.lives; i++) {
        const lx = 6 + i * 10;
        drawPixel(lx + 1, 17, PAL.red); drawPixel(lx + 3, 17, PAL.red);
        drawPixel(lx, 18, PAL.red); drawPixel(lx + 1, 18, '#ff4444');
        drawPixel(lx + 2, 18, PAL.red); drawPixel(lx + 3, 18, '#ff4444');
        drawPixel(lx + 4, 18, PAL.red); drawPixel(lx + 1, 19, PAL.red);
        drawPixel(lx + 2, 19, PAL.red); drawPixel(lx + 3, 19, PAL.red);
        drawPixel(lx + 2, 20, PAL.red);
    }

    // Score
    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W - 99, 7, '#333300', 1);
    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W - 100, 6, PAL.yellow, 1);

    // Level indicator
    drawText('NIVÅ 2 - HOTELLET', GAME_W / 2 - 54, 3, PAL.orange, 1);

    // Room progress
    const progress = Math.floor((player.x / LEVEL2_WIDTH) * 100);
    drawText('HOTELL ' + progress + '%', GAME_W - 90, 16, PAL.grey, 1);
    drawRect(GAME_W - 90, 24, 80, 3, '#222222');
    drawRect(GAME_W - 90, 24, Math.floor(80 * progress / 100), 3, '#aa4466');
    drawPixel(GAME_W - 90 + Math.floor(80 * progress / 100), 24, PAL.white);

    // Gun / Ammo indicator
    if (player.hasGun) {
        drawRect(4, 28, 14, 7, '#000000');
        drawRect(5, 29, 9, 3, '#555555');
        drawRect(13, 29, 3, 2, '#444444');
        drawRect(6, 32, 3, 3, '#3a2a1a');
        const ammoColor = player.ammo > 6 ? PAL.yellow : (player.ammo > 0 ? PAL.orange : PAL.red);
        drawText(String(player.ammo).padStart(3, '0'), 20, 29, ammoColor, 1);
        for (let ai = 0; ai < Math.min(player.ammo, 12); ai++) {
            drawPixel(20 + ai * 3, 36, '#ccaa44');
            drawPixel(20 + ai * 3, 37, '#aa8833');
        }
    } else {
        if (game.frameCount % 120 < 80) {
            drawText('X=SKJUT', 4, 30, '#444444', 1);
        }
    }

    // Boss warning when approaching FRASSES
    if (player.x > LEVEL2_WIDTH - 600 && !game.level2BossActive && !game.level2BossDefeated) {
        if (game.frameCount % 30 < 15) {
            drawText('! FRASSES NÄRA !', GAME_W / 2 - 50, 30, PAL.red, 1);
        }
    }

    // Boss intro text - KOCKEN
    if (game.level2BossIntroTimer > 0) {
        if (game.level2BossIntroTimer > 80) {
            drawText('VARNING!', GAME_W / 2 - 26, 50, PAL.red, 1);
        }
        if (game.level2BossIntroTimer > 40 && game.level2BossIntroTimer < 100) {
            drawText('KOCKEN ÄR RASANDE!', GAME_W / 2 - 56, 62, PAL.white, 1);
            drawText('POMMES FRITESEN ÄR', GAME_W / 2 - 56, 74, PAL.yellow, 1);
            drawText('BLÖTA OCH SMAKAR SKIT!', GAME_W / 2 - 66, 86, PAL.orange, 1);
        }
        if (game.level2BossIntroTimer < 50 && game.frameCount % 6 < 4) {
            drawText('SLÅSS!', GAME_W / 2 - 20, 60, PAL.red, 2);
        }
    }

    // Boss HP bar - KOCKEN
    if (game.level2BossActive && !game.level2BossDefeated) {
        const boss = enemies.find(e => e.type === 'boss' && e.active);
        if (boss) {
            const barW = 140;
            const barX = GAME_W / 2 - barW / 2;
            drawRect(barX - 1, 224, barW + 2, 12, PAL.black);
            drawRect(barX, 225, barW, 10, '#330000');
            const bossHpW = Math.floor(barW * boss.hp / boss.maxHp);
            const bossHpColor = boss.hp > boss.maxHp * 0.5 ? PAL.red : (boss.hp > boss.maxHp * 0.25 ? PAL.orange : '#ff0066');
            drawRect(barX, 225, bossHpW, 10, bossHpColor);
            if (boss.hp > 0) {
                const shimmer = (game.frameCount * 2) % barW;
                drawRect(barX + shimmer, 226, 3, 2, PAL.white);
            }
            drawText('KOCKEN', barX + barW / 2 - 18, 227, PAL.white, 1);
        }
    }
}

function drawPukeProjectiles() {
    game.pukeProjectiles.forEach(p => {
        p.draw(game.camX);
    });
}

function drawDogPoops() {
    if (!game.dogPoops) return;
    game.dogPoops.forEach(p => {
        if (!p.active) return;
        const sx = Math.floor(p.x - game.camX);
        const sy = Math.floor(p.y);
        if (sx < -10 || sx > GAME_W + 10) return;

        // Stinky brown poop pile - pixel art
        const age = p.life / 600; // 1 = fresh, 0 = old
        const freshCol = '#553311';
        const oldCol = '#332211';
        const poopCol = age > 0.5 ? freshCol : oldCol;

        // Main pile
        drawRect(sx, sy + 2, 6, 3, poopCol);
        drawRect(sx + 1, sy + 1, 4, 1, poopCol);
        drawRect(sx + 2, sy, 2, 1, '#664422');
        // Highlight
        drawPixel(sx + 2, sy + 1, '#775533');
        // Dark spot
        drawPixel(sx + 4, sy + 3, '#221100');

        // Stink lines (animated, float upward)
        if (age > 0.3) {
            const wave = Math.sin(game.frameCount * 0.15 + p.x);
            const wave2 = Math.sin(game.frameCount * 0.12 + p.x + 2);
            drawPixel(sx + 1 + Math.floor(wave), sy - 2, '#88aa44');
            drawPixel(sx + 4 + Math.floor(wave2), sy - 3, '#88aa44');
            if (age > 0.7) {
                drawPixel(sx + 2 - Math.floor(wave), sy - 4, '#77993a');
            }
        }

        // Flies buzzing around fresh poop
        if (age > 0.6) {
            const flyAngle = game.frameCount * 0.2 + p.x;
            const flyX = sx + 3 + Math.cos(flyAngle) * 5;
            const flyY = sy - 2 + Math.sin(flyAngle * 1.3) * 3;
            drawPixel(Math.floor(flyX), Math.floor(flyY), '#000000');
        }
    });
}

function drawDiscProjectiles() {
    if (!game.discProjectiles) return;
    game.discProjectiles.forEach(d => {
        const sx = Math.floor(d.x - game.camX);
        const sy = Math.floor(d.y);
        if (sx < -20 || sx > GAME_W + 20) return;

        // Spinning frisbee/disc - BIG and visible
        const spin = d.spin || game.frameCount * 0.3;
        const flash = game.frameCount % 6 < 3;
        const mainCol = flash ? '#ff3333' : '#ff6644';
        const rimCol = flash ? '#ffaa00' : '#ff8800';

        // Disc body (wide oval, always visible)
        const stretch = Math.abs(Math.cos(spin));
        const discW = Math.max(6, Math.floor(10 * stretch + 4));
        const discH = 5;
        const offsetX = Math.floor((14 - discW) / 2);

        // Glow behind disc
        bctx.fillStyle = 'rgba(255,100,50,0.35)';
        bctx.fillRect(Math.floor(sx + offsetX - 2), Math.floor(sy - 2), discW + 4, discH + 4);

        // Main disc body
        drawRect(sx + offsetX, sy, discW, discH, mainCol);
        // Rim highlight
        drawRect(sx + offsetX, sy, discW, 1, rimCol);
        drawRect(sx + offsetX, sy + discH - 1, discW, 1, '#cc2200');
        // Center stripe
        drawRect(sx + offsetX + 1, sy + 2, Math.max(2, discW - 2), 1, '#ffccaa');

        // Motion trail (thick)
        const trailDir = d.vx > 0 ? -1 : 1;
        for (let t = 1; t <= 4; t++) {
            const alpha = 0.5 - t * 0.1;
            bctx.fillStyle = `rgba(255,100,50,${alpha})`;
            bctx.fillRect(Math.floor(sx + offsetX + trailDir * t * 4), Math.floor(sy + 1), 3, 3);
        }

        // Spin sparkles
        if (game.frameCount % 3 < 2) {
            drawRect(sx + offsetX + Math.floor(discW / 2) - 1, sy - 2, 2, 1, PAL.white);
            drawRect(sx + offsetX + discW - 1, sy + 1, 1, 2, PAL.white);
        }
    });
}

function drawPuckProjectiles() {
    if (!game.puckProjectiles) return;
    game.puckProjectiles.forEach(p => {
        const sx = Math.floor(p.x - game.camX);
        const sy = Math.floor(p.y);
        if (sx < -10 || sx > GAME_W + 10) return;

        // Hockey puck - black disc
        drawRect(sx, sy, 6, 4, '#111111');
        drawRect(sx + 1, sy + 1, 4, 2, '#333333');
        // Highlight
        drawRect(sx + 1, sy, 3, 1, '#555555');

        // Speed trail
        const trailDir = p.vx > 0 ? -1 : 1;
        for (let t = 1; t <= 3; t++) {
            bctx.fillStyle = `rgba(50,50,50,${0.4 - t * 0.1})`;
            bctx.fillRect(Math.floor(sx + trailDir * t * 4), Math.floor(sy + 1), 3, 2);
        }

        // Ice spray sparkle
        if (game.frameCount % 3 < 2) {
            drawPixel(sx + 3, sy - 1, '#aaddff');
        }
    });
}

// ============================================================
//  DECORATIONS (lamp posts, trash cans, benches)
// ============================================================
function drawDecorations() {
    for (let i = 0; i < LEVEL_WIDTH; i += 150) {
        const sx = Math.floor(i - game.camX);
        if (sx < -20 || sx > GAME_W + 20) continue;

        // Lamp post
        drawRect(sx + 5, GAME_H - 70, 2, 40, PAL.darkgrey);
        drawRect(sx + 2, GAME_H - 72, 8, 3, PAL.darkgrey);
        // Light glow
        drawRect(sx + 3, GAME_H - 74, 6, 2, PAL.yellow);
        if (game.frameCount % 60 < 55) {
            bctx.fillStyle = 'rgba(255, 236, 39, 0.08)';
            bctx.beginPath();
            bctx.arc(sx + 6, GAME_H - 60, 18, 0, Math.PI * 2);
            bctx.fill();
        }
    }

    // Trash cans
    for (let i = 80; i < LEVEL_WIDTH; i += 200) {
        const sx = Math.floor(i - game.camX);
        if (sx < -10 || sx > GAME_W + 10) continue;
        drawRect(sx, GAME_H - 38, 6, 8, PAL.darkgrey);
        drawRect(sx - 1, GAME_H - 39, 8, 2, PAL.grey);
    }
}

// ============================================================
//  SCREENS
// ============================================================
function drawTitleScreen() {
    bctx.fillStyle = '#0a0a1a';
    bctx.fillRect(0, 0, GAME_W, GAME_H);

    // Background decoration
    for (let i = 0; i < 30; i++) {
        const sx = (i * 47 + game.frameCount) % GAME_W;
        const sy = (i * 23) % 100;
        drawPixel(sx, sy, PAL.indigo);
    }

    // Animated road at bottom
    drawRect(0, GAME_H - 30, GAME_W, 30, PAL.asphalt);
    for (let i = 0; i < GAME_W; i += 20) {
        drawRect((i - game.frameCount * 2) % GAME_W, GAME_H - 16, 10, 2, PAL.yellow);
    }

    // Title
    const bounce = Math.sin(game.frameCount * 0.05) * 3;
    drawText('W.IKATTI', GAME_W / 2 - 50, 40 + bounce, PAL.yellow, 2);

    drawText('- VÄNNÄSDAGARNA -', GAME_W / 2 - 55, 70, PAL.orange, 1);

    // Subtitle
    drawText('SLÅSS I VÄNNÄS!', GAME_W / 2 - 48, 95, PAL.grey, 1);

    // Instructions
    drawText('PILAR/WASD    GÅ', 100, 130, PAL.white, 1);
    drawText('SPACE/W/UPP HOPPA', 100, 142, PAL.white, 1);
    drawText('Z/J/ENTER    SLÅ', 100, 154, PAL.white, 1);
    drawText('X/K/KLICK  SKJUT', 100, 166, PAL.white, 1);

    // Blink start text
    if (game.frameCount % 50 < 35) {
        drawText('TRYCK ENTER FÖR ATT STARTA', GAME_W / 2 - 80, 192, PAL.green, 1);
    }

    // High score
    if (game.highScore > 0) {
        drawText('HÖGSTA POÄNG ' + game.highScore, GAME_W / 2 - 50, 212, PAL.yellow, 1);
    }

    // Copyright
    drawText('2026 VÄNNÄS STUDIOS', GAME_W / 2 - 60, 228, PAL.darkgrey, 1);

    // Animated character preview
    const pSprite = getPlayerSprite(Math.floor(game.frameCount / 10), false);
    drawSprite(pSprite, 50, GAME_H - 55);
    // EPA driving across title screen
    const epaX = (GAME_W + 40 - (game.frameCount * 2) % (GAME_W + 80));
    drawSprite(getEPASprite(game.frameCount), epaX, GAME_H - 52);
}

function drawGameOverScreen() {
    bctx.fillStyle = '#1a0000';
    bctx.fillRect(0, 0, GAME_W, GAME_H);

    drawText('SPELET SLUT', GAME_W / 2 - 62, 60, PAL.red, 2);

    drawText('POÄNG ' + String(game.score).padStart(6, '0'), GAME_W / 2 - 42, 110, PAL.yellow, 1);
    drawText('BÄST  ' + String(game.highScore).padStart(6, '0'), GAME_W / 2 - 42, 125, PAL.orange, 1);

    drawText('VÄNNÄS GATOR VAR', GAME_W / 2 - 52, 155, PAL.grey, 1);
    drawText('FÖR FARLIGA!', GAME_W / 2 - 40, 167, PAL.grey, 1);

    if (game.frameCount % 50 < 35) {
        drawText('TRYCK ENTER FÖRSÖK IGEN', GAME_W / 2 - 70, 200, PAL.green, 1);
    }
}

// ============================================================
//  CUTSCENE: Post-Boss Sequence (Medborgarhuset → SKRAECKOEDLAN)
// ============================================================
function updateCutscene() {
    game.cutsceneTimer--;

    // Allow skip during concert
    if (game.cutscenePhase === 'concert' && game.cutsceneTimer < 700 && keys['Enter']) {
        game.state = 'victory';
        keys['Enter'] = false;
        return;
    }

    if (game.cutsceneTimer <= 0) {
        switch (game.cutscenePhase) {
            case 'fadeout':
                game.cutscenePhase = 'medborgarhuset';
                game.cutsceneTimer = 420;
                break;
            case 'medborgarhuset':
                game.cutscenePhase = 'concert_intro';
                game.cutsceneTimer = 180;
                playSkraeckoedlanMusic();
                break;
            case 'concert_intro':
                game.cutscenePhase = 'concert';
                game.cutsceneTimer = 900;
                break;
            case 'concert':
                game.state = 'victory';
                break;
        }
    }
}

function drawCutscene() {
    switch (game.cutscenePhase) {
        case 'fadeout':
            drawCutsceneFadeout();
            break;
        case 'medborgarhuset':
            drawCutsceneMedborgarhuset();
            break;
        case 'concert_intro':
            drawCutsceneConcertIntro();
            break;
        case 'concert':
            drawCutsceneConcert();
            break;
    }
}

function drawCutsceneFadeout() {
    bctx.fillStyle = '#000000';
    bctx.fillRect(0, 0, GAME_W, GAME_H);
    const progress = 1 - (game.cutsceneTimer / 120);
    if (progress > 0.3) {
        drawText('BANDET ÄR KROSSAT!', GAME_W/2 - 58, GAME_H/2 - 20, PAL.red, 1);
    }
    if (progress > 0.6) {
        if (game.frameCount % 40 < 30) {
            drawText('GÅ TILL MEDBORGARHUSET!', GAME_W/2 - 70, GAME_H/2 + 5, PAL.yellow, 1);
        }
    }
}

function drawCutsceneMedborgarhuset() {
    // Evening sky
    bctx.fillStyle = '#0a0a2a';
    bctx.fillRect(0, 0, GAME_W, GAME_H * 0.6);

    // Stars
    for (let i = 0; i < 20; i++) {
        const sx = (i * 73 + 10) % GAME_W;
        const sy = (i * 37 + 5) % (GAME_H * 0.4);
        if ((game.frameCount + i * 13) % 30 < 25) {
            drawPixel(sx, sy, '#ffffff');
        }
    }

    // Ground
    bctx.fillStyle = '#333333';
    bctx.fillRect(0, GAME_H - 40, GAME_W, 40);
    bctx.fillStyle = '#444444';
    bctx.fillRect(0, GAME_H - 42, GAME_W, 3);
    bctx.fillStyle = '#666666';
    bctx.fillRect(0, GAME_H - 52, GAME_W, 12);

    // Street lamp left
    drawRect(40, GAME_H - 120, 2, 80, '#555555');
    drawRect(36, GAME_H - 122, 10, 4, '#444444');
    drawPixel(38, GAME_H - 124, '#ffdd88');
    drawPixel(39, GAME_H - 124, '#ffdd88');
    drawPixel(40, GAME_H - 124, '#ffdd88');
    drawPixel(41, GAME_H - 124, '#ffdd88');
    drawPixel(42, GAME_H - 124, '#ffdd88');

    // Street lamp right
    drawRect(GAME_W - 42, GAME_H - 120, 2, 80, '#555555');
    drawRect(GAME_W - 46, GAME_H - 122, 10, 4, '#444444');
    drawPixel(GAME_W - 44, GAME_H - 124, '#ffdd88');
    drawPixel(GAME_W - 43, GAME_H - 124, '#ffdd88');
    drawPixel(GAME_W - 42, GAME_H - 124, '#ffdd88');
    drawPixel(GAME_W - 41, GAME_H - 124, '#ffdd88');

    // === MEDBORGARHUSET BUILDING ===
    const bx = GAME_W/2 - 60;
    const by = GAME_H - 120;

    // Main building
    drawRect(bx, by, 120, 70, '#ddcc88');
    drawRect(bx + 2, by + 2, 116, 66, '#ccbb77');
    // Roof
    drawRect(bx, by - 8, 120, 10, '#aa6633');
    drawRect(bx - 4, by - 4, 128, 5, '#8B4513');
    drawRect(bx + 2, by - 7, 116, 2, '#996633');

    // Windows top row
    for (let wi = 0; wi < 4; wi++) {
        const wx = bx + 12 + wi * 28;
        drawRect(wx, by + 10, 16, 14, '#224466');
        drawRect(wx + 1, by + 11, 14, 12, '#335577');
        drawRect(wx + 7, by + 10, 2, 14, '#ccbb77');
        drawRect(wx, by + 16, 16, 2, '#ccbb77');
        drawRect(wx + 2, by + 12, 5, 3, '#557799');
        drawRect(wx + 9, by + 12, 5, 3, '#557799');
    }

    // Bottom windows
    drawRect(bx + 12, by + 35, 16, 18, '#224466');
    drawRect(bx + 13, by + 36, 14, 16, '#335577');
    drawRect(bx + 92, by + 35, 16, 18, '#224466');
    drawRect(bx + 93, by + 36, 14, 16, '#335577');

    // Door
    drawRect(bx + 46, by + 32, 28, 36, '#553311');
    drawRect(bx + 48, by + 34, 24, 34, '#664422');
    drawRect(bx + 48, by + 34, 24, 2, '#775533');
    drawRect(bx + 59, by + 34, 2, 34, '#553311');
    drawPixel(bx + 56, by + 50, '#ccaa44');
    drawPixel(bx + 63, by + 50, '#ccaa44');

    // Sign
    drawRect(bx + 10, by - 18, 100, 12, '#663322');
    drawRect(bx + 12, by - 16, 96, 8, '#884433');
    drawText('MEDBORGARHUSET', bx + 18, by - 15, PAL.yellow, 1);

    // Lamp above door
    drawRect(bx + 55, by + 28, 10, 4, '#333333');
    for (let li = 0; li < 5; li++) {
        drawPixel(bx + 57 + li, by + 32, '#ffdd88');
    }

    // === CHARACTERS ===
    const elapsed = 420 - game.cutsceneTimer;

    // Player W.IKATTI walks in from left (first ~60 frames)
    const playerTargetX = bx + 20;
    const px = Math.min(elapsed * 2, playerTargetX);
    const py = GAME_H - 68;
    const walkFrame = elapsed < 60 ? Math.floor(elapsed / 6) % 4 : 0;

    // W.IKATTI sprite
    drawRect(px + 2, py, 10, 3, '#444444');
    drawRect(px + 3, py + 3, 8, 6, PAL.peach);
    drawPixel(px + 5, py + 5, PAL.black);
    drawPixel(px + 8, py + 5, PAL.black);
    drawPixel(px + 6, py + 7, '#cc9977');
    drawPixel(px + 7, py + 7, '#cc9977');
    drawRect(px + 2, py + 9, 10, 8, '#2244aa');
    drawRect(px + 1, py + 10, 2, 6, PAL.peach);
    drawRect(px + 11, py + 10, 2, 6, PAL.peach);
    if (walkFrame % 2 === 0) {
        drawRect(px + 3, py + 17, 3, 5, '#222244');
        drawRect(px + 8, py + 17, 3, 5, '#222244');
    } else {
        drawRect(px + 2, py + 17, 3, 5, '#222244');
        drawRect(px + 9, py + 17, 3, 5, '#222244');
    }
    drawRect(px + 2, py + 22, 4, 2, '#111111');
    drawRect(px + 7, py + 22, 4, 2, '#111111');

    // Näringslivsplaneraren appears at door after 90 frames
    if (elapsed > 90) {
        const npx = bx + 70;
        const npy = GAME_H - 68;
        // Hair
        drawRect(npx + 2, npy, 10, 3, '#332211');
        // Head
        drawRect(npx + 3, npy + 3, 8, 6, PAL.peach);
        // Glasses
        drawRect(npx + 4, npy + 4, 3, 3, '#333333');
        drawRect(npx + 8, npy + 4, 3, 3, '#333333');
        drawPixel(npx + 7, npy + 5, '#333333');
        drawPixel(npx + 5, npy + 5, '#3366aa');
        drawPixel(npx + 9, npy + 5, '#3366aa');
        drawPixel(npx + 7, npy + 7, '#cc9977');
        // Suit body
        drawRect(npx + 2, npy + 9, 10, 8, '#222222');
        drawRect(npx + 4, npy + 9, 6, 8, '#333333');
        // Red tie
        drawRect(npx + 6, npy + 9, 2, 6, '#cc2222');
        // Arms
        drawRect(npx + 1, npy + 10, 2, 6, '#222222');
        drawRect(npx + 11, npy + 10, 2, 6, '#222222');
        // Briefcase
        drawRect(npx + 12, npy + 15, 6, 4, '#8B4513');
        drawRect(npx + 13, npy + 14, 4, 1, '#aa6633');
        // Legs
        drawRect(npx + 3, npy + 17, 3, 5, '#111111');
        drawRect(npx + 8, npy + 17, 3, 5, '#111111');
        // Shoes
        drawRect(npx + 2, npy + 22, 4, 2, '#222222');
        drawRect(npx + 7, npy + 22, 4, 2, '#222222');
    }

    // === DIALOGUE BOX ===
    const dialogueY = GAME_H - 36;
    drawRect(4, dialogueY - 2, GAME_W - 8, 34, '#000000');
    drawRect(6, dialogueY, GAME_W - 12, 30, '#111122');
    drawRect(6, dialogueY, GAME_W - 12, 2, '#333355');

    if (elapsed < 120) {
        drawText('...', GAME_W/2 - 10, dialogueY + 10, PAL.grey, 1);
    } else if (elapsed < 200) {
        drawText('W.IKATTI:', 12, dialogueY + 4, PAL.green, 1);
        drawText('RIFF RAFF RUFF ÄR BORTA!', 12, dialogueY + 16, PAL.white, 1);
    } else if (elapsed < 260) {
        drawText('W.IKATTI:', 12, dialogueY + 4, PAL.green, 1);
        drawText('VI BEHÖVER ETT RIKTIGT BAND!', 12, dialogueY + 16, PAL.white, 1);
    } else if (elapsed < 320) {
        drawText('NÄRINGSLIVSPLANERAREN:', 12, dialogueY + 4, PAL.orange, 1);
        drawText('HMMMM...', 12, dialogueY + 16, PAL.white, 1);
    } else if (elapsed < 380) {
        drawText('NÄRINGSLIVSPLANERAREN:', 12, dialogueY + 4, PAL.orange, 1);
        drawText('JAG RINGER SKRAECKOEDLAN!', 12, dialogueY + 16, PAL.yellow, 1);
    } else {
        drawText('W.IKATTI:', 12, dialogueY + 4, PAL.green, 1);
        drawText('YEEEEEES!', 12, dialogueY + 16, PAL.yellow, 2);
    }
}

function drawCutsceneConcertIntro() {
    bctx.fillStyle = '#000000';
    bctx.fillRect(0, 0, GAME_W, GAME_H);

    const progress = 1 - (game.cutsceneTimer / 180);

    if (progress > 0.1) {
        // Fire glow around text
        for (let i = 0; i < 30; i++) {
            const fx = GAME_W/2 - 80 + i * 5.5 + Math.sin(game.frameCount * 0.1 + i) * 3;
            const fy = GAME_H/2 - 30 + Math.sin(game.frameCount * 0.15 + i * 0.5) * 5;
            const colors = ['#ff4400', '#ff6600', '#ff8800', '#ffaa00'];
            drawPixel(Math.floor(fx), Math.floor(fy), colors[i % 4]);
            drawPixel(Math.floor(fx), Math.floor(fy) - 1, colors[(i + 1) % 4]);
        }

        // Cactus left
        const cx1 = GAME_W/2 - 110;
        const cy1 = GAME_H/2 - 10;
        drawRect(cx1, cy1, 4, 20, '#2d5a1e');
        drawRect(cx1 - 4, cy1 + 5, 4, 3, '#2d5a1e');
        drawRect(cx1 - 4, cy1 + 2, 2, 6, '#2d5a1e');
        drawRect(cx1 + 4, cy1 + 8, 4, 3, '#2d5a1e');
        drawRect(cx1 + 6, cy1 + 5, 2, 6, '#2d5a1e');
        drawPixel(cx1 - 1, cy1 + 3, '#558833');
        drawPixel(cx1 + 4, cy1 + 7, '#558833');

        // Cactus right
        const cx2 = GAME_W/2 + 110;
        drawRect(cx2, cy1, 4, 20, '#2d5a1e');
        drawRect(cx2 - 4, cy1 + 8, 4, 3, '#2d5a1e');
        drawRect(cx2 - 4, cy1 + 5, 2, 6, '#2d5a1e');
        drawRect(cx2 + 4, cy1 + 5, 4, 3, '#2d5a1e');
        drawRect(cx2 + 6, cy1 + 2, 2, 6, '#2d5a1e');
        drawPixel(cx2 - 1, cy1 + 7, '#558833');
        drawPixel(cx2 + 4, cy1 + 3, '#558833');

        // Shadow text
        drawText('SKRAECKOEDLAN', GAME_W/2 - 79, GAME_H/2 - 21, '#882200', 2);
        // Main text
        drawText('SKRAECKOEDLAN', GAME_W/2 - 78, GAME_H/2 - 22, '#ff6600', 2);
    }

    if (progress > 0.4) {
        drawText('SPELAR PÅ OSKARSPARKEN!', GAME_W/2 - 70, GAME_H/2 + 10, PAL.yellow, 1);
    }

    if (progress > 0.7) {
        if (game.frameCount % 30 < 22) {
            drawText('SUPER HEAVY DOOM STONER ROCK', GAME_W/2 - 86, GAME_H/2 + 30, PAL.red, 1);
        }
    }
}

function drawCutsceneConcert() {
    // Night sky
    bctx.fillStyle = '#050520';
    bctx.fillRect(0, 0, GAME_W, 120);
    bctx.fillStyle = '#0a0a30';
    bctx.fillRect(0, 80, GAME_W, 40);

    // Stars
    for (let i = 0; i < 40; i++) {
        const sx = (i * 73 + 17) % GAME_W;
        const sy = (i * 31 + 3) % 80;
        if ((game.frameCount + i * 11) % 40 < 35) {
            drawPixel(sx, sy, i % 3 === 0 ? '#aaaaff' : '#ffffff');
        }
    }

    // Park ground (Oskarsparken)
    bctx.fillStyle = '#1a3a0a';
    bctx.fillRect(0, 120, GAME_W, 120);
    bctx.fillStyle = '#1e4010';
    bctx.fillRect(0, 120, GAME_W, 3);

    // Trees in background
    for (let t = 0; t < 6; t++) {
        const tx = 10 + t * 75;
        drawRect(tx + 6, 95, 4, 28, '#3a2a1a');
        drawRect(tx, 82, 16, 16, '#1a4a0a');
        drawRect(tx + 2, 78, 12, 6, '#226622');
        drawRect(tx + 4, 75, 8, 5, '#2d5a1e');
    }

    // === STAGE ===
    const stageX = 60;
    const stageW = 280;
    const stageY = 125;

    // Stage platform
    drawRect(stageX, stageY, stageW, 8, '#5a3a1a');
    drawRect(stageX + 2, stageY + 1, stageW - 4, 3, '#6a4a2a');
    drawRect(stageX, stageY + 8, stageW, 3, '#4a2a0a');
    // Stage legs
    drawRect(stageX + 10, stageY + 8, 4, 22, '#4a2a0a');
    drawRect(stageX + stageW - 14, stageY + 8, 4, 22, '#4a2a0a');
    drawRect(stageX + stageW/2 - 2, stageY + 8, 4, 22, '#4a2a0a');

    // Stage back wall
    drawRect(stageX + 5, stageY - 60, stageW - 10, 61, '#111111');
    drawRect(stageX + 7, stageY - 58, stageW - 14, 57, '#1a1a1a');

    // === BIG "SKRAECKOEDLAN" SIGN ===
    const signW = 210;
    const signX = GAME_W/2 - signW/2;
    const signY = stageY - 58;
    const glowPhase = game.frameCount % 30 < 15;
    drawRect(signX - 2, signY - 2, signW + 4, 20, glowPhase ? '#cc4400' : '#ff5500');
    drawRect(signX, signY, signW, 16, '#000000');
    drawText('SKRAECKOEDLAN', signX + 14, signY + 2, '#ff6600', 2);

    // === ORANGE SPEAKERS (LEFT) ===
    const spkLx = stageX + 8;
    const spkY = stageY - 48;
    // Top cab
    drawRect(spkLx, spkY, 34, 18, '#cc6600');
    drawRect(spkLx + 1, spkY + 1, 32, 16, '#dd7700');
    drawRect(spkLx + 3, spkY + 3, 12, 12, '#111111');
    drawRect(spkLx + 19, spkY + 3, 12, 12, '#111111');
    drawRect(spkLx + 5, spkY + 5, 8, 8, '#222222');
    drawRect(spkLx + 21, spkY + 5, 8, 8, '#222222');
    drawPixel(spkLx + 9, spkY + 9, '#333333');
    drawPixel(spkLx + 25, spkY + 9, '#333333');
    // Bottom cab
    drawRect(spkLx, spkY + 18, 34, 24, '#cc6600');
    drawRect(spkLx + 1, spkY + 19, 32, 22, '#dd7700');
    drawRect(spkLx + 3, spkY + 21, 12, 8, '#111111');
    drawRect(spkLx + 19, spkY + 21, 12, 8, '#111111');
    drawRect(spkLx + 5, spkY + 23, 8, 4, '#222222');
    drawRect(spkLx + 21, spkY + 23, 8, 4, '#222222');
    drawRect(spkLx + 3, spkY + 31, 12, 8, '#111111');
    drawRect(spkLx + 19, spkY + 31, 12, 8, '#111111');
    drawRect(spkLx + 5, spkY + 33, 8, 4, '#222222');
    drawRect(spkLx + 21, spkY + 33, 8, 4, '#222222');
    // "ORANGE" text on speaker
    drawText('ORANGE', spkLx, spkY + 43, '#ffaa00', 1);

    // === ORANGE SPEAKERS (RIGHT) ===
    const spkRx = stageX + stageW - 42;
    drawRect(spkRx, spkY, 34, 18, '#cc6600');
    drawRect(spkRx + 1, spkY + 1, 32, 16, '#dd7700');
    drawRect(spkRx + 3, spkY + 3, 12, 12, '#111111');
    drawRect(spkRx + 19, spkY + 3, 12, 12, '#111111');
    drawRect(spkRx + 5, spkY + 5, 8, 8, '#222222');
    drawRect(spkRx + 21, spkY + 5, 8, 8, '#222222');
    drawPixel(spkRx + 9, spkY + 9, '#333333');
    drawPixel(spkRx + 25, spkY + 9, '#333333');
    drawRect(spkRx, spkY + 18, 34, 24, '#cc6600');
    drawRect(spkRx + 1, spkY + 19, 32, 22, '#dd7700');
    drawRect(spkRx + 3, spkY + 21, 12, 8, '#111111');
    drawRect(spkRx + 19, spkY + 21, 12, 8, '#111111');
    drawRect(spkRx + 5, spkY + 23, 8, 4, '#222222');
    drawRect(spkRx + 21, spkY + 23, 8, 4, '#222222');
    drawRect(spkRx + 3, spkY + 31, 12, 8, '#111111');
    drawRect(spkRx + 19, spkY + 31, 12, 8, '#111111');
    drawRect(spkRx + 5, spkY + 33, 8, 4, '#222222');
    drawRect(spkRx + 21, spkY + 33, 8, 4, '#222222');
    drawText('ORANGE', spkRx, spkY + 43, '#ffaa00', 1);

    // Speaker vibration waves
    if (game.frameCount % 4 < 2) {
        for (let sw = 0; sw < 3; sw++) {
            drawPixel(spkLx - 3 - sw * 2, spkY + 10 + sw * 3, '#ff8800');
            drawPixel(spkRx + 36 + sw * 2, spkY + 10 + sw * 3, '#ff8800');
        }
    }

    // === CACTUSES ON STAGE ===
    // Cactus 1 (left of band)
    const cac1x = stageX + 55;
    const cacY = stageY - 30;
    drawRect(cac1x, cacY, 5, 26, '#2d5a1e');
    drawRect(cac1x + 1, cacY + 1, 3, 24, '#3a7a2a');
    drawRect(cac1x - 5, cacY + 8, 5, 3, '#2d5a1e');
    drawRect(cac1x - 5, cacY + 4, 2, 7, '#2d5a1e');
    drawRect(cac1x + 5, cacY + 12, 5, 3, '#2d5a1e');
    drawRect(cac1x + 8, cacY + 8, 2, 7, '#2d5a1e');
    drawPixel(cac1x - 1, cacY + 5, '#558833');
    drawPixel(cac1x + 5, cacY + 10, '#558833');
    drawPixel(cac1x + 2, cacY - 1, '#558833');

    // Cactus 2 (right of band)
    const cac2x = stageX + stageW - 68;
    drawRect(cac2x, cacY + 4, 4, 22, '#2d5a1e');
    drawRect(cac2x + 1, cacY + 5, 2, 20, '#3a7a2a');
    drawRect(cac2x - 4, cacY + 12, 4, 3, '#2d5a1e');
    drawRect(cac2x - 4, cacY + 9, 2, 6, '#2d5a1e');
    drawRect(cac2x + 4, cacY + 8, 4, 3, '#2d5a1e');
    drawRect(cac2x + 6, cacY + 5, 2, 6, '#2d5a1e');
    drawPixel(cac2x - 1, cacY + 10, '#558833');
    drawPixel(cac2x + 4, cacY + 6, '#558833');

    // Cactus 3 (small, behind drummer)
    const cac3x = GAME_W/2 + 30;
    drawRect(cac3x, cacY + 10, 3, 16, '#2d5a1e');
    drawRect(cac3x + 1, cacY + 11, 1, 14, '#3a7a2a');
    drawRect(cac3x + 3, cacY + 15, 3, 2, '#2d5a1e');
    drawRect(cac3x + 4, cacY + 13, 2, 4, '#2d5a1e');

    // === BAND MEMBERS (SKRAECKOEDLAN) ===
    const bob = Math.sin(game.frameCount * 0.15) * 2;
    const armSwing = Math.sin(game.frameCount * 0.2) * 3;

    // GUITARIST (left-center) - long hair, beard, black shirt
    const gx = stageX + 85;
    const gy = stageY - 26 + Math.floor(bob);
    drawRect(gx, gy, 12, 5, '#553311');
    drawRect(gx - 1, gy + 3, 14, 8, '#553311');
    drawRect(gx + 2, gy + 2, 8, 6, PAL.peach);
    drawPixel(gx + 4, gy + 4, PAL.black);
    drawPixel(gx + 7, gy + 4, PAL.black);
    drawRect(gx + 3, gy + 6, 6, 3, '#443322');
    drawRect(gx + 1, gy + 10, 10, 8, '#111111');
    drawRect(gx + 3, gy + 11, 6, 2, '#cc4400');
    drawRect(gx - 2, gy + 11, 3, 6, PAL.peach);
    drawRect(gx + 11, gy + 11 + Math.floor(armSwing), 3, 6, PAL.peach);
    // Guitar
    drawRect(gx + 2, gy + 13, 8, 5, '#aa3322');
    drawRect(gx + 10, gy + 14, 10, 2, '#886611');
    drawPixel(gx + 5, gy + 15, '#ffcc00');
    drawRect(gx + 2, gy + 18, 3, 6, '#222222');
    drawRect(gx + 7, gy + 18, 3, 6, '#222222');

    // BASSIST (right-center) - very long black hair, thick beard
    const bsx = stageX + stageW - 105;
    const bsy = stageY - 26 + Math.floor(bob * 0.8);
    drawRect(bsx, bsy, 12, 4, '#222222');
    drawRect(bsx - 1, bsy + 2, 14, 10, '#222222');
    drawRect(bsx + 2, bsy + 2, 8, 6, PAL.peach);
    drawPixel(bsx + 4, bsy + 4, PAL.black);
    drawPixel(bsx + 7, bsy + 4, PAL.black);
    drawRect(bsx + 3, bsy + 6, 6, 4, '#111111');
    drawRect(bsx + 1, bsy + 11, 10, 8, '#1a1a2a');
    drawRect(bsx + 3, bsy + 12, 6, 2, '#2d5a1e');
    drawRect(bsx - 2, bsy + 12, 3, 6, PAL.peach);
    drawRect(bsx + 11, bsy + 12 - Math.floor(armSwing * 0.7), 3, 6, PAL.peach);
    // Bass guitar
    drawRect(bsx + 2, bsy + 14, 10, 4, '#5a2a1a');
    drawRect(bsx + 12, bsy + 15, 12, 2, '#886611');
    drawRect(bsx + 2, bsy + 19, 3, 6, '#222222');
    drawRect(bsx + 7, bsy + 19, 3, 6, '#222222');

    // DRUMMER (center back) - hair, beard, behind kit
    const ddx = GAME_W/2 - 6;
    const ddy = stageY - 24 + Math.floor(bob * 0.5);
    // Drum kit
    drawRect(ddx - 12, stageY - 10, 10, 7, '#666666');
    drawRect(ddx + 14, stageY - 10, 10, 7, '#666666');
    drawRect(ddx - 2, stageY - 14, 16, 10, '#555555');
    drawRect(ddx, stageY - 16, 12, 2, '#777777');
    drawRect(ddx - 10, stageY - 18, 8, 1, '#ccaa00');
    drawRect(ddx + 14, stageY - 18, 8, 1, '#ccaa00');
    drawRect(ddx - 7, stageY - 17, 1, 7, '#555555');
    drawRect(ddx + 18, stageY - 17, 1, 7, '#555555');
    // Drummer body
    drawRect(ddx + 2, ddy, 8, 4, '#443311');
    drawRect(ddx + 3, ddy + 4, 6, 5, PAL.peach);
    drawPixel(ddx + 4, ddy + 6, PAL.black);
    drawPixel(ddx + 7, ddy + 6, PAL.black);
    drawRect(ddx + 3, ddy + 7, 6, 2, '#553322');
    drawRect(ddx + 1, ddy + 9, 10, 7, '#111111');
    // Drumstick arms (animated)
    const stickAng = Math.floor(Math.sin(game.frameCount * 0.3) * 3);
    drawRect(ddx - 2, ddy + 10 + stickAng, 3, 2, PAL.peach);
    drawRect(ddx - 4, ddy + 11 + stickAng, 4, 1, '#DAA520');
    drawRect(ddx + 11, ddy + 10 - stickAng, 3, 2, PAL.peach);
    drawRect(ddx + 13, ddy + 11 - stickAng, 4, 1, '#DAA520');

    // === STAGE LIGHTS ===
    for (let sli = 0; sli < 5; sli++) {
        const lx = stageX + 30 + sli * 55;
        if ((game.frameCount + sli * 15) % 40 < 30) {
            const lc = sli % 2 === 0 ? PAL.red : PAL.blue;
            drawPixel(lx, stageY - 59, lc);
            drawPixel(lx + 1, stageY - 59, lc);
            for (let beam = 0; beam < 6; beam++) {
                const beamX = lx + Math.floor(beam * (sli < 2 ? 1.5 : -1.5));
                const beamY = stageY - 57 + beam * 8;
                if (beamY < stageY) drawPixel(beamX, beamY, lc);
            }
        }
    }

    // === CROWD ===
    // Row 1 (further away, smaller)
    for (let ci = 0; ci < 35; ci++) {
        const cx = 5 + ci * 11.5 + Math.sin(game.frameCount * 0.1 + ci) * 2;
        const cy = 155 + Math.sin(game.frameCount * 0.15 + ci * 0.7) * 3 + (ci % 2) * 8;
        const hc = ci % 3 === 0 ? PAL.peach : (ci % 3 === 1 ? '#ddaa88' : '#bb9977');
        const hairC = ci % 4 === 0 ? '#333333' : (ci % 4 === 1 ? '#664422' : (ci % 4 === 2 ? '#222222' : '#884433'));
        drawRect(Math.floor(cx), Math.floor(cy), 6, 6, hc);
        drawRect(Math.floor(cx), Math.floor(cy) - 2, 6, 3, hairC);
        if ((game.frameCount + ci * 7) % 30 < 15) {
            drawRect(Math.floor(cx) - 1, Math.floor(cy) - 5, 2, 4, hc);
            drawRect(Math.floor(cx) + 5, Math.floor(cy) - 4, 2, 3, hc);
        }
    }
    // Row 2 (closer, bigger)
    for (let ci = 0; ci < 20; ci++) {
        const cx = 3 + ci * 20 + Math.sin(game.frameCount * 0.12 + ci * 1.3) * 3;
        const cy = 185 + Math.sin(game.frameCount * 0.13 + ci * 0.9) * 2;
        const hc = ci % 2 === 0 ? PAL.peach : '#ddaa88';
        const hairC = ci % 3 === 0 ? '#222222' : '#553322';
        drawRect(Math.floor(cx), Math.floor(cy), 8, 8, hc);
        drawRect(Math.floor(cx), Math.floor(cy) - 3, 8, 4, hairC);
        if ((game.frameCount + ci * 5) % 25 < 12) {
            drawRect(Math.floor(cx) - 2, Math.floor(cy) - 7, 2, 5, hc);
            drawRect(Math.floor(cx) + 8, Math.floor(cy) - 6, 2, 4, hc);
        }
    }
    // Crowd base
    bctx.fillStyle = '#0a0a0a';
    bctx.fillRect(0, 205, GAME_W, 35);
    for (let ci = 0; ci < 40; ci++) {
        const cx = ci * 10 + Math.sin(game.frameCount * 0.08 + ci) * 2;
        drawRect(Math.floor(cx), 202, 8, 10, ci % 2 === 0 ? '#222222' : '#1a1a1a');
    }

    // === HUD ===
    if (game.frameCount % 60 < 45) {
        drawText('SKRAECKOEDLAN LIVE', GAME_W/2 - 56, 5, '#ff6600', 1);
    }
    drawText('OSKARSPARKEN - VÄNNÄSDAGARNA', GAME_W/2 - 86, 15, PAL.green, 1);

    const concertElapsed = 900 - game.cutsceneTimer;
    if (concertElapsed > 300 && game.frameCount % 50 < 35) {
        drawText('TRYCK ENTER', GAME_W/2 - 34, GAME_H - 8, PAL.grey, 1);
    }
}

function drawVictoryScreen() {
    bctx.fillStyle = '#001a00';
    bctx.fillRect(0, 0, GAME_W, GAME_H);

    // Fireworks
    for (let i = 0; i < 5; i++) {
        const fx = 50 + Math.sin(game.frameCount * 0.03 + i * 2) * 150;
        const fy = 30 + Math.cos(game.frameCount * 0.04 + i * 1.5) * 20;
        const colors = [PAL.red, PAL.yellow, PAL.green, PAL.blue, PAL.pink];
        for (let j = 0; j < 8; j++) {
            const angle = (j / 8) * Math.PI * 2 + game.frameCount * 0.05;
            const dist = 5 + Math.sin(game.frameCount * 0.1) * 3;
            drawPixel(fx + Math.cos(angle) * dist, fy + Math.sin(angle) * dist, colors[i]);
        }
    }

    drawText('SEGER!', GAME_W / 2 - 36, 50, PAL.green, 2);

    if (game.level === 3) {
        // Level 3 victory - SKRAECKOEDLAN rocks Vännäsdagarna!
        drawText('W.IKATTI RÄDDADE', GAME_W / 2 - 50, 80, PAL.white, 1);
        drawText('VÄNNÄSDAGARNA!', GAME_W / 2 - 44, 92, PAL.yellow, 1);

        // Mini stage with SKRAECKOEDLAN
        const cx = GAME_W / 2;
        // Stage platform
        drawRect(cx - 50, 120, 100, 5, '#553322');
        drawRect(cx - 48, 118, 96, 3, '#664433');

        // Mini ORANGE speakers
        drawRect(cx - 45, 108, 14, 12, '#cc6600');
        drawRect(cx - 44, 109, 12, 10, '#dd7700');
        drawRect(cx - 42, 111, 4, 4, '#111111');
        drawRect(cx - 36, 111, 4, 4, '#111111');
        drawRect(cx + 31, 108, 14, 12, '#cc6600');
        drawRect(cx + 32, 109, 12, 10, '#dd7700');
        drawRect(cx + 34, 111, 4, 4, '#111111');
        drawRect(cx + 40, 111, 4, 4, '#111111');

        // Cactus
        drawRect(cx - 2, 100, 4, 18, '#2d5a1e');
        drawRect(cx - 6, 106, 4, 2, '#2d5a1e');
        drawRect(cx - 6, 103, 2, 5, '#2d5a1e');
        drawRect(cx + 4, 108, 4, 2, '#2d5a1e');
        drawRect(cx + 6, 105, 2, 5, '#2d5a1e');

        // Band silhouettes rocking
        const vBob = Math.sin(game.frameCount * 0.15) * 1;
        drawRect(cx - 25, 110 + Math.floor(vBob), 6, 10, '#111111');
        drawRect(cx - 24, 107 + Math.floor(vBob), 4, 4, '#111111');
        drawRect(cx + 6, 110 + Math.floor(-vBob), 6, 10, '#111111');
        drawRect(cx + 7, 107 + Math.floor(-vBob), 4, 4, '#111111');
        drawRect(cx + 20, 110 + Math.floor(vBob * 0.5), 6, 10, '#111111');
        drawRect(cx + 21, 107 + Math.floor(vBob * 0.5), 4, 4, '#111111');

        drawText('SKRAECKOEDLAN', cx - 40, 128, '#ff6600', 1);
        drawText('ROCKADE VÄNNÄSDAGARNA!', cx - 66, 140, PAL.orange, 1);

    } else if (game.level === 2) {
        // Level 2 victory - Kocken defeated
        drawText('W.IKATTI BESEGRADE', GAME_W / 2 - 56, 85, PAL.white, 1);
        drawText('KOCKEN OCH HANS', GAME_W / 2 - 48, 97, PAL.white, 1);
        drawText('BLÖTA POMMES FRITES!', GAME_W / 2 - 62, 112, PAL.yellow, 1);

        // Chef hat and frying pan pixel art
        drawRect(GAME_W / 2 - 10, 125, 20, 5, PAL.white);
        drawRect(GAME_W / 2 - 7, 118, 14, 8, PAL.white);
        drawRect(GAME_W / 2 - 5, 130, 10, 8, PAL.peach);
        drawRect(GAME_W / 2 - 3, 133, 6, 2, '#884422');
        drawRect(GAME_W / 2 + 12, 132, 8, 2, '#555555');
        drawRect(GAME_W / 2 + 18, 130, 6, 5, '#444444');
        drawRect(GAME_W / 2 + 19, 128, 1, 3, PAL.yellow);
        drawRect(GAME_W / 2 + 21, 129, 1, 2, PAL.yellow);
        drawRect(GAME_W / 2 + 20, 129, 1, 2, '#ccaa00');

        drawText('FRASSES ÄR STÄNGT!', GAME_W / 2 - 56, 148, PAL.red, 1);
    } else {
        // Level 1 victory
        drawText('W.IKATTI BESEGRADE', GAME_W / 2 - 56, 85, PAL.white, 1);
        drawText('KOCKEN OCH HANS', GAME_W / 2 - 48, 97, PAL.white, 1);
        drawText('BLÖTA POMMES FRITES!', GAME_W / 2 - 62, 112, PAL.yellow, 1);

        // Chef hat and frying pan pixel art
        drawRect(GAME_W / 2 - 10, 125, 20, 5, PAL.white);
        drawRect(GAME_W / 2 - 7, 118, 14, 8, PAL.white);
        drawRect(GAME_W / 2 - 5, 130, 10, 8, PAL.peach);
        drawRect(GAME_W / 2 - 3, 133, 6, 2, '#884422');
        drawRect(GAME_W / 2 + 12, 132, 8, 2, '#555555');
        drawRect(GAME_W / 2 + 18, 130, 6, 5, '#444444');
        drawRect(GAME_W / 2 + 19, 128, 1, 3, PAL.yellow);
        drawRect(GAME_W / 2 + 21, 129, 1, 2, PAL.yellow);
        drawRect(GAME_W / 2 + 20, 129, 1, 2, '#ccaa00');

        drawText('FRASSES ÄR STÄNGT!', GAME_W / 2 - 56, 148, PAL.red, 1);
    }

    drawText('SLUTPOÄNG', GAME_W / 2 - 28, 158, PAL.grey, 1);
    drawText(String(game.score).padStart(6, '0'), GAME_W / 2 - 20, 170, PAL.yellow, 2);

    if (game.frameCount % 50 < 35) {
        drawText('TRYCK ENTER FÖR OMSTART', GAME_W / 2 - 72, 200, PAL.green, 1);
    }
}

// ============================================================
//  GAME LOOP
// ============================================================
function update() {
    game.frameCount++;

    if (game.shakeTimer > 0) game.shakeTimer--;

    switch (game.state) {
        case 'title':
            if (keys['Enter'] || keys['Space']) {
                game.state = 'playing';
                initLevel();
                playMusic();
                keys['Enter'] = false;
                keys['Space'] = false;
            }
            break;

        case 'playing':
            updatePlayer();
            updateEnemies();
            updateParticles();
            if (game.flashTimer > 0) game.flashTimer--;
            break;

        case 'cutscene':
            updateCutscene();
            break;

        case 'gameover':
        case 'victory':
            if (keys['Enter']) {
                game.state = 'title';
                keys['Enter'] = false;
                stopMusic();
            }
            break;
    }
}

function draw() {
    // Clear buffer
    bctx.fillStyle = PAL.black;
    bctx.fillRect(0, 0, GAME_W, GAME_H);

    // Apply screen shake
    let shakeX = 0, shakeY = 0;
    if (game.shakeTimer > 0) {
        shakeX = (Math.random() - 0.5) * game.shakeIntensity;
        shakeY = (Math.random() - 0.5) * game.shakeIntensity;
    }
    bctx.save();
    bctx.translate(shakeX, shakeY);

    switch (game.state) {
        case 'title':
            drawTitleScreen();
            break;

        case 'playing':
            if (game.level === 3) {
                // Outdoor park/streets level
                drawLevel3Sky();
                drawLevel3Ground();
                drawLevel3Areas();
            } else if (game.level === 2) {
                // Indoor hotel level
                drawIndoorBackground();
                drawIndoorRooms();
            } else {
                // Outdoor Vännäs level
                drawSky();
                drawTivoliLightsBg();
                drawBackground();
                drawDecorations();
                drawBuildings();
                drawStreet();
            }
            drawPickups();
            drawPukeProjectiles();
            drawDogPoops();
            drawDiscProjectiles();
            drawPuckProjectiles();
            drawEnemies();
            drawPlayer();
            drawBullets();
            drawParticles();
            if (game.level === 3) {
                drawHUDLevel3();
            } else if (game.level === 2) {
                drawHUDLevel2();
            } else {
                drawHUD();
            }

            // Gun pickup message
            if (game.gunMessageTimer > 0) {
                game.gunMessageTimer--;
                if (game.gunMessageTimer % 8 < 6) {
                    drawRect(GAME_W / 2 - 74, 42, 148, 18, '#000000');
                    drawRect(GAME_W / 2 - 72, 43, 144, 16, '#332200');
                    drawText('DU FICK ETT VAPEN!', GAME_W / 2 - 56, 45, PAL.yellow, 1);
                    drawText('TRYCK X FÖR ATT SKJUTA', GAME_W / 2 - 68, 53, PAL.orange, 1);
                }
            }

            // Level transition fade
            if (game.enteringHotel) {
                const fadeProgress = 1 - (game.enterHotelTimer / 90);
                bctx.fillStyle = '#000000';
                bctx.globalAlpha = fadeProgress;
                bctx.fillRect(0, 0, GAME_W, GAME_H);
                bctx.globalAlpha = 1;
                if (fadeProgress > 0.3) {
                    drawText('HOTELL VÄNNÄS', GAME_W / 2 - 40, GAME_H / 2 - 5, PAL.yellow, 1);
                }
            }
            if (game.enteringLevel3) {
                const fadeProgress = 1 - (game.enterLevel3Timer / 90);
                bctx.fillStyle = '#000000';
                bctx.globalAlpha = fadeProgress;
                bctx.fillRect(0, 0, GAME_W, GAME_H);
                bctx.globalAlpha = 1;
                if (fadeProgress > 0.3) {
                    drawText('MYRANPARKEN', GAME_W / 2 - 34, GAME_H / 2 - 5, PAL.green, 1);
                }
            }

            // Damage flash overlay
            if (game.flashTimer > 0) {
                bctx.fillStyle = game.flashColor;
                bctx.globalAlpha = 0.2;
                bctx.fillRect(0, 0, GAME_W, GAME_H);
                bctx.globalAlpha = 1;
            }
            break;

        case 'gameover':
            drawGameOverScreen();
            break;

        case 'cutscene':
            drawCutscene();
            break;

        case 'victory':
            drawVictoryScreen();
            break;
    }

    bctx.restore();

    // Scale buffer to main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(buf, 0, 0, canvas.width, canvas.height);
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Start!
gameLoop();

    </script>
</body>
</html>
